/*
 * # Semantic UI - 2.4.1
 * https://github.com/Semantic-Org/Semantic-UI
 * http://www.semantic-ui.com/
 *
 * Copyright 2014 Contributors
 * Released under the MIT license
 * http://opensource.org/licenses/MIT
 *
 */
!(function (p, h, v, b) {
  p.site = p.fn.site = function (e) {
    let s; let l; let i = (new Date()).getTime(); let o = []; const t = e; const n = typeof t === 'string'; const c = [].slice.call(arguments, 1); const u = p.isPlainObject(e) ? p.extend(!0, {}, p.site.settings, e) : p.extend({}, p.site.settings); const a = u.namespace; const d = u.error; const r = `module-${a}`; const f = p(v); const m = this; let g = f.data(r); return s = {
      initialize() { s.instantiate(); },
      instantiate() { s.verbose('Storing instance of site', s), g = s, f.data(r, s); },
      normalize() { s.fix.console(), s.fix.requestAnimationFrame(); },
      fix: { console() { s.debug('Normalizing window.console'), console !== b && console.log !== b || (s.verbose('Console not available, normalizing events'), s.disable.console()), void 0 !== console.group && void 0 !== console.groupEnd && void 0 !== console.groupCollapsed || (s.verbose('Console group not available, normalizing events'), h.console.group = function () {}, h.console.groupEnd = function () {}, h.console.groupCollapsed = function () {}), void 0 === console.markTimeline && (s.verbose('Mark timeline not available, normalizing events'), h.console.markTimeline = function () {}); }, consoleClear() { s.debug('Disabling programmatic console clearing'), h.console.clear = function () {}; }, requestAnimationFrame() { s.debug('Normalizing requestAnimationFrame'), h.requestAnimationFrame === b && (s.debug('RequestAnimationFrame not available, normalizing event'), h.requestAnimationFrame = h.requestAnimationFrame || h.mozRequestAnimationFrame || h.webkitRequestAnimationFrame || h.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }); } },
      moduleExists(e) { return p.fn[e] !== b && p.fn[e].settings !== b; },
      enabled: { modules(e) { const n = []; return e = e || u.modules, p.each(e, (e, t) => { s.moduleExists(t) && n.push(t); }), n; } },
      disabled: { modules(e) { const n = []; return e = e || u.modules, p.each(e, (e, t) => { s.moduleExists(t) || n.push(t); }), n; } },
      change: { setting(o, a, e, r) { e = typeof e === 'string' ? e === 'all' ? u.modules : [e] : e || u.modules, r = r === b || r, p.each(e, (e, t) => { let n; const i = !s.moduleExists(t) || (p.fn[t].settings.namespace || !1); s.moduleExists(t) && (s.verbose('Changing default setting', o, a, t), p.fn[t].settings[o] = a, r && i && (n = p(`:data(module-${i})`)).length > 0 && (s.verbose('Modifying existing settings', n), n[t]('setting', o, a))); }); }, settings(i, e, o) { e = typeof e === 'string' ? [e] : e || u.modules, o = o === b || o, p.each(e, (e, t) => { let n; s.moduleExists(t) && (s.verbose('Changing default setting', i, t), p.extend(!0, p.fn[t].settings, i), o && a && (n = p(`:data(module-${a})`)).length > 0 && (s.verbose('Modifying existing settings', n), n[t]('setting', i))); }); } },
      enable: { console() { s.console(!0); }, debug(e, t) { e = e || u.modules, s.debug('Enabling debug for modules', e), s.change.setting('debug', !0, e, t); }, verbose(e, t) { e = e || u.modules, s.debug('Enabling verbose debug for modules', e), s.change.setting('verbose', !0, e, t); } },
      disable: { console() { s.console(!1); }, debug(e, t) { e = e || u.modules, s.debug('Disabling debug for modules', e), s.change.setting('debug', !1, e, t); }, verbose(e, t) { e = e || u.modules, s.debug('Disabling verbose debug for modules', e), s.change.setting('verbose', !1, e, t); } },
      console(e) {
        if (e) { if (g.cache.console === b) return void s.error(d.console); s.debug('Restoring console function'), h.console = g.cache.console; } else {
          s.debug('Disabling console function'), g.cache.console = h.console, h.console = {
            clear() {}, error() {}, group() {}, groupCollapsed() {}, groupEnd() {}, info() {}, log() {}, markTimeline() {}, warn() {},
          };
        }
      },
      destroy() { s.verbose('Destroying previous site for', f), f.removeData(r); },
      cache: {},
      setting(e, t) { if (p.isPlainObject(e))p.extend(!0, u, e); else { if (t === b) return u[e]; u[e] = t; } },
      internal(e, t) { if (p.isPlainObject(e))p.extend(!0, s, e); else { if (t === b) return s[e]; s[e] = t; } },
      debug() { u.debug && (u.performance ? s.performance.log(arguments) : (s.debug = Function.prototype.bind.call(console.info, console, `${u.name}:`), s.debug.apply(console, arguments))); },
      verbose() { u.verbose && u.debug && (u.performance ? s.performance.log(arguments) : (s.verbose = Function.prototype.bind.call(console.info, console, `${u.name}:`), s.verbose.apply(console, arguments))); },
      error() { s.error = Function.prototype.bind.call(console.error, console, `${u.name}:`), s.error.apply(console, arguments); },
      performance: {
        log(e) {
          let t; let n; u.performance && (n = (t = (new Date()).getTime()) - (i || t), i = t, o.push({
            Element: m, Name: e[0], Arguments: [].slice.call(e, 1) || '', 'Execution Time': n,
          })), clearTimeout(s.performance.timer), s.performance.timer = setTimeout(s.performance.display, 500);
        },
        display() { let e = `${u.name}:`; let n = 0; i = !1, clearTimeout(s.performance.timer), p.each(o, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, (console.group !== b || console.table !== b) && o.length > 0 && (console.groupCollapsed(e), console.table ? console.table(o) : p.each(o, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), o = []; },
      },
      invoke(i, e, t) { let o; let a; let n; let r = g; return e = e || c, t = m || t, typeof i === 'string' && r !== b && (i = i.split(/[\. ]/), o = i.length - 1, p.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (p.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== b) return a = r[n], !1; if (!p.isPlainObject(r[t]) || e == o) return r[t] !== b ? a = r[t] : s.error(d.method, i), !1; r = r[t]; } })), p.isFunction(a) ? n = a.apply(t, e) : a !== b && (n = a), p.isArray(l) ? l.push(n) : l !== b ? l = [l, n] : n !== b && (l = n), a; },
    }, n ? (g === b && s.initialize(), s.invoke(t)) : (g !== b && s.destroy(), s.initialize()), l !== b ? l : this;
  }, p.site.settings = {
    name: 'Site',
    namespace: 'site',
    error: { console: 'Console cannot be restored, most likely it was overwritten outside of module', method: 'The method you called is not defined.' },
    debug: !1,
    verbose: !1,
    performance: !0,
    modules: ['accordion', 'api', 'checkbox', 'dimmer', 'dropdown', 'embed', 'form', 'modal', 'nag', 'popup', 'rating', 'shape', 'sidebar', 'state', 'sticky', 'tab', 'transition', 'visit', 'visibility'],
    siteNamespace: 'site',
    namespaceStub: {
      cache: {}, config: {}, sections: {}, section: {}, utilities: {},
    },
  }, p.extend(p.expr[':'], { data: p.expr.createPseudo ? p.expr.createPseudo((t) => function (e) { return !!p.data(e, t); }) : function (e, t, n) { return !!p.data(e, n[3]); } });
}(jQuery, window, document)), (function (F, e, O, D) {
  e = void 0 !== e && e.Math == Math ? e : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), F.fn.form = function (x) {
    let C; const w = F(this); const S = w.selector || ''; let k = (new Date()).getTime(); let T = []; const A = x; const R = arguments[1]; const P = typeof A === 'string'; const E = [].slice.call(arguments, 1); return w.each(function () {
      let n; let l; let t; let e; let d; let c; let u; let f; let m; let i; let s; let o; let a; let g; let p; let h; const r = F(this); const v = this; let b = []; let y = !1; (h = {
        initialize() { h.get.settings(), P ? (p === D && h.instantiate(), h.invoke(A)) : (p !== D && p.invoke('destroy'), h.verbose('Initializing form validation', r, d), h.bindEvents(), h.set.defaults(), h.instantiate()); },
        instantiate() { h.verbose('Storing instance of module', h), p = h, r.data(a, h); },
        destroy() { h.verbose('Destroying previous module', p), h.removeEvents(), r.removeData(a); },
        refresh() { h.verbose('Refreshing selector cache'), n = r.find(f.field), l = r.find(f.group), t = r.find(f.message), r.find(f.prompt), e = r.find(f.submit), r.find(f.clear), r.find(f.reset); },
        submit() { h.verbose('Submitting form', r), r.submit(); },
        attachEvents(e, t) { t = t || 'submit', F(e).on(`click${g}`, (e) => { h[t](), e.preventDefault(); }); },
        bindEvents() {
          h.verbose('Attaching form events'), r.on(`submit${g}`, h.validate.form).on(`blur${g}`, f.field, h.event.field.blur).on(`click${g}`, f.submit, h.submit).on(`click${g}`, f.reset, h.reset)
            .on(`click${g}`, f.clear, h.clear), d.keyboardShortcuts && r.on(`keydown${g}`, f.field, h.event.field.keydown), n.each(function () { const e = F(this); const t = e.prop('type'); const n = h.get.changeEvent(t, e); F(this).on(n + g, h.event.field.change); });
        },
        clear() { n.each(function () { const e = F(this); const t = e.parent(); const n = e.closest(l); const i = n.find(f.prompt); const o = e.data(u.defaultValue) || ''; const a = t.is(f.uiCheckbox); const r = t.is(f.uiDropdown); n.hasClass(m.error) && (h.verbose('Resetting error on field', n), n.removeClass(m.error), i.remove()), r ? (h.verbose('Resetting dropdown value', t, o), t.dropdown('clear')) : a ? e.prop('checked', !1) : (h.verbose('Resetting field value', e, o), e.val('')); }); },
        reset() { n.each(function () { const e = F(this); const t = e.parent(); const n = e.closest(l); const i = n.find(f.prompt); const o = e.data(u.defaultValue); const a = t.is(f.uiCheckbox); const r = t.is(f.uiDropdown); const s = n.hasClass(m.error); o !== D && (s && (h.verbose('Resetting error on field', n), n.removeClass(m.error), i.remove()), r ? (h.verbose('Resetting dropdown value', t, o), t.dropdown('restore defaults')) : a ? (h.verbose('Resetting checkbox value', t, o), e.prop('checked', o)) : (h.verbose('Resetting field value', e, o), e.val(o))); }); },
        determine: { isValid() { let n = !0; return F.each(c, (e, t) => { h.validate.field(t, e, !0) || (n = !1); }), n; } },
        is: {
          bracketedRule(e) { return e.type && e.type.match(d.regExp.bracket); }, shorthandFields(e) { const t = e[Object.keys(e)[0]]; return h.is.shorthandRules(t); }, shorthandRules(e) { return typeof e === 'string' || F.isArray(e); }, empty(e) { return !e || e.length === 0 || (e.is('input[type="checkbox"]') ? !e.is(':checked') : h.is.blank(e)); }, blank(e) { return F.trim(e.val()) === ''; }, valid(e) { let n = !0; return e ? (h.verbose('Checking if field is valid', e), h.validate.field(c[e], e, !1)) : (h.verbose('Checking if form is valid'), F.each(c, (e, t) => { h.is.valid(e) || (n = !1); }), n); },
        },
        removeEvents() { r.off(g), n.off(g), e.off(g), n.off(g); },
        event: {
          field: {
            keydown(e) { const t = F(this); const n = e.which; const i = t.is(f.input); const o = t.is(f.checkbox); const a = t.closest(f.uiDropdown).length > 0; const r = 13; n == 27 && (h.verbose('Escape key pressed blurring field'), t.blur()), e.ctrlKey || n != r || !i || a || o || (y || (t.one(`keyup${g}`, h.event.field.keyup), h.submit(), h.debug('Enter pressed on input submitting form')), y = !0); }, keyup() { y = !1; }, blur(e) { const t = F(this); const n = t.closest(l); const i = h.get.validation(t); n.hasClass(m.error) ? (h.debug('Revalidating field', t, i), i && h.validate.field(i)) : d.on == 'blur' && i && h.validate.field(i); }, change(e) { const t = F(this); const n = t.closest(l); const i = h.get.validation(t); i && (d.on == 'change' || n.hasClass(m.error) && d.revalidate) && (clearTimeout(h.timer), h.timer = setTimeout(() => { h.debug('Revalidating field', t, h.get.validation(t)), h.validate.field(i); }, d.delay)); },
          },
        },
        get: {
          ancillaryValue(e) { return !(!e.type || !e.value && !h.is.bracketedRule(e)) && (e.value !== D ? e.value : `${e.type.match(d.regExp.bracket)[1]}`); }, ruleName(e) { return h.is.bracketedRule(e) ? e.type.replace(e.type.match(d.regExp.bracket)[0], '') : e.type; }, changeEvent(e, t) { return e == 'checkbox' || e == 'radio' || e == 'hidden' || t.is('select') ? 'change' : h.get.inputEvent(); }, inputEvent() { return O.createElement('input').oninput !== D ? 'input' : O.createElement('input').onpropertychange !== D ? 'propertychange' : 'keyup'; }, fieldsFromShorthand(e) { const i = {}; return F.each(e, (n, e) => { typeof e === 'string' && (e = [e]), i[n] = { rules: [] }, F.each(e, (e, t) => { i[n].rules.push({ type: t }); }); }), i; }, prompt(e, t) { let n; let i; const o = h.get.ruleName(e); const a = h.get.ancillaryValue(e); const r = h.get.field(t.identifier); const s = r.val(); let l = F.isFunction(e.prompt) ? e.prompt(s) : e.prompt || d.prompt[o] || d.text.unspecifiedRule; const c = l.search('{value}') !== -1; const u = l.search('{name}') !== -1; return c && (l = l.replace('{value}', r.val())), u && (i = (n = r.closest(f.group).find('label').eq(0)).length == 1 ? n.text() : r.prop('placeholder') || d.text.unspecifiedField, l = l.replace('{name}', i)), l = (l = l.replace('{identifier}', t.identifier)).replace('{ruleValue}', a), e.prompt || h.verbose('Using default validation prompt for type', l, o), l; }, settings() { if (F.isPlainObject(x)) { const e = Object.keys(x); e.length > 0 && (x[e[0]].identifier !== D && x[e[0]].rules !== D) ? (d = F.extend(!0, {}, F.fn.form.settings, R), c = F.extend({}, F.fn.form.settings.defaults, x), h.error(d.error.oldSyntax, v), h.verbose('Extending settings from legacy parameters', c, d)) : (x.fields && h.is.shorthandFields(x.fields) && (x.fields = h.get.fieldsFromShorthand(x.fields)), d = F.extend(!0, {}, F.fn.form.settings, x), c = F.extend({}, F.fn.form.settings.defaults, d.fields), h.verbose('Extending settings', c, d)); } else d = F.fn.form.settings, c = F.fn.form.settings.defaults, h.verbose('Using default form validation', c, d); o = d.namespace, u = d.metadata, f = d.selector, m = d.className, i = d.regExp, s = d.error, a = `module-${o}`, g = `.${o}`, p = r.data(a), h.refresh(); }, field(e) { return h.verbose('Finding field with identifier', e), e = h.escape.string(e), n.filter(`#${e}`).length > 0 ? n.filter(`#${e}`) : n.filter(`[name="${e}"]`).length > 0 ? n.filter(`[name="${e}"]`) : n.filter(`[name="${e}[]"]`).length > 0 ? n.filter(`[name="${e}[]"]`) : n.filter(`[data-${u.validate}="${e}"]`).length > 0 ? n.filter(`[data-${u.validate}="${e}"]`) : F('<input/>'); }, fields(e) { let n = F(); return F.each(e, (e, t) => { n = n.add(h.get.field(t)); }), n; }, validation(n) { let i; let o; return !!c && (F.each(c, (e, t) => { o = t.identifier || e, h.get.field(o)[0] == n[0] && (t.identifier = o, i = t); }), i || !1); }, value(e) { const t = []; return t.push(e), h.get.values.call(v, t)[e]; }, values(e) { const t = F.isArray(e) ? h.get.fields(e) : n; const c = {}; return t.each((e, t) => { const n = F(t); let i = (n.prop('type'), n.prop('name')); const o = n.val(); const a = n.is(f.checkbox); const r = n.is(f.radio); const s = i.indexOf('[]') !== -1; const l = !!a && n.is(':checked'); i && (s ? (i = i.replace('[]', ''), c[i] || (c[i] = []), a ? l ? c[i].push(o || !0) : c[i].push(!1) : c[i].push(o)) : r ? c[i] !== D && c[i] != 0 || (c[i] = !!l && (o || !0)) : c[i] = a ? !!l && (o || !0) : o); }), c; },
        },
        has: { field(e) { return h.verbose('Checking for existence of a field with identifier', e), typeof (e = h.escape.string(e)) !== 'string' && h.error(s.identifier, e), n.filter(`#${e}`).length > 0 || (n.filter(`[name="${e}"]`).length > 0 || n.filter(`[data-${u.validate}="${e}"]`).length > 0); } },
        escape: { string(e) { return (e = String(e)).replace(i.escape, '\\$&'); } },
        add: {
          rule(e, t) { h.add.field(e, t); }, field(n, e) { const i = {}; h.is.shorthandRules(e) ? (e = F.isArray(e) ? e : [e], i[n] = { rules: [] }, F.each(e, (e, t) => { i[n].rules.push({ type: t }); })) : i[n] = e, c = F.extend({}, c, i), h.debug('Adding rules', i, c); }, fields(e) { let t; t = e && h.is.shorthandFields(e) ? h.get.fieldsFromShorthand(e) : e, c = F.extend({}, c, t); }, prompt(e, t) { const n = h.get.field(e).closest(l); let i = n.children(f.prompt); const o = i.length !== 0; t = typeof t === 'string' ? [t] : t, h.verbose('Adding field error state', e), n.addClass(m.error), d.inline && (o || (i = d.templates.prompt(t)).appendTo(n), i.html(t[0]), o ? h.verbose('Inline errors are disabled, no inline error added', e) : d.transition && F.fn.transition !== D && r.transition('is supported') ? (h.verbose('Displaying error with css transition', d.transition), i.transition(`${d.transition} in`, d.duration)) : (h.verbose('Displaying error with fallback javascript animation'), i.fadeIn(d.duration))); }, errors(e) { h.debug('Adding form error messages', e), h.set.error(), t.html(d.templates.error(e)); },
        },
        remove: {
          rule(n, e) { const i = F.isArray(e) ? e : [e]; if (e == D) return h.debug('Removed all rules'), void (c[n].rules = []); c[n] != D && F.isArray(c[n].rules) && F.each(c[n].rules, (e, t) => { i.indexOf(t.type) !== -1 && (h.debug('Removed rule', t.type), c[n].rules.splice(e, 1)); }); }, field(e) { const t = F.isArray(e) ? e : [e]; F.each(t, (e, t) => { h.remove.rule(t); }); }, rules(e, n) { F.isArray(e) ? F.each(fields, (e, t) => { h.remove.rule(t, n); }) : h.remove.rule(e, n); }, fields(e) { h.remove.field(e); }, prompt(e) { const t = h.get.field(e).closest(l); const n = t.children(f.prompt); t.removeClass(m.error), d.inline && n.is(':visible') && (h.verbose('Removing prompt for field', e), d.transition && F.fn.transition !== D && r.transition('is supported') ? n.transition(`${d.transition} out`, d.duration, () => { n.remove(); }) : n.fadeOut(d.duration, () => { n.remove(); })); },
        },
        set: {
          success() { r.removeClass(m.error).addClass(m.success); }, defaults() { n.each(function () { const e = F(this); const t = e.filter(f.checkbox).length > 0 ? e.is(':checked') : e.val(); e.data(u.defaultValue, t); }); }, error() { r.removeClass(m.success).addClass(m.error); }, value(e, t) { const n = {}; return n[e] = t, h.set.values.call(v, n); }, values(e) { F.isEmptyObject(e) || F.each(e, (e, t) => { let n; const i = h.get.field(e); let o = i.parent(); const a = F.isArray(t); const r = o.is(f.uiCheckbox); const s = o.is(f.uiDropdown); const l = i.is(f.radio) && r; i.length > 0 && (a && r ? (h.verbose('Selecting multiple', t, i), o.checkbox('uncheck'), F.each(t, (e, t) => { n = i.filter(`[value="${t}"]`), o = n.parent(), n.length > 0 && o.checkbox('check'); })) : l ? (h.verbose('Selecting radio value', t, i), i.filter(`[value="${t}"]`).parent(f.uiCheckbox).checkbox('check')) : r ? (h.verbose('Setting checkbox value', t, o), !0 === t ? o.checkbox('check') : o.checkbox('uncheck')) : s ? (h.verbose('Setting dropdown value', t, o), o.dropdown('set selected', t)) : (h.verbose('Setting field value', t, i), i.val(t))); }); },
        },
        validate: { form(e, t) { const n = h.get.values(); if (y) return !1; if (b = [], h.determine.isValid()) { if (h.debug('Form has no validation errors, submitting'), h.set.success(), !0 !== t) return d.onSuccess.call(v, e, n); } else if (h.debug('Form has errors'), h.set.error(), d.inline || h.add.errors(b), r.data('moduleApi') !== D && e.stopImmediatePropagation(), !0 !== t) return d.onFailure.call(v, b, n); }, field(n, e, t) { t = t === D || t, typeof n === 'string' && (h.verbose('Validating field', n), n = c[e = n]); const i = n.identifier || e; const o = h.get.field(i); const a = !!n.depends && h.get.field(n.depends); let r = !0; const s = []; return n.identifier || (h.debug('Using field name as identifier', i), n.identifier = i), o.prop('disabled') ? (h.debug('Field is disabled. Skipping', i), r = !0) : n.optional && h.is.blank(o) ? (h.debug('Field is optional and blank. Skipping', i), r = !0) : n.depends && h.is.empty(a) ? (h.debug('Field depends on another value that is not present or empty. Skipping', a), r = !0) : n.rules !== D && F.each(n.rules, (e, t) => { h.has.field(i) && !h.validate.rule(n, t) && (h.debug('Field is invalid', i, t.type), s.push(h.get.prompt(t, n)), r = !1); }), r ? (t && (h.remove.prompt(i, s), d.onValid.call(o)), !0) : (t && (b = b.concat(s), h.add.prompt(i, s), d.onInvalid.call(o, s)), !1); }, rule(e, t) { const n = h.get.field(e.identifier); let i = (t.type, n.val()); const o = h.get.ancillaryValue(t); const a = h.get.ruleName(t); const r = d.rules[a]; if (F.isFunction(r)) return i = i === D || i === '' || i === null ? '' : F.trim(`${i}`), r.call(n, i, o); h.error(s.noRule, a); } },
        setting(e, t) { if (F.isPlainObject(e))F.extend(!0, d, e); else { if (t === D) return d[e]; d[e] = t; } },
        internal(e, t) { if (F.isPlainObject(e))F.extend(!0, h, e); else { if (t === D) return h[e]; h[e] = t; } },
        debug() { !d.silent && d.debug && (d.performance ? h.performance.log(arguments) : (h.debug = Function.prototype.bind.call(console.info, console, `${d.name}:`), h.debug.apply(console, arguments))); },
        verbose() { !d.silent && d.verbose && d.debug && (d.performance ? h.performance.log(arguments) : (h.verbose = Function.prototype.bind.call(console.info, console, `${d.name}:`), h.verbose.apply(console, arguments))); },
        error() { d.silent || (h.error = Function.prototype.bind.call(console.error, console, `${d.name}:`), h.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; d.performance && (n = (t = (new Date()).getTime()) - (k || t), k = t, T.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: v, 'Execution Time': n,
            })), clearTimeout(h.performance.timer), h.performance.timer = setTimeout(h.performance.display, 500);
          },
          display() { let e = `${d.name}:`; let n = 0; k = !1, clearTimeout(h.performance.timer), F.each(T, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, S && (e += ` '${S}'`), w.length > 1 && (e += ` (${w.length})`), (console.group !== D || console.table !== D) && T.length > 0 && (console.groupCollapsed(e), console.table ? console.table(T) : F.each(T, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), T = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = p; return e = e || E, t = v || t, typeof i === 'string' && r !== D && (i = i.split(/[\. ]/), o = i.length - 1, F.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (F.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== D) return a = r[n], !1; if (!F.isPlainObject(r[t]) || e == o) return r[t] !== D && (a = r[t]), !1; r = r[t]; } })), F.isFunction(a) ? n = a.apply(t, e) : a !== D && (n = a), F.isArray(C) ? C.push(n) : C !== D ? C = [C, n] : n !== D && (C = n), a; },
      }).initialize();
    }), C !== D ? C : this;
  }, F.fn.form.settings = {
    name: 'Form',
    namespace: 'form',
    debug: !1,
    verbose: !1,
    performance: !0,
    fields: !1,
    keyboardShortcuts: !0,
    on: 'submit',
    inline: !1,
    delay: 200,
    revalidate: !0,
    transition: 'scale',
    duration: 200,
    onValid() {},
    onInvalid() {},
    onSuccess() { return !0; },
    onFailure() { return !1; },
    metadata: { defaultValue: 'default', validate: 'validate' },
    regExp: {
      htmlID: /^[a-zA-Z][\w:.-]*$/g, bracket: /\[(.*)\]/i, decimal: /^\d+\.?\d*$/, email: /^[a-z0-9!#$%&'*+\/=?^_`{|}~.-]+@[a-z0-9]([a-z0-9-]*[a-z0-9])?(\.[a-z0-9]([a-z0-9-]*[a-z0-9])?)*$/i, escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, flags: /^\/(.*)\/(.*)?/, integer: /^\-?\d+$/, number: /^\-?\d*(\.\d+)?$/, url: /(https?:\/\/(?:www\.|(?!www))[^\s\.]+\.[^\s]{2,}|www\.[^\s]+\.[^\s]{2,})/i,
    },
    text: { unspecifiedRule: 'Please enter a valid value', unspecifiedField: 'This field' },
    prompt: {
      empty: '{name} must have a value', checked: '{name} must be checked', email: '{name} must be a valid e-mail', url: '{name} must be a valid url', regExp: '{name} is not formatted correctly', integer: '{name} must be an integer', decimal: '{name} must be a decimal number', number: '{name} must be set to a number', is: '{name} must be "{ruleValue}"', isExactly: '{name} must be exactly "{ruleValue}"', not: '{name} cannot be set to "{ruleValue}"', notExactly: '{name} cannot be set to exactly "{ruleValue}"', contain: '{name} must contain "{ruleValue}"', containExactly: '{name} must contain exactly "{ruleValue}"', doesntContain: '{name} cannot contain  "{ruleValue}"', doesntContainExactly: '{name} cannot contain exactly "{ruleValue}"', minLength: '{name} must be at least {ruleValue} characters', length: '{name} must be at least {ruleValue} characters', exactLength: '{name} must be exactly {ruleValue} characters', maxLength: '{name} cannot be longer than {ruleValue} characters', match: '{name} must match {ruleValue} field', different: '{name} must have a different value than {ruleValue} field', creditCard: '{name} must be a valid credit card number', minCount: '{name} must have at least {ruleValue} choices', exactCount: '{name} must have exactly {ruleValue} choices', maxCount: '{name} must have {ruleValue} or less choices',
    },
    selector: {
      checkbox: 'input[type="checkbox"], input[type="radio"]', clear: '.clear', field: 'input, textarea, select', group: '.field', input: 'input', message: '.error.message', prompt: '.prompt.label', radio: 'input[type="radio"]', reset: '.reset:not([type="reset"])', submit: '.submit:not([type="submit"])', uiCheckbox: '.ui.checkbox', uiDropdown: '.ui.dropdown',
    },
    className: {
      error: 'error', label: 'ui prompt label', pressed: 'down', success: 'success',
    },
    error: {
      identifier: 'You must specify a string identifier for each field', method: 'The method you called is not defined.', noRule: 'There is no rule matching the one you specified', oldSyntax: 'Starting in 2.0 forms now only take a single settings object. Validation settings converted to new syntax automatically.',
    },
    templates: { error(e) { let n = '<ul class="list">'; return F.each(e, (e, t) => { n += `<li>${t}</li>`; }), F(n += '</ul>'); }, prompt(e) { return F('<div/>').addClass('ui basic red pointing prompt label').html(e[0]); } },
    rules: {
      empty(e) { return !(e === D || e === '' || F.isArray(e) && e.length === 0); },
      checked() { return F(this).filter(':checked').length > 0; },
      email(e) { return F.fn.form.settings.regExp.email.test(e); },
      url(e) { return F.fn.form.settings.regExp.url.test(e); },
      regExp(e, t) { if (t instanceof RegExp) return e.match(t); let n; const i = t.match(F.fn.form.settings.regExp.flags); return i && (t = i.length >= 2 ? i[1] : t, n = i.length >= 3 ? i[2] : ''), e.match(new RegExp(t, n)); },
      integer(e, t) { let n; let i; let o; const a = F.fn.form.settings.regExp.integer; return t && ['', '..'].indexOf(t) === -1 && (t.indexOf('..') == -1 ? a.test(t) && (n = i = t - 0) : (o = t.split('..', 2), a.test(o[0]) && (n = o[0] - 0), a.test(o[1]) && (i = o[1] - 0))), a.test(e) && (n === D || n <= e) && (i === D || e <= i); },
      decimal(e) { return F.fn.form.settings.regExp.decimal.test(e); },
      number(e) { return F.fn.form.settings.regExp.number.test(e); },
      is(e, t) { return t = typeof t === 'string' ? t.toLowerCase() : t, (e = typeof e === 'string' ? e.toLowerCase() : e) == t; },
      isExactly(e, t) { return e == t; },
      not(e, t) { return (e = typeof e === 'string' ? e.toLowerCase() : e) != (t = typeof t === 'string' ? t.toLowerCase() : t); },
      notExactly(e, t) { return e != t; },
      contains(e, t) { return t = t.replace(F.fn.form.settings.regExp.escape, '\\$&'), e.search(new RegExp(t, 'i')) !== -1; },
      containsExactly(e, t) { return t = t.replace(F.fn.form.settings.regExp.escape, '\\$&'), e.search(new RegExp(t)) !== -1; },
      doesntContain(e, t) { return t = t.replace(F.fn.form.settings.regExp.escape, '\\$&'), e.search(new RegExp(t, 'i')) === -1; },
      doesntContainExactly(e, t) { return t = t.replace(F.fn.form.settings.regExp.escape, '\\$&'), e.search(new RegExp(t)) === -1; },
      minLength(e, t) { return e !== D && e.length >= t; },
      length(e, t) { return e !== D && e.length >= t; },
      exactLength(e, t) { return e !== D && e.length == t; },
      maxLength(e, t) { return e !== D && e.length <= t; },
      match(e, t) { let n; F(this); return F(`[data-validate="${t}"]`).length > 0 ? n = F(`[data-validate="${t}"]`).val() : F(`#${t}`).length > 0 ? n = F(`#${t}`).val() : F(`[name="${t}"]`).length > 0 ? n = F(`[name="${t}"]`).val() : F(`[name="${t}[]"]`).length > 0 && (n = F(`[name="${t}[]"]`)), n !== D && e.toString() == n.toString(); },
      different(e, t) { let n; F(this); return F(`[data-validate="${t}"]`).length > 0 ? n = F(`[data-validate="${t}"]`).val() : F(`#${t}`).length > 0 ? n = F(`#${t}`).val() : F(`[name="${t}"]`).length > 0 ? n = F(`[name="${t}"]`).val() : F(`[name="${t}[]"]`).length > 0 && (n = F(`[name="${t}[]"]`)), n !== D && e.toString() !== n.toString(); },
      creditCard(n, e) {
        let t; let i; const o = {
          visa: { pattern: /^4/, length: [16] }, amex: { pattern: /^3[47]/, length: [15] }, mastercard: { pattern: /^5[1-5]/, length: [16] }, discover: { pattern: /^(6011|622(12[6-9]|1[3-9][0-9]|[2-8][0-9]{2}|9[0-1][0-9]|92[0-5]|64[4-9])|65)/, length: [16] }, unionPay: { pattern: /^(62|88)/, length: [16, 17, 18, 19] }, jcb: { pattern: /^35(2[89]|[3-8][0-9])/, length: [16] }, maestro: { pattern: /^(5018|5020|5038|6304|6759|676[1-3])/, length: [12, 13, 14, 15, 16, 17, 18, 19] }, dinersClub: { pattern: /^(30[0-5]|^36)/, length: [14] }, laser: { pattern: /^(6304|670[69]|6771)/, length: [16, 17, 18, 19] }, visaElectron: { pattern: /^(4026|417500|4508|4844|491(3|7))/, length: [16] },
        }; let a = {}; let r = !1; const s = typeof e === 'string' && e.split(','); if (typeof n === 'string' && n.length !== 0) { if (n = n.replace(/[\-]/g, ''), s && (F.each(s, (e, t) => { (i = o[t]) && (a = { length: F.inArray(n.length, i.length) !== -1, pattern: n.search(i.pattern) !== -1 }).length && a.pattern && (r = !0); }), !r)) return !1; if ((t = { number: F.inArray(n.length, o.unionPay.length) !== -1, pattern: n.search(o.unionPay.pattern) !== -1 }).number && t.pattern) return !0; for (var l = n.length, c = 0, u = [[0, 1, 2, 3, 4, 5, 6, 7, 8, 9], [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]], d = 0; l--;)d += u[c][parseInt(n.charAt(l), 10)], c ^= 1; return d % 10 == 0 && d > 0; }
      },
      minCount(e, t) { return t == 0 || (t == 1 ? e !== '' : e.split(',').length >= t); },
      exactCount(e, t) { return t == 0 ? e === '' : t == 1 ? e !== '' && e.search(',') === -1 : e.split(',').length == t; },
      maxCount(e, t) { return t != 0 && (t == 1 ? e.search(',') === -1 : e.split(',').length <= t); },
    },
  };
}(jQuery, window, document)), (function (S, k, e, T) {
  k = void 0 !== k && k.Math == Math ? k : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), S.fn.accordion = function (a) {
    let v; const r = S(this); let b = (new Date()).getTime(); let y = []; const x = a; const C = typeof x === 'string'; const w = [].slice.call(arguments, 1); k.requestAnimationFrame || k.mozRequestAnimationFrame || k.webkitRequestAnimationFrame || k.msRequestAnimationFrame; return r.each(function () {
      let e; let c; const u = S.isPlainObject(a) ? S.extend(!0, {}, S.fn.accordion.settings, a) : S.extend({}, S.fn.accordion.settings); const d = u.className; const t = u.namespace; const f = u.selector; const s = u.error; const n = `.${t}`; const i = `module-${t}`; const o = r.selector || ''; const m = S(this); let g = m.find(f.title); let p = m.find(f.content); const l = this; let h = m.data(i); c = {
        initialize() { c.debug('Initializing', m), c.bind.events(), u.observeChanges && c.observeChanges(), c.instantiate(); },
        instantiate() { h = c, m.data(i, c); },
        destroy() { c.debug('Destroying previous instance', m), m.off(n).removeData(i); },
        refresh() { g = m.find(f.title), p = m.find(f.content); },
        observeChanges() { 'MutationObserver' in k && ((e = new MutationObserver(((e) => { c.debug('DOM tree modified, updating selector cache'), c.refresh(); }))).observe(l, { childList: !0, subtree: !0 }), c.debug('Setting up mutation observer', e)); },
        bind: { events() { c.debug('Binding delegated events'), m.on(u.on + n, f.trigger, c.event.click); } },
        event: { click() { c.toggle.call(this); } },
        toggle(e) { const t = e !== T ? typeof e === 'number' ? g.eq(e) : S(e).closest(f.title) : S(this).closest(f.title); const n = t.next(p); const i = n.hasClass(d.animating); const o = n.hasClass(d.active); const a = o && !i; const r = !o && i; c.debug('Toggling visibility of content', t), a || r ? u.collapsible ? c.close.call(t) : c.debug('Cannot close accordion content collapsing is disabled') : c.open.call(t); },
        open(e) {
          const t = e !== T ? typeof e === 'number' ? g.eq(e) : S(e).closest(f.title) : S(this).closest(f.title); const n = t.next(p); const i = n.hasClass(d.animating); n.hasClass(d.active) || i ? c.debug('Accordion already open, skipping', n) : (c.debug('Opening accordion content', t), u.onOpening.call(n), u.onChanging.call(n), u.exclusive && c.closeOthers.call(t), t.addClass(d.active), n.stop(!0, !0).addClass(d.animating), u.animateChildren && (S.fn.transition !== T && m.transition('is supported') ? n.children().transition({
            animation: 'fade in', queue: !1, useFailSafe: !0, debug: u.debug, verbose: u.verbose, duration: u.duration,
          }) : n.children().stop(!0, !0).animate({ opacity: 1 }, u.duration, c.resetOpacity)), n.slideDown(u.duration, u.easing, function () { n.removeClass(d.animating).addClass(d.active), c.reset.display.call(this), u.onOpen.call(this), u.onChange.call(this); }));
        },
        close(e) {
          const t = e !== T ? typeof e === 'number' ? g.eq(e) : S(e).closest(f.title) : S(this).closest(f.title); const n = t.next(p); const i = n.hasClass(d.animating); const o = n.hasClass(d.active); !o && !(!o && i) || o && i || (c.debug('Closing accordion content', n), u.onClosing.call(n), u.onChanging.call(n), t.removeClass(d.active), n.stop(!0, !0).addClass(d.animating), u.animateChildren && (S.fn.transition !== T && m.transition('is supported') ? n.children().transition({
            animation: 'fade out', queue: !1, useFailSafe: !0, debug: u.debug, verbose: u.verbose, duration: u.duration,
          }) : n.children().stop(!0, !0).animate({ opacity: 0 }, u.duration, c.resetOpacity)), n.slideUp(u.duration, u.easing, function () { n.removeClass(d.animating).removeClass(d.active), c.reset.display.call(this), u.onClose.call(this), u.onChange.call(this); }));
        },
        closeOthers(e) {
          let t; let n; let i; const o = e !== T ? g.eq(e) : S(this).closest(f.title); const a = o.parents(f.content).prev(f.title); const r = o.closest(f.accordion); const s = `${f.title}.${d.active}:visible`; const l = `${f.content}.${d.active}:visible`; i = u.closeNested ? (t = r.find(s).not(a)).next(p) : (t = r.find(s).not(a), n = r.find(l).find(s).not(a), (t = t.not(n)).next(p)), t.length > 0 && (c.debug('Exclusive enabled, closing other content', t), t.removeClass(d.active), i.removeClass(d.animating).stop(!0, !0), u.animateChildren && (S.fn.transition !== T && m.transition('is supported') ? i.children().transition({
            animation: 'fade out', useFailSafe: !0, debug: u.debug, verbose: u.verbose, duration: u.duration,
          }) : i.children().stop(!0, !0).animate({ opacity: 0 }, u.duration, c.resetOpacity)), i.slideUp(u.duration, u.easing, function () { S(this).removeClass(d.active), c.reset.display.call(this); }));
        },
        reset: { display() { c.verbose('Removing inline display from element', this), S(this).css('display', ''), S(this).attr('style') === '' && S(this).attr('style', '').removeAttr('style'); }, opacity() { c.verbose('Removing inline opacity from element', this), S(this).css('opacity', ''), S(this).attr('style') === '' && S(this).attr('style', '').removeAttr('style'); } },
        setting(e, t) { if (c.debug('Changing setting', e, t), S.isPlainObject(e))S.extend(!0, u, e); else { if (t === T) return u[e]; S.isPlainObject(u[e]) ? S.extend(!0, u[e], t) : u[e] = t; } },
        internal(e, t) { if (c.debug('Changing internal', e, t), t === T) return c[e]; S.isPlainObject(e) ? S.extend(!0, c, e) : c[e] = t; },
        debug() { !u.silent && u.debug && (u.performance ? c.performance.log(arguments) : (c.debug = Function.prototype.bind.call(console.info, console, `${u.name}:`), c.debug.apply(console, arguments))); },
        verbose() { !u.silent && u.verbose && u.debug && (u.performance ? c.performance.log(arguments) : (c.verbose = Function.prototype.bind.call(console.info, console, `${u.name}:`), c.verbose.apply(console, arguments))); },
        error() { u.silent || (c.error = Function.prototype.bind.call(console.error, console, `${u.name}:`), c.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; u.performance && (n = (t = (new Date()).getTime()) - (b || t), b = t, y.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: l, 'Execution Time': n,
            })), clearTimeout(c.performance.timer), c.performance.timer = setTimeout(c.performance.display, 500);
          },
          display() { let e = `${u.name}:`; let n = 0; b = !1, clearTimeout(c.performance.timer), S.each(y, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, o && (e += ` '${o}'`), (console.group !== T || console.table !== T) && y.length > 0 && (console.groupCollapsed(e), console.table ? console.table(y) : S.each(y, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), y = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = h; return e = e || w, t = l || t, typeof i === 'string' && r !== T && (i = i.split(/[\. ]/), o = i.length - 1, S.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (S.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== T) return a = r[n], !1; if (!S.isPlainObject(r[t]) || e == o) return r[t] !== T ? a = r[t] : c.error(s.method, i), !1; r = r[t]; } })), S.isFunction(a) ? n = a.apply(t, e) : a !== T && (n = a), S.isArray(v) ? v.push(n) : v !== T ? v = [v, n] : n !== T && (v = n), a; },
      }, C ? (h === T && c.initialize(), c.invoke(x)) : (h !== T && h.invoke('destroy'), c.initialize());
    }), v !== T ? v : this;
  }, S.fn.accordion.settings = {
    name: 'Accordion',
    namespace: 'accordion',
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    on: 'click',
    observeChanges: !0,
    exclusive: !0,
    collapsible: !0,
    closeNested: !1,
    animateChildren: !0,
    duration: 350,
    easing: 'easeOutQuad',
    onOpening() {},
    onClosing() {},
    onChanging() {},
    onOpen() {},
    onClose() {},
    onChange() {},
    error: { method: 'The method you called is not defined' },
    className: { active: 'active', animating: 'animating' },
    selector: {
      accordion: '.accordion', title: '.title', trigger: '.title', content: '.content',
    },
  }, S.extend(S.easing, { easeOutQuad(e, t, n, i, o) { return -i * (t /= o) * (t - 2) + n; } });
}(jQuery, window, document)), (function (T, A, R, P) {
  A = void 0 !== A && A.Math == Math ? A : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), T.fn.checkbox = function (v) {
    let b; const e = T(this); const y = e.selector || ''; let x = (new Date()).getTime(); let C = []; const w = v; const S = typeof w === 'string'; const k = [].slice.call(arguments, 1); return e.each(function () {
      let e; let s; const i = T.extend(!0, {}, T.fn.checkbox.settings, v); const t = i.className; const n = i.namespace; const o = i.selector; const l = i.error; const a = `.${n}`; const r = `module-${n}`; let c = T(this); let u = T(this).children(o.label); let d = T(this).children(o.input); let f = d[0]; let m = !1; let g = !1; let p = c.data(r); const h = this; s = {
        initialize() { s.verbose('Initializing checkbox', i), s.create.label(), s.bind.events(), s.set.tabbable(), s.hide.input(), s.observeChanges(), s.instantiate(), s.setup(); },
        instantiate() { s.verbose('Storing instance of module', s), p = s, c.data(r, s); },
        destroy() { s.verbose('Destroying module'), s.unbind.events(), s.show.input(), c.removeData(r); },
        fix: { reference() { c.is(o.input) && (s.debug('Behavior called on <input> adjusting invoked element'), c = c.closest(o.checkbox), s.refresh()); } },
        setup() { s.set.initialLoad(), s.is.indeterminate() ? (s.debug('Initial value is indeterminate'), s.indeterminate()) : s.is.checked() ? (s.debug('Initial value is checked'), s.check()) : (s.debug('Initial value is unchecked'), s.uncheck()), s.remove.initialLoad(); },
        refresh() { u = c.children(o.label), d = c.children(o.input), f = d[0]; },
        hide: { input() { s.verbose('Modifying <input> z-index to be unselectable'), d.addClass(t.hidden); } },
        show: { input() { s.verbose('Modifying <input> z-index to be selectable'), d.removeClass(t.hidden); } },
        observeChanges() { 'MutationObserver' in A && ((e = new MutationObserver(((e) => { s.debug('DOM tree modified, updating selector cache'), s.refresh(); }))).observe(h, { childList: !0, subtree: !0 }), s.debug('Setting up mutation observer', e)); },
        attachEvents(e, t) { const n = T(e); t = T.isFunction(s[t]) ? s[t] : s.toggle, n.length > 0 ? (s.debug('Attaching checkbox events to element', e, t), n.on(`click${a}`, t)) : s.error(l.notFound); },
        event: { click(e) { const t = T(e.target); t.is(o.input) ? s.verbose('Using default check action on initialized checkbox') : t.is(o.link) ? s.debug('Clicking link inside checkbox, skipping toggle') : (s.toggle(), d.focus(), e.preventDefault()); }, keydown(e) { const t = e.which; const n = 13; const i = 32; g = t == 27 ? (s.verbose('Escape key pressed blurring field'), d.blur(), !0) : !(e.ctrlKey || t != i && t != n) && (s.verbose('Enter/space key pressed, toggling checkbox'), s.toggle(), !0); }, keyup(e) { g && e.preventDefault(); } },
        check() { s.should.allowCheck() && (s.debug('Checking checkbox', d), s.set.checked(), s.should.ignoreCallbacks() || (i.onChecked.call(f), i.onChange.call(f))); },
        uncheck() { s.should.allowUncheck() && (s.debug('Unchecking checkbox'), s.set.unchecked(), s.should.ignoreCallbacks() || (i.onUnchecked.call(f), i.onChange.call(f))); },
        indeterminate() { s.should.allowIndeterminate() ? s.debug('Checkbox is already indeterminate') : (s.debug('Making checkbox indeterminate'), s.set.indeterminate(), s.should.ignoreCallbacks() || (i.onIndeterminate.call(f), i.onChange.call(f))); },
        determinate() { s.should.allowDeterminate() ? s.debug('Checkbox is already determinate') : (s.debug('Making checkbox determinate'), s.set.determinate(), s.should.ignoreCallbacks() || (i.onDeterminate.call(f), i.onChange.call(f))); },
        enable() { s.is.enabled() ? s.debug('Checkbox is already enabled') : (s.debug('Enabling checkbox'), s.set.enabled(), i.onEnable.call(f), i.onEnabled.call(f)); },
        disable() { s.is.disabled() ? s.debug('Checkbox is already disabled') : (s.debug('Disabling checkbox'), s.set.disabled(), i.onDisable.call(f), i.onDisabled.call(f)); },
        get: { radios() { const e = s.get.name(); return T(`input[name="${e}"]`).closest(o.checkbox); }, otherRadios() { return s.get.radios().not(c); }, name() { return d.attr('name'); } },
        is: {
          initialLoad() { return m; }, radio() { return d.hasClass(t.radio) || d.attr('type') == 'radio'; }, indeterminate() { return d.prop('indeterminate') !== P && d.prop('indeterminate'); }, checked() { return d.prop('checked') !== P && d.prop('checked'); }, disabled() { return d.prop('disabled') !== P && d.prop('disabled'); }, enabled() { return !s.is.disabled(); }, determinate() { return !s.is.indeterminate(); }, unchecked() { return !s.is.checked(); },
        },
        should: {
          allowCheck() { return s.is.determinate() && s.is.checked() && !s.should.forceCallbacks() ? (s.debug('Should not allow check, checkbox is already checked'), !1) : !1 !== i.beforeChecked.apply(f) || (s.debug('Should not allow check, beforeChecked cancelled'), !1); }, allowUncheck() { return s.is.determinate() && s.is.unchecked() && !s.should.forceCallbacks() ? (s.debug('Should not allow uncheck, checkbox is already unchecked'), !1) : !1 !== i.beforeUnchecked.apply(f) || (s.debug('Should not allow uncheck, beforeUnchecked cancelled'), !1); }, allowIndeterminate() { return s.is.indeterminate() && !s.should.forceCallbacks() ? (s.debug('Should not allow indeterminate, checkbox is already indeterminate'), !1) : !1 !== i.beforeIndeterminate.apply(f) || (s.debug('Should not allow indeterminate, beforeIndeterminate cancelled'), !1); }, allowDeterminate() { return s.is.determinate() && !s.should.forceCallbacks() ? (s.debug('Should not allow determinate, checkbox is already determinate'), !1) : !1 !== i.beforeDeterminate.apply(f) || (s.debug('Should not allow determinate, beforeDeterminate cancelled'), !1); }, forceCallbacks() { return s.is.initialLoad() && i.fireOnInit; }, ignoreCallbacks() { return m && !i.fireOnInit; },
        },
        can: { change() { return !(c.hasClass(t.disabled) || c.hasClass(t.readOnly) || d.prop('disabled') || d.prop('readonly')); }, uncheck() { return typeof i.uncheckable === 'boolean' ? i.uncheckable : !s.is.radio(); } },
        set: {
          initialLoad() { m = !0; }, checked() { s.verbose('Setting class to checked'), c.removeClass(t.indeterminate).addClass(t.checked), s.is.radio() && s.uncheckOthers(), s.is.indeterminate() || !s.is.checked() ? (s.verbose('Setting state to checked', f), d.prop('indeterminate', !1).prop('checked', !0), s.trigger.change()) : s.debug('Input is already checked, skipping input property change'); }, unchecked() { s.verbose('Removing checked class'), c.removeClass(t.indeterminate).removeClass(t.checked), s.is.indeterminate() || !s.is.unchecked() ? (s.debug('Setting state to unchecked'), d.prop('indeterminate', !1).prop('checked', !1), s.trigger.change()) : s.debug('Input is already unchecked'); }, indeterminate() { s.verbose('Setting class to indeterminate'), c.addClass(t.indeterminate), s.is.indeterminate() ? s.debug('Input is already indeterminate, skipping input property change') : (s.debug('Setting state to indeterminate'), d.prop('indeterminate', !0), s.trigger.change()); }, determinate() { s.verbose('Removing indeterminate class'), c.removeClass(t.indeterminate), s.is.determinate() ? s.debug('Input is already determinate, skipping input property change') : (s.debug('Setting state to determinate'), d.prop('indeterminate', !1)); }, disabled() { s.verbose('Setting class to disabled'), c.addClass(t.disabled), s.is.disabled() ? s.debug('Input is already disabled, skipping input property change') : (s.debug('Setting state to disabled'), d.prop('disabled', 'disabled'), s.trigger.change()); }, enabled() { s.verbose('Removing disabled class'), c.removeClass(t.disabled), s.is.enabled() ? s.debug('Input is already enabled, skipping input property change') : (s.debug('Setting state to enabled'), d.prop('disabled', !1), s.trigger.change()); }, tabbable() { s.verbose('Adding tabindex to checkbox'), d.attr('tabindex') === P && d.attr('tabindex', 0); },
        },
        remove: { initialLoad() { m = !1; } },
        trigger: { change() { const e = R.createEvent('HTMLEvents'); const t = d[0]; t && (s.verbose('Triggering native change event'), e.initEvent('change', !0, !1), t.dispatchEvent(e)); } },
        create: { label() { d.prevAll(o.label).length > 0 ? (d.prev(o.label).detach().insertAfter(d), s.debug('Moving existing label', u)) : s.has.label() || (u = T('<label>').insertAfter(d), s.debug('Creating label', u)); } },
        has: { label() { return u.length > 0; } },
        bind: { events() { s.verbose('Attaching checkbox events'), c.on(`click${a}`, s.event.click).on(`keydown${a}`, o.input, s.event.keydown).on(`keyup${a}`, o.input, s.event.keyup); } },
        unbind: { events() { s.debug('Removing events'), c.off(a); } },
        uncheckOthers() { const e = s.get.otherRadios(); s.debug('Unchecking other radios', e), e.removeClass(t.checked); },
        toggle() { s.can.change() ? s.is.indeterminate() || s.is.unchecked() ? (s.debug('Currently unchecked'), s.check()) : s.is.checked() && s.can.uncheck() && (s.debug('Currently checked'), s.uncheck()) : s.is.radio() || s.debug('Checkbox is read-only or disabled, ignoring toggle'); },
        setting(e, t) { if (s.debug('Changing setting', e, t), T.isPlainObject(e))T.extend(!0, i, e); else { if (t === P) return i[e]; T.isPlainObject(i[e]) ? T.extend(!0, i[e], t) : i[e] = t; } },
        internal(e, t) { if (T.isPlainObject(e))T.extend(!0, s, e); else { if (t === P) return s[e]; s[e] = t; } },
        debug() { !i.silent && i.debug && (i.performance ? s.performance.log(arguments) : (s.debug = Function.prototype.bind.call(console.info, console, `${i.name}:`), s.debug.apply(console, arguments))); },
        verbose() { !i.silent && i.verbose && i.debug && (i.performance ? s.performance.log(arguments) : (s.verbose = Function.prototype.bind.call(console.info, console, `${i.name}:`), s.verbose.apply(console, arguments))); },
        error() { i.silent || (s.error = Function.prototype.bind.call(console.error, console, `${i.name}:`), s.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; i.performance && (n = (t = (new Date()).getTime()) - (x || t), x = t, C.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: h, 'Execution Time': n,
            })), clearTimeout(s.performance.timer), s.performance.timer = setTimeout(s.performance.display, 500);
          },
          display() { let e = `${i.name}:`; let n = 0; x = !1, clearTimeout(s.performance.timer), T.each(C, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, y && (e += ` '${y}'`), (console.group !== P || console.table !== P) && C.length > 0 && (console.groupCollapsed(e), console.table ? console.table(C) : T.each(C, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), C = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = p; return e = e || k, t = h || t, typeof i === 'string' && r !== P && (i = i.split(/[\. ]/), o = i.length - 1, T.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (T.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== P) return a = r[n], !1; if (!T.isPlainObject(r[t]) || e == o) return r[t] !== P ? a = r[t] : s.error(l.method, i), !1; r = r[t]; } })), T.isFunction(a) ? n = a.apply(t, e) : a !== P && (n = a), T.isArray(b) ? b.push(n) : b !== P ? b = [b, n] : n !== P && (b = n), a; },
      }, S ? (p === P && s.initialize(), s.invoke(w)) : (p !== P && p.invoke('destroy'), s.initialize());
    }), b !== P ? b : this;
  }, T.fn.checkbox.settings = {
    name: 'Checkbox',
    namespace: 'checkbox',
    silent: !1,
    debug: !1,
    verbose: !0,
    performance: !0,
    uncheckable: 'auto',
    fireOnInit: !1,
    onChange() {},
    beforeChecked() {},
    beforeUnchecked() {},
    beforeDeterminate() {},
    beforeIndeterminate() {},
    onChecked() {},
    onUnchecked() {},
    onDeterminate() {},
    onIndeterminate() {},
    onEnable() {},
    onDisable() {},
    onEnabled() {},
    onDisabled() {},
    className: {
      checked: 'checked', indeterminate: 'indeterminate', disabled: 'disabled', hidden: 'hidden', radio: 'radio', readOnly: 'read-only',
    },
    error: { method: 'The method you called is not defined' },
    selector: {
      checkbox: '.ui.checkbox', label: 'label, .box', input: 'input[type="checkbox"], input[type="radio"]', link: 'a[href]',
    },
  };
}(jQuery, window, document)), (function (S, e, k, T) {
  e = void 0 !== e && e.Math == Math ? e : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), S.fn.dimmer = function (p) {
    let h; const v = S(this); let b = (new Date()).getTime(); let y = []; const x = p; const C = typeof x === 'string'; const w = [].slice.call(arguments, 1); return v.each(function () {
      let a; let t; let s; const r = S.isPlainObject(p) ? S.extend(!0, {}, S.fn.dimmer.settings, p) : S.extend({}, S.fn.dimmer.settings); const n = r.selector; const e = r.namespace; const i = r.className; const l = r.error; const o = `.${e}`; const c = `module-${e}`; const u = v.selector || ''; const d = 'ontouchstart' in k.documentElement ? 'touchstart' : 'click'; const f = S(this); const m = this; let g = f.data(c); (s = {
        preinitialize() { a = s.is.dimmer() ? (t = f.parent(), f) : (t = f, s.has.dimmer() ? r.dimmerName ? t.find(n.dimmer).filter(`.${r.dimmerName}`) : t.find(n.dimmer) : s.create()); },
        initialize() { s.debug('Initializing dimmer', r), s.bind.events(), s.set.dimmable(), s.instantiate(); },
        instantiate() { s.verbose('Storing instance of module', s), g = s, f.data(c, g); },
        destroy() { s.verbose('Destroying previous module', a), s.unbind.events(), s.remove.variation(), t.off(o); },
        bind: { events() { r.on == 'hover' ? t.on(`mouseenter${o}`, s.show).on(`mouseleave${o}`, s.hide) : r.on == 'click' && t.on(d + o, s.toggle), s.is.page() && (s.debug('Setting as a page dimmer', t), s.set.pageDimmer()), s.is.closable() && (s.verbose('Adding dimmer close event', a), t.on(d + o, n.dimmer, s.event.click)); } },
        unbind: { events() { f.removeData(c), t.off(o); } },
        event: { click(e) { s.verbose('Determining if event occured on dimmer', e), (a.find(e.target).length === 0 || S(e.target).is(n.content)) && (s.hide(), e.stopImmediatePropagation()); } },
        addContent(e) { const t = S(e); s.debug('Add content to dimmer', t), t.parent()[0] !== a[0] && t.detach().appendTo(a); },
        create() { const e = S(r.template.dimmer()); return r.dimmerName && (s.debug('Creating named dimmer', r.dimmerName), e.addClass(r.dimmerName)), e.appendTo(t), e; },
        show(e) { e = S.isFunction(e) ? e : function () {}, s.debug('Showing dimmer', a, r), s.set.variation(), s.is.dimmed() && !s.is.animating() || !s.is.enabled() ? s.debug('Dimmer is already shown or disabled') : (s.animate.show(e), r.onShow.call(m), r.onChange.call(m)); },
        hide(e) { e = S.isFunction(e) ? e : function () {}, s.is.dimmed() || s.is.animating() ? (s.debug('Hiding dimmer', a), s.animate.hide(e), r.onHide.call(m), r.onChange.call(m)) : s.debug('Dimmer is not visible'); },
        toggle() { s.verbose('Toggling dimmer visibility', a), s.is.dimmed() ? s.hide() : s.show(); },
        animate: {
          show(e) {
            e = S.isFunction(e) ? e : function () {}, r.useCSS && S.fn.transition !== T && a.transition('is supported') ? (r.useFlex ? (s.debug('Using flex dimmer'), s.remove.legacy()) : (s.debug('Using legacy non-flex dimmer'), s.set.legacy()), r.opacity !== 'auto' && s.set.opacity(), a.transition({
              displayType: r.useFlex ? 'flex' : 'block', animation: `${r.transition} in`, queue: !1, duration: s.get.duration(), useFailSafe: !0, onStart() { s.set.dimmed(); }, onComplete() { s.set.active(), e(); },
            })) : (s.verbose('Showing dimmer animation with javascript'), s.set.dimmed(), r.opacity == 'auto' && (r.opacity = 0.8), a.stop().css({ opacity: 0, width: '100%', height: '100%' }).fadeTo(s.get.duration(), r.opacity, () => { a.removeAttr('style'), s.set.active(), e(); }));
          },
          hide(e) {
            e = S.isFunction(e) ? e : function () {}, r.useCSS && S.fn.transition !== T && a.transition('is supported') ? (s.verbose('Hiding dimmer with css'), a.transition({
              displayType: r.useFlex ? 'flex' : 'block', animation: `${r.transition} out`, queue: !1, duration: s.get.duration(), useFailSafe: !0, onStart() { s.remove.dimmed(); }, onComplete() { s.remove.variation(), s.remove.active(), e(); },
            })) : (s.verbose('Hiding dimmer with javascript'), s.remove.dimmed(), a.stop().fadeOut(s.get.duration(), () => { s.remove.active(), a.removeAttr('style'), e(); }));
          },
        },
        get: { dimmer() { return a; }, duration() { return typeof r.duration === 'object' ? s.is.active() ? r.duration.hide : r.duration.show : r.duration; } },
        has: { dimmer() { return r.dimmerName ? f.find(n.dimmer).filter(`.${r.dimmerName}`).length > 0 : f.find(n.dimmer).length > 0; } },
        is: {
          active() { return a.hasClass(i.active); }, animating() { return a.is(':animated') || a.hasClass(i.animating); }, closable() { return r.closable == 'auto' ? r.on != 'hover' : r.closable; }, dimmer() { return f.hasClass(i.dimmer); }, dimmable() { return f.hasClass(i.dimmable); }, dimmed() { return t.hasClass(i.dimmed); }, disabled() { return t.hasClass(i.disabled); }, enabled() { return !s.is.disabled(); }, page() { return t.is('body'); }, pageDimmer() { return a.hasClass(i.pageDimmer); },
        },
        can: { show() { return !a.hasClass(i.disabled); } },
        set: {
          opacity(e) { let t = a.css('background-color'); const n = t.split(','); const i = n && n.length == 3; const o = n && n.length == 4; e = r.opacity === 0 ? 0 : r.opacity || e, t = i || o ? (n[3] = `${e})`, n.join(',')) : `rgba(0, 0, 0, ${e})`, s.debug('Setting opacity to', e), a.css('background-color', t); }, legacy() { a.addClass(i.legacy); }, active() { a.addClass(i.active); }, dimmable() { t.addClass(i.dimmable); }, dimmed() { t.addClass(i.dimmed); }, pageDimmer() { a.addClass(i.pageDimmer); }, disabled() { a.addClass(i.disabled); }, variation(e) { (e = e || r.variation) && a.addClass(e); },
        },
        remove: {
          active() { a.removeClass(i.active); }, legacy() { a.removeClass(i.legacy); }, dimmed() { t.removeClass(i.dimmed); }, disabled() { a.removeClass(i.disabled); }, variation(e) { (e = e || r.variation) && a.removeClass(e); },
        },
        setting(e, t) { if (s.debug('Changing setting', e, t), S.isPlainObject(e))S.extend(!0, r, e); else { if (t === T) return r[e]; S.isPlainObject(r[e]) ? S.extend(!0, r[e], t) : r[e] = t; } },
        internal(e, t) { if (S.isPlainObject(e))S.extend(!0, s, e); else { if (t === T) return s[e]; s[e] = t; } },
        debug() { !r.silent && r.debug && (r.performance ? s.performance.log(arguments) : (s.debug = Function.prototype.bind.call(console.info, console, `${r.name}:`), s.debug.apply(console, arguments))); },
        verbose() { !r.silent && r.verbose && r.debug && (r.performance ? s.performance.log(arguments) : (s.verbose = Function.prototype.bind.call(console.info, console, `${r.name}:`), s.verbose.apply(console, arguments))); },
        error() { r.silent || (s.error = Function.prototype.bind.call(console.error, console, `${r.name}:`), s.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; r.performance && (n = (t = (new Date()).getTime()) - (b || t), b = t, y.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: m, 'Execution Time': n,
            })), clearTimeout(s.performance.timer), s.performance.timer = setTimeout(s.performance.display, 500);
          },
          display() { let e = `${r.name}:`; let n = 0; b = !1, clearTimeout(s.performance.timer), S.each(y, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, u && (e += ` '${u}'`), v.length > 1 && (e += ` (${v.length})`), (console.group !== T || console.table !== T) && y.length > 0 && (console.groupCollapsed(e), console.table ? console.table(y) : S.each(y, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), y = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = g; return e = e || w, t = m || t, typeof i === 'string' && r !== T && (i = i.split(/[\. ]/), o = i.length - 1, S.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (S.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== T) return a = r[n], !1; if (!S.isPlainObject(r[t]) || e == o) return r[t] !== T ? a = r[t] : s.error(l.method, i), !1; r = r[t]; } })), S.isFunction(a) ? n = a.apply(t, e) : a !== T && (n = a), S.isArray(h) ? h.push(n) : h !== T ? h = [h, n] : n !== T && (h = n), a; },
      }).preinitialize(), C ? (g === T && s.initialize(), s.invoke(x)) : (g !== T && g.invoke('destroy'), s.initialize());
    }), h !== T ? h : this;
  }, S.fn.dimmer.settings = {
    name: 'Dimmer',
    namespace: 'dimmer',
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    useFlex: !0,
    dimmerName: !1,
    variation: !1,
    closable: 'auto',
    useCSS: !0,
    transition: 'fade',
    on: !1,
    opacity: 'auto',
    duration: { show: 500, hide: 500 },
    onChange() {},
    onShow() {},
    onHide() {},
    error: { method: 'The method you called is not defined.' },
    className: {
      active: 'active', animating: 'animating', dimmable: 'dimmable', dimmed: 'dimmed', dimmer: 'dimmer', disabled: 'disabled', hide: 'hide', legacy: 'legacy', pageDimmer: 'page', show: 'show',
    },
    selector: { dimmer: '> .ui.dimmer', content: '.ui.dimmer > .content, .ui.dimmer > .content > .center' },
    template: { dimmer() { return S('<div />').attr('class', 'ui dimmer'); } },
  };
}(jQuery, window, document)), (function (Y, Z, K, J) {
  Z = void 0 !== Z && Z.Math == Math ? Z : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), Y.fn.dropdown = function (M) {
    let L; let V = Y(this); const N = Y(K); const H = V.selector || ''; const U = 'ontouchstart' in K.documentElement; let W = (new Date()).getTime(); let B = []; const Q = M; const X = typeof Q === 'string'; const $ = [].slice.call(arguments, 1); return V.each(function (n) {
      let e; let t; let i; let o; let a; let r; let s; let g; const p = Y.isPlainObject(M) ? Y.extend(!0, {}, Y.fn.dropdown.settings, M) : Y.extend({}, Y.fn.dropdown.settings); const h = p.className; const c = p.message; const l = p.fields; const v = p.keys; const b = p.metadata; const u = p.namespace; const d = p.regExp; const y = p.selector; const f = p.error; const m = p.templates; const x = `.${u}`; const C = `module-${u}`; let w = Y(this); const S = Y(p.context); let k = w.find(y.text); let T = w.find(y.search); let A = w.find(y.sizer); let R = w.find(y.input); let P = w.find(y.icon); let E = w.prev().find(y.text).length > 0 ? w.prev().find(y.text) : w.prev(); let F = w.children(y.menu); let O = F.find(y.item); let D = !1; let q = !1; let j = !1; let z = this; let I = w.data(C); g = {
        initialize() { g.debug('Initializing dropdown', p), g.is.alreadySetup() ? g.setup.reference() : (g.setup.layout(), p.values && g.change.values(p.values), g.refreshData(), g.save.defaults(), g.restore.selected(), g.create.id(), g.bind.events(), g.observeChanges(), g.instantiate()); },
        instantiate() { g.verbose('Storing instance of dropdown', g), I = g, w.data(C, g); },
        destroy() { g.verbose('Destroying previous dropdown', w), g.remove.tabbable(), w.off(x).removeData(C), F.off(x), N.off(o), g.disconnect.menuObserver(), g.disconnect.selectObserver(); },
        observeChanges() { 'MutationObserver' in Z && (r = new MutationObserver(g.event.select.mutation), s = new MutationObserver(g.event.menu.mutation), g.debug('Setting up mutation observer', r, s), g.observe.select(), g.observe.menu()); },
        disconnect: { menuObserver() { s && s.disconnect(); }, selectObserver() { r && r.disconnect(); } },
        observe: { select() { g.has.input() && r.observe(w[0], { childList: !0, subtree: !0 }); }, menu() { g.has.menu() && s.observe(F[0], { childList: !0, subtree: !0 }); } },
        create: {
          id() { a = (`${Math.random().toString(16)}000000000`).substr(2, 8), o = `.${a}`, g.verbose('Creating unique id for element', a); },
          userChoice(e) {
            let n; let i; let o; return !!(e = e || g.get.userValues()) && (e = Y.isArray(e) ? e : [e], Y.each(e, (e, t) => {
              !1 === g.get.item(t) && (o = p.templates.addition(g.add.variables(c.addResult, t)), i = Y('<div />').html(o).attr(`data-${b.value}`, t).attr(`data-${b.text}`, t)
                .addClass(h.addition)
                .addClass(h.item), p.hideAdditions && i.addClass(h.hidden), n = n === J ? i : n.add(i), g.verbose('Creating user choices for value', t, i));
            }), n);
          },
          userLabels(e) { const t = g.get.userValues(); t && (g.debug('Adding user labels', t), Y.each(t, (e, t) => { g.verbose('Adding custom user value'), g.add.label(t, t); })); },
          menu() { F = Y('<div />').addClass(h.menu).appendTo(w); },
          sizer() { A = Y('<span />').addClass(h.sizer).insertAfter(T); },
        },
        search(e) { e = e !== J ? e : g.get.query(), g.verbose('Searching for query', e), g.has.minCharacters(e) ? g.filter(e) : g.hide(); },
        select: { firstUnfiltered() { g.verbose('Selecting first non-filtered element'), g.remove.selectedItem(), O.not(y.unselectable).not(y.addition + y.hidden).eq(0).addClass(h.selected); }, nextAvailable(e) { const t = (e = e.eq(0)).nextAll(y.item).not(y.unselectable).eq(0); const n = e.prevAll(y.item).not(y.unselectable).eq(0); t.length > 0 ? (g.verbose('Moving selection to', t), t.addClass(h.selected)) : (g.verbose('Moving selection to', n), n.addClass(h.selected)); } },
        setup: {
          api() { const e = { debug: p.debug, urlData: { value: g.get.value(), query: g.get.query() }, on: !1 }; g.verbose('First request, initializing API'), w.api(e); },
          layout() { w.is('select') && (g.setup.select(), g.setup.returnedObject()), g.has.menu() || g.create.menu(), g.is.search() && !g.has.search() && (g.verbose('Adding search input'), T = Y('<input />').addClass(h.search).prop('autocomplete', 'off').insertBefore(k)), g.is.multiple() && g.is.searchSelection() && !g.has.sizer() && g.create.sizer(), p.allowTab && g.set.tabbable(); },
          select() {
            const e = g.get.selectValues(); g.debug('Dropdown initialized on a select', e), w.is('select') && (R = w), R.parent(y.dropdown).length > 0 ? (g.debug('UI dropdown already exists. Creating dropdown menu only'), w = R.closest(y.dropdown), g.has.menu() || g.create.menu(), F = w.children(y.menu), g.setup.menu(e)) : (g.debug('Creating entire dropdown from select'), w = Y('<div />').attr('class', R.attr('class')).addClass(h.selection).addClass(h.dropdown)
              .html(m.dropdown(e))
              .insertBefore(R), R.hasClass(h.multiple) && !1 === R.prop('multiple') && (g.error(f.missingMultiple), R.prop('multiple', !0)), R.is('[multiple]') && g.set.multiple(), R.prop('disabled') && (g.debug('Disabling dropdown'), w.addClass(h.disabled)), R.removeAttr('class').detach().prependTo(w)), g.refresh();
          },
          menu(e) { F.html(m.menu(e, l)), O = F.find(y.item); },
          reference() { g.debug('Dropdown behavior was called on select, replacing with closest dropdown'), w = w.parent(y.dropdown), I = w.data(C), z = w.get(0), g.refresh(), g.setup.returnedObject(); },
          returnedObject() { const e = V.slice(0, n); const t = V.slice(n + 1); V = e.add(w).add(t); },
        },
        refresh() { g.refreshSelectors(), g.refreshData(); },
        refreshItems() { O = F.find(y.item); },
        refreshSelectors() { g.verbose('Refreshing selector cache'), k = w.find(y.text), T = w.find(y.search), R = w.find(y.input), P = w.find(y.icon), E = w.prev().find(y.text).length > 0 ? w.prev().find(y.text) : w.prev(), F = w.children(y.menu), O = F.find(y.item); },
        refreshData() { g.verbose('Refreshing cached metadata'), O.removeData(b.text).removeData(b.value); },
        clearData() { g.verbose('Clearing metadata'), O.removeData(b.text).removeData(b.value), w.removeData(b.defaultText).removeData(b.defaultValue).removeData(b.placeholderText); },
        toggle() { g.verbose('Toggling menu visibility'), g.is.active() ? g.hide() : g.show(); },
        show(e) { if (e = Y.isFunction(e) ? e : function () {}, !g.can.show() && g.is.remote() && (g.debug('No API results retrieved, searching before show'), g.queryRemote(g.get.query(), g.show)), g.can.show() && !g.is.active()) { if (g.debug('Showing dropdown'), !g.has.message() || g.has.maxSelections() || g.has.allResultsFiltered() || g.remove.message(), g.is.allFiltered()) return !0; !1 !== p.onShow.call(z) && g.animate.show(() => { g.can.click() && g.bind.intent(), g.has.menuSearch() && g.focusSearch(), g.set.visible(), e.call(z); }); } },
        hide(e) { e = Y.isFunction(e) ? e : function () {}, g.is.active() && !g.is.animatingOutward() && (g.debug('Hiding dropdown'), !1 !== p.onHide.call(z) && g.animate.hide(() => { g.remove.visible(), e.call(z); })); },
        hideOthers() { g.verbose('Finding other dropdowns to hide'), V.not(w).has(`${y.menu}.${h.visible}`).dropdown('hide'); },
        hideMenu() { g.verbose('Hiding menu  instantaneously'), g.remove.active(), g.remove.visible(), F.transition('hide'); },
        hideSubMenus() { const e = F.children(y.item).find(y.menu); g.verbose('Hiding sub menus', e), e.transition('hide'); },
        bind: {
          events() { U && g.bind.touchEvents(), g.bind.keyboardEvents(), g.bind.inputEvents(), g.bind.mouseEvents(); },
          touchEvents() { g.debug('Touch device detected binding additional touch events'), g.is.searchSelection() || g.is.single() && w.on(`touchstart${x}`, g.event.test.toggle), F.on(`touchstart${x}`, y.item, g.event.item.mouseenter); },
          keyboardEvents() { g.verbose('Binding keyboard events'), w.on(`keydown${x}`, g.event.keydown), g.has.search() && w.on(g.get.inputEvent() + x, y.search, g.event.input), g.is.multiple() && N.on(`keydown${o}`, g.event.document.keydown); },
          inputEvents() { g.verbose('Binding input change events'), w.on(`change${x}`, y.input, g.event.change); },
          mouseEvents() {
            g.verbose('Binding mouse events'), g.is.multiple() && w.on(`click${x}`, y.label, g.event.label.click).on(`click${x}`, y.remove, g.event.remove.click), g.is.searchSelection() ? (w.on(`mousedown${x}`, g.event.mousedown).on(`mouseup${x}`, g.event.mouseup).on(`mousedown${x}`, y.menu, g.event.menu.mousedown).on(`mouseup${x}`, y.menu, g.event.menu.mouseup)
              .on(`click${x}`, y.icon, g.event.icon.click)
              .on(`focus${x}`, y.search, g.event.search.focus)
              .on(`click${x}`, y.search, g.event.search.focus)
              .on(`blur${x}`, y.search, g.event.search.blur)
              .on(`click${x}`, y.text, g.event.text.focus), g.is.multiple() && w.on(`click${x}`, g.event.click)) : (p.on == 'click' ? w.on(`click${x}`, g.event.test.toggle) : p.on == 'hover' ? w.on(`mouseenter${x}`, g.delay.show).on(`mouseleave${x}`, g.delay.hide) : w.on(p.on + x, g.toggle), w.on(`click${x}`, y.icon, g.event.icon.click).on(`mousedown${x}`, g.event.mousedown).on(`mouseup${x}`, g.event.mouseup).on(`focus${x}`, g.event.focus), g.has.menuSearch() ? w.on(`blur${x}`, y.search, g.event.search.blur) : w.on(`blur${x}`, g.event.blur)), F.on(`mouseenter${x}`, y.item, g.event.item.mouseenter).on(`mouseleave${x}`, y.item, g.event.item.mouseleave).on(`click${x}`, y.item, g.event.item.click);
          },
          intent() { g.verbose('Binding hide intent event to document'), U && N.on(`touchstart${o}`, g.event.test.touch).on(`touchmove${o}`, g.event.test.touch), N.on(`click${o}`, g.event.test.hide); },
        },
        unbind: { intent() { g.verbose('Removing hide intent event from document'), U && N.off(`touchstart${o}`).off(`touchmove${o}`), N.off(`click${o}`); } },
        filter(e) { const t = e !== J ? e : g.get.query(); const n = function () { g.is.multiple() && g.filterActive(), (e || !e && g.get.activeItem().length == 0) && g.select.firstUnfiltered(), g.has.allResultsFiltered() ? p.onNoResults.call(z, t) ? p.allowAdditions ? p.hideAdditions && (g.verbose('User addition with no menu, setting empty style'), g.set.empty(), g.hideMenu()) : (g.verbose('All items filtered, showing message', t), g.add.message(c.noResults)) : (g.verbose('All items filtered, hiding dropdown', t), g.hideMenu()) : (g.remove.empty(), g.remove.message()), p.allowAdditions && g.add.userSuggestion(e), g.is.searchSelection() && g.can.show() && g.is.focusedOnSearch() && g.show(); }; p.useLabels && g.has.maxSelections() || (p.apiSettings ? g.can.useAPI() ? g.queryRemote(t, () => { p.filterRemoteData && g.filterItems(t), n(); }) : g.error(f.noAPI) : (g.filterItems(t), n())); },
        queryRemote(e, n) {
          let t = {
            errorDuration: !1, cache: 'local', throttle: p.throttle, urlData: { query: e }, onError() { g.add.message(c.serverError), n(); }, onFailure() { g.add.message(c.serverError), n(); }, onSuccess(e) { const t = e[l.remoteValues]; Y.isArray(t) && t.length > 0 ? (g.remove.message(), g.setup.menu({ values: e[l.remoteValues] })) : g.add.message(c.noResults), n(); },
          }; w.api('get request') || g.setup.api(), t = Y.extend(!0, {}, t, p.apiSettings), w.api('setting', t).api('query');
        },
        filterItems(e) { const i = e !== J ? e : g.get.query(); let o = null; const t = g.escape.string(i); const a = new RegExp(`^${t}`, 'igm'); g.has.query() && (o = [], g.verbose('Searching for matching values', i), O.each(function () { let e; let t; const n = Y(this); if (p.match == 'both' || p.match == 'text') { if ((e = String(g.get.choiceText(n, !1))).search(a) !== -1) return o.push(this), !0; if (p.fullTextSearch === 'exact' && g.exactSearch(i, e)) return o.push(this), !0; if (!0 === p.fullTextSearch && g.fuzzySearch(i, e)) return o.push(this), !0; } if (p.match == 'both' || p.match == 'value') { if ((t = String(g.get.choiceValue(n, e))).search(a) !== -1) return o.push(this), !0; if (p.fullTextSearch === 'exact' && g.exactSearch(i, t)) return o.push(this), !0; if (!0 === p.fullTextSearch && g.fuzzySearch(i, t)) return o.push(this), !0; } })), g.debug('Showing only matched items', i), g.remove.filteredItem(), o && O.not(o).addClass(h.filtered); },
        fuzzySearch(e, t) { const n = t.length; const i = e.length; if (e = e.toLowerCase(), t = t.toLowerCase(), n < i) return !1; if (i === n) return e === t; e:for (let o = 0, a = 0; o < i; o++) { for (let r = e.charCodeAt(o); a < n;) if (t.charCodeAt(a++) === r) continue e; return !1; } return !0; },
        exactSearch(e, t) { return e = e.toLowerCase(), (t = t.toLowerCase()).indexOf(e) > -1; },
        filterActive() { p.useLabels && O.filter(`.${h.active}`).addClass(h.filtered); },
        focusSearch(e) { g.has.search() && !g.is.focusedOnSearch() && (e ? (w.off(`focus${x}`, y.search), T.focus(), w.on(`focus${x}`, y.search, g.event.search.focus)) : T.focus()); },
        forceSelection() { const e = O.not(h.filtered).filter(`.${h.selected}`).eq(0); const t = O.not(h.filtered).filter(`.${h.active}`).eq(0); const n = e.length > 0 ? e : t; if (n.length > 0 && !g.is.multiple()) return g.debug('Forcing partial selection to selected item', n), void g.event.item.click.call(n, {}, !0); p.allowAdditions && g.set.selected(g.get.query()), g.remove.searchTerm(); },
        change: { values(e) { p.allowAdditions || g.clear(), g.debug('Creating dropdown with specified values', e), g.setup.menu({ values: e }), Y.each(e, (e, t) => { if (t.selected == 1) return g.debug('Setting initial selection to', t.value), g.set.selected(t.value), !0; }); } },
        event: {
          change() { j || (g.debug('Input changed, updating selection'), g.set.selected()); }, focus() { p.showOnFocus && !D && g.is.hidden() && !t && g.show(); }, blur(e) { t = K.activeElement === this, D || t || (g.remove.activeLabel(), g.hide()); }, mousedown() { g.is.searchSelection() ? i = !0 : D = !0; }, mouseup() { g.is.searchSelection() ? i = !1 : D = !1; }, click(e) { Y(e.target).is(w) && (g.is.focusedOnSearch() ? g.show() : g.focusSearch()); }, search: { focus() { D = !0, g.is.multiple() && g.remove.activeLabel(), p.showOnFocus && g.search(); }, blur(e) { t = K.activeElement === this, g.is.searchSelection() && !i && (q || t || (p.forceSelection && g.forceSelection(), g.hide())), i = !1; } }, icon: { click(e) { P.hasClass(h.clear) ? g.clear() : g.can.click() && g.toggle(); } }, text: { focus(e) { D = !0, g.focusSearch(); } }, input(e) { (g.is.multiple() || g.is.searchSelection()) && g.set.filtered(), clearTimeout(g.timer), g.timer = setTimeout(g.search, p.delay.search); }, label: { click(e) { const t = Y(this); const n = w.find(y.label); const i = n.filter(`.${h.active}`); const o = t.nextAll(`.${h.active}`); const a = t.prevAll(`.${h.active}`); const r = o.length > 0 ? t.nextUntil(o).add(i).add(t) : t.prevUntil(a).add(i).add(t); e.shiftKey ? (i.removeClass(h.active), r.addClass(h.active)) : e.ctrlKey ? t.toggleClass(h.active) : (i.removeClass(h.active), t.addClass(h.active)), p.onLabelSelect.apply(this, n.filter(`.${h.active}`)); } }, remove: { click() { const e = Y(this).parent(); e.hasClass(h.active) ? g.remove.activeLabels() : g.remove.activeLabels(e); } }, test: { toggle(e) { const t = g.is.multiple() ? g.show : g.toggle; g.is.bubbledLabelClick(e) || g.is.bubbledIconClick(e) || g.determine.eventOnElement(e, t) && e.preventDefault(); }, touch(e) { g.determine.eventOnElement(e, () => { e.type == 'touchstart' ? g.timer = setTimeout(() => { g.hide(); }, p.delay.touch) : e.type == 'touchmove' && clearTimeout(g.timer); }), e.stopPropagation(); }, hide(e) { g.determine.eventInModule(e, g.hide); } }, select: { mutation(e) { g.debug('<select> modified, recreating menu'); let n = !1; Y.each(e, (e, t) => { if (Y(t.target).is('select') || Y(t.addedNodes).is('select')) return n = !0; }), n && (g.disconnect.selectObserver(), g.refresh(), g.setup.select(), g.set.selected(), g.observe.select()); } }, menu: { mutation(e) { const t = e[0]; const n = t.addedNodes ? Y(t.addedNodes[0]) : Y(!1); const i = t.removedNodes ? Y(t.removedNodes[0]) : Y(!1); const o = n.add(i); const a = o.is(y.addition) || o.closest(y.addition).length > 0; const r = o.is(y.message) || o.closest(y.message).length > 0; a || r ? (g.debug('Updating item selector cache'), g.refreshItems()) : (g.debug('Menu modified, updating selector cache'), g.refresh()); }, mousedown() { q = !0; }, mouseup() { q = !1; } }, item: { mouseenter(e) { const t = Y(e.target); const n = Y(this); const i = n.children(y.menu); const o = n.siblings(y.item).children(y.menu); const a = i.length > 0; !(i.find(t).length > 0) && a && (clearTimeout(g.itemTimer), g.itemTimer = setTimeout(() => { g.verbose('Showing sub-menu', i), Y.each(o, function () { g.animate.hide(!1, Y(this)); }), g.animate.show(!1, i); }, p.delay.show), e.preventDefault()); }, mouseleave(e) { const t = Y(this).children(y.menu); t.length > 0 && (clearTimeout(g.itemTimer), g.itemTimer = setTimeout(() => { g.verbose('Hiding sub-menu', t), g.animate.hide(!1, t); }, p.delay.hide)); }, click(e, t) { const n = Y(this); const i = Y(e ? e.target : ''); const o = n.find(y.menu); const a = g.get.choiceText(n); const r = g.get.choiceValue(n, a); const s = o.length > 0; const l = o.find(i).length > 0; g.has.menuSearch() && Y(K.activeElement).blur(), l || s && !p.allowCategorySelection || (g.is.searchSelection() && (p.allowAdditions && g.remove.userAddition(), g.remove.searchTerm(), g.is.focusedOnSearch() || t == 1 || g.focusSearch(!0)), p.useLabels || (g.remove.filteredItem(), g.set.scrollPosition(n)), g.determine.selectAction.call(this, a, r)); } }, document: { keydown(e) { const t = e.which; if (g.is.inObject(t, v)) { const n = w.find(y.label); let i = n.filter(`.${h.active}`); const o = (i.data(b.value), n.index(i)); const a = n.length; const r = i.length > 0; const s = i.length > 1; const l = o === 0; const c = o + 1 == a; const u = g.is.searchSelection(); const d = g.is.focusedOnSearch(); const f = g.is.focused(); const m = d && g.get.caretPosition() === 0; if (u && !r && !d) return; t == v.leftArrow ? !f && !m || r ? r && (e.shiftKey ? g.verbose('Adding previous label to selection') : (g.verbose('Selecting previous label'), n.removeClass(h.active)), l && !s ? i.addClass(h.active) : i.prev(y.siblingLabel).addClass(h.active).end(), e.preventDefault()) : (g.verbose('Selecting previous label'), n.last().addClass(h.active)) : t == v.rightArrow ? (f && !r && n.first().addClass(h.active), r && (e.shiftKey ? g.verbose('Adding next label to selection') : (g.verbose('Selecting next label'), n.removeClass(h.active)), c ? u ? d ? n.removeClass(h.active) : g.focusSearch() : s ? i.next(y.siblingLabel).addClass(h.active) : i.addClass(h.active) : i.next(y.siblingLabel).addClass(h.active), e.preventDefault())) : t == v.deleteKey || t == v.backspace ? r ? (g.verbose('Removing active labels'), c && u && !d && g.focusSearch(), i.last().next(y.siblingLabel).addClass(h.active), g.remove.activeLabels(i), e.preventDefault()) : m && !r && t == v.backspace && (g.verbose('Removing last label on input backspace'), i = n.last().addClass(h.active), g.remove.activeLabels(i)) : i.removeClass(h.active); } } }, keydown(e) { let t = e.which; if (g.is.inObject(t, v)) { let n; const i = O.not(y.unselectable).filter(`.${h.selected}`).eq(0); const o = F.children(`.${h.active}`).eq(0); const a = i.length > 0 ? i : o; const r = a.length > 0 ? a.siblings(`:not(.${h.filtered})`).addBack() : F.children(`:not(.${h.filtered})`); const s = a.children(y.menu); const l = a.closest(y.menu); const c = l.hasClass(h.visible) || l.hasClass(h.animating) || l.parent(y.menu).length > 0; const u = s.length > 0; const d = a.length > 0; const f = a.not(y.unselectable).length > 0; const m = t == v.delimiter && p.allowAdditions && g.is.multiple(); if (p.allowAdditions && p.hideAdditions && (t == v.enter || m) && f && (g.verbose('Selecting item from keyboard shortcut', a), g.event.item.click.call(a, e), g.is.searchSelection() && g.remove.searchTerm()), g.is.visible()) { if ((t == v.enter || m) && (t == v.enter && d && u && !p.allowCategorySelection ? (g.verbose('Pressed enter on unselectable category, opening sub menu'), t = v.rightArrow) : f && (g.verbose('Selecting item from keyboard shortcut', a), g.event.item.click.call(a, e), g.is.searchSelection() && g.remove.searchTerm()), e.preventDefault()), d && (t == v.leftArrow && l[0] !== F[0] && (g.verbose('Left key pressed, closing sub-menu'), g.animate.hide(!1, l), a.removeClass(h.selected), l.closest(y.item).addClass(h.selected), e.preventDefault()), t == v.rightArrow && u && (g.verbose('Right key pressed, opening sub-menu'), g.animate.show(!1, s), a.removeClass(h.selected), s.find(y.item).eq(0).addClass(h.selected), e.preventDefault())), t == v.upArrow) { if (n = d && c ? a.prevAll(`${y.item}:not(${y.unselectable})`).eq(0) : O.eq(0), r.index(n) < 0) return g.verbose('Up key pressed but reached top of current menu'), void e.preventDefault(); g.verbose('Up key pressed, changing active item'), a.removeClass(h.selected), n.addClass(h.selected), g.set.scrollPosition(n), p.selectOnKeydown && g.is.single() && g.set.selectedItem(n), e.preventDefault(); } if (t == v.downArrow) { if ((n = d && c ? n = a.nextAll(`${y.item}:not(${y.unselectable})`).eq(0) : O.eq(0)).length === 0) return g.verbose('Down key pressed but reached bottom of current menu'), void e.preventDefault(); g.verbose('Down key pressed, changing active item'), O.removeClass(h.selected), n.addClass(h.selected), g.set.scrollPosition(n), p.selectOnKeydown && g.is.single() && g.set.selectedItem(n), e.preventDefault(); }t == v.pageUp && (g.scrollPage('up'), e.preventDefault()), t == v.pageDown && (g.scrollPage('down'), e.preventDefault()), t == v.escape && (g.verbose('Escape key pressed, closing dropdown'), g.hide()); } else m && e.preventDefault(), t != v.downArrow || g.is.visible() || (g.verbose('Down key pressed, showing dropdown'), g.show(), e.preventDefault()); } else g.has.search() || g.set.selectedLetter(String.fromCharCode(t)); },
        },
        trigger: { change() { const e = K.createEvent('HTMLEvents'); const t = R[0]; t && (g.verbose('Triggering native change event'), e.initEvent('change', !0, !1), t.dispatchEvent(e)); } },
        determine: { selectAction(e, t) { g.verbose('Determining action', p.action), Y.isFunction(g.action[p.action]) ? (g.verbose('Triggering preset action', p.action, e, t), g.action[p.action].call(z, e, t, this)) : Y.isFunction(p.action) ? (g.verbose('Triggering user action', p.action, e, t), p.action.call(z, e, t, this)) : g.error(f.action, p.action); }, eventInModule(e, t) { const n = Y(e.target); const i = n.closest(K.documentElement).length > 0; const o = n.closest(w).length > 0; return t = Y.isFunction(t) ? t : function () {}, i && !o ? (g.verbose('Triggering event', t), t(), !0) : (g.verbose('Event occurred in dropdown, canceling callback'), !1); }, eventOnElement(e, t) { const n = Y(e.target); const i = n.closest(y.siblingLabel); const o = K.body.contains(e.target); const a = w.find(i).length === 0; const r = n.closest(F).length === 0; return t = Y.isFunction(t) ? t : function () {}, o && a && r ? (g.verbose('Triggering event', t), t(), !0) : (g.verbose('Event occurred in dropdown menu, canceling callback'), !1); } },
        action: {
          nothing() {}, activate(e, t, n) { if (t = t !== J ? t : e, g.can.activate(Y(n))) { if (g.set.selected(t, Y(n)), g.is.multiple() && !g.is.allFiltered()) return; g.hideAndClear(); } }, select(e, t, n) { if (t = t !== J ? t : e, g.can.activate(Y(n))) { if (g.set.value(t, e, Y(n)), g.is.multiple() && !g.is.allFiltered()) return; g.hideAndClear(); } }, combo(e, t, n) { t = t !== J ? t : e, g.set.selected(t, Y(n)), g.hideAndClear(); }, hide(e, t, n) { g.set.value(t, e, Y(n)), g.hideAndClear(); },
        },
        get: {
          id() { return a; }, defaultText() { return w.data(b.defaultText); }, defaultValue() { return w.data(b.defaultValue); }, placeholderText() { return p.placeholder != 'auto' && typeof p.placeholder === 'string' ? p.placeholder : w.data(b.placeholderText) || ''; }, text() { return k.text(); }, query() { return Y.trim(T.val()); }, searchWidth(e) { return e = e !== J ? e : T.val(), A.text(e), Math.ceil(A.width() + 1); }, selectionCount() { const e = g.get.values(); return g.is.multiple() ? Y.isArray(e) ? e.length : 0 : g.get.value() !== '' ? 1 : 0; }, transition(e) { return p.transition == 'auto' ? g.is.upward(e) ? 'slide up' : 'slide down' : p.transition; }, userValues() { let e = g.get.values(); return !!e && (e = Y.isArray(e) ? e : [e], Y.grep(e, (e) => !1 === g.get.item(e))); }, uniqueArray(n) { return Y.grep(n, (e, t) => Y.inArray(e, n) === t); }, caretPosition() { let e; let t; const n = T.get(0); return 'selectionStart' in n ? n.selectionStart : K.selection ? (n.focus(), t = (e = K.selection.createRange()).text.length, e.moveStart('character', -n.value.length), e.text.length - t) : void 0; }, value() { const e = R.length > 0 ? R.val() : w.data(b.value); const t = Y.isArray(e) && e.length === 1 && e[0] === ''; return e === J || t ? '' : e; }, values() { const e = g.get.value(); return e === '' ? '' : !g.has.selectInput() && g.is.multiple() ? typeof e === 'string' ? e.split(p.delimiter) : '' : e; }, remoteValues() { let e = g.get.values(); let i = !1; return e && (typeof e === 'string' && (e = [e]), Y.each(e, (e, t) => { const n = g.read.remoteData(t); g.verbose('Restoring value from session data', n, t), n && (i || (i = {}), i[t] = n); })), i; }, choiceText(e, t) { if (t = t !== J ? t : p.preserveHTML, e) return e.find(y.menu).length > 0 && (g.verbose('Retrieving text of element with sub-menu'), (e = e.clone()).find(y.menu).remove(), e.find(y.menuIcon).remove()), e.data(b.text) !== J ? e.data(b.text) : t ? Y.trim(e.html()) : Y.trim(e.text()); }, choiceValue(e, t) { return t = t || g.get.choiceText(e), !!e && (e.data(b.value) !== J ? String(e.data(b.value)) : typeof t === 'string' ? Y.trim(t.toLowerCase()) : String(t)); }, inputEvent() { const e = T[0]; return !!e && (e.oninput !== J ? 'input' : e.onpropertychange !== J ? 'propertychange' : 'keyup'); }, selectValues() { const o = { values: [] }; return w.find('option').each(function () { const e = Y(this); const t = e.html(); const n = e.attr('disabled'); const i = e.attr('value') !== J ? e.attr('value') : t; p.placeholder === 'auto' && i === '' ? o.placeholder = t : o.values.push({ name: t, value: i, disabled: n }); }), p.placeholder && p.placeholder !== 'auto' && (g.debug('Setting placeholder value to', p.placeholder), o.placeholder = p.placeholder), p.sortSelect ? (o.values.sort((e, t) => (e.name > t.name ? 1 : -1)), g.debug('Retrieved and sorted values from select', o)) : g.debug('Retrieved values from select', o), o; }, activeItem() { return O.filter(`.${h.active}`); }, selectedItem() { const e = O.not(y.unselectable).filter(`.${h.selected}`); return e.length > 0 ? e : O.eq(0); }, itemWithAdditions(e) { let t = g.get.item(e); const n = g.create.userChoice(e); return n && n.length > 0 && (t = t.length > 0 ? t.add(n) : n), t; }, item(i, o) { let e; let a; let r = !1; return i = i !== J ? i : g.get.values() !== J ? g.get.values() : g.get.text(), e = a ? i.length > 0 : i !== J && i !== null, a = g.is.multiple() && Y.isArray(i), o = i === '' || i === 0 || (o || !1), e && O.each(function () { const e = Y(this); const t = g.get.choiceText(e); const n = g.get.choiceValue(e, t); if (n !== null && n !== J) if (a)Y.inArray(String(n), i) === -1 && Y.inArray(t, i) === -1 || (r = r ? r.add(e) : e); else if (o) { if (g.verbose('Ambiguous dropdown value using strict type check', e, i), n === i || t === i) return r = e, !0; } else if (String(n) == String(i) || t == i) return g.verbose('Found select item by value', n, i), r = e, !0; }), r; },
        },
        check: { maxSelections(e) { return !p.maxSelections || ((e = e !== J ? e : g.get.selectionCount()) >= p.maxSelections ? (g.debug('Maximum selection count reached'), p.useLabels && (O.addClass(h.filtered), g.add.message(c.maxSelections)), !0) : (g.verbose('No longer at maximum selection count'), g.remove.message(), g.remove.filteredItem(), g.is.searchSelection() && g.filterItems(), !1)); } },
        restore: {
          defaults() { g.clear(), g.restore.defaultText(), g.restore.defaultValue(); }, defaultText() { const e = g.get.defaultText(); e === g.get.placeholderText ? (g.debug('Restoring default placeholder text', e), g.set.placeholderText(e)) : (g.debug('Restoring default text', e), g.set.text(e)); }, placeholderText() { g.set.placeholderText(); }, defaultValue() { const e = g.get.defaultValue(); e !== J && (g.debug('Restoring default value', e), e !== '' ? (g.set.value(e), g.set.selected()) : (g.remove.activeItem(), g.remove.selectedItem())); }, labels() { p.allowAdditions && (p.useLabels || (g.error(f.labels), p.useLabels = !0), g.debug('Restoring selected values'), g.create.userLabels()), g.check.maxSelections(); }, selected() { g.restore.values(), g.is.multiple() ? (g.debug('Restoring previously selected values and labels'), g.restore.labels()) : g.debug('Restoring previously selected values'); }, values() { g.set.initialLoad(), p.apiSettings && p.saveRemoteData && g.get.remoteValues() ? g.restore.remoteValues() : g.set.selected(), g.remove.initialLoad(); }, remoteValues() { const e = g.get.remoteValues(); g.debug('Recreating selected from session data', e), e && (g.is.single() ? Y.each(e, (e, t) => { g.set.text(t); }) : Y.each(e, (e, t) => { g.add.label(e, t); })); },
        },
        read: { remoteData(e) { let t; if (Z.Storage !== J) return (t = sessionStorage.getItem(e)) !== J && t; g.error(f.noStorage); } },
        save: {
          defaults() { g.save.defaultText(), g.save.placeholderText(), g.save.defaultValue(); }, defaultValue() { const e = g.get.value(); g.verbose('Saving default value as', e), w.data(b.defaultValue, e); }, defaultText() { const e = g.get.text(); g.verbose('Saving default text as', e), w.data(b.defaultText, e); }, placeholderText() { let e; !1 !== p.placeholder && k.hasClass(h.placeholder) && (e = g.get.text(), g.verbose('Saving placeholder text as', e), w.data(b.placeholderText, e)); }, remoteData(e, t) { Z.Storage !== J ? (g.verbose('Saving remote data to session storage', t, e), sessionStorage.setItem(t, e)) : g.error(f.noStorage); },
        },
        clear() { g.is.multiple() && p.useLabels ? g.remove.labels() : (g.remove.activeItem(), g.remove.selectedItem()), g.set.placeholderText(), g.clearValue(); },
        clearValue() { g.set.value(''); },
        scrollPage(e, t) { let n; let i; const o = t || g.get.selectedItem(); const a = o.closest(y.menu); const r = a.outerHeight(); const s = a.scrollTop(); const l = O.eq(0).outerHeight(); const c = Math.floor(r / l); const u = (a.prop('scrollHeight'), e == 'up' ? s - l * c : s + l * c); const d = O.not(y.unselectable); i = e == 'up' ? d.index(o) - c : d.index(o) + c, (n = (e == 'up' ? i >= 0 : i < d.length) ? d.eq(i) : e == 'up' ? d.first() : d.last()).length > 0 && (g.debug('Scrolling page', e, n), o.removeClass(h.selected), n.addClass(h.selected), p.selectOnKeydown && g.is.single() && g.set.selectedItem(n), a.scrollTop(u)); },
        set: {
          filtered() { const e = g.is.multiple(); const t = g.is.searchSelection(); const n = e && t; const i = t ? g.get.query() : ''; const o = typeof i === 'string' && i.length > 0; const a = g.get.searchWidth(); const r = i !== ''; e && o && (g.verbose('Adjusting input width', a, p.glyphWidth), T.css('width', a)), o || n && r ? (g.verbose('Hiding placeholder text'), k.addClass(h.filtered)) : (!e || n && !r) && (g.verbose('Showing placeholder text'), k.removeClass(h.filtered)); }, empty() { w.addClass(h.empty); }, loading() { w.addClass(h.loading); }, placeholderText(e) { e = e || g.get.placeholderText(), g.debug('Setting placeholder text', e), g.set.text(e), k.addClass(h.placeholder); }, tabbable() { g.is.searchSelection() ? (g.debug('Added tabindex to searchable dropdown'), T.val('').attr('tabindex', 0), F.attr('tabindex', -1)) : (g.debug('Added tabindex to dropdown'), w.attr('tabindex') === J && (w.attr('tabindex', 0), F.attr('tabindex', -1))); }, initialLoad() { g.verbose('Setting initial load'), e = !0; }, activeItem(e) { p.allowAdditions && e.filter(y.addition).length > 0 ? e.addClass(h.filtered) : e.addClass(h.active); }, partialSearch(e) { const t = g.get.query().length; T.val(e.substr(0, t)); }, scrollPosition(e, t) { let n; let i; let o; let a; let r; let s; n = (e = e || g.get.selectedItem()).closest(y.menu), i = e && e.length > 0, t = t !== J && t, e && n.length > 0 && i && (e.position().top, n.addClass(h.loading), o = (a = n.scrollTop()) - n.offset().top + e.offset().top, t || (s = a + n.height() < o + 5, r = o - 5 < a), g.debug('Scrolling to active item', o), (t || r || s) && n.scrollTop(o), n.removeClass(h.loading)); }, text(e) { p.action !== 'select' && (p.action == 'combo' ? (g.debug('Changing combo button text', e, E), p.preserveHTML ? E.html(e) : E.text(e)) : (e !== g.get.placeholderText() && k.removeClass(h.placeholder), g.debug('Changing text', e, k), k.removeClass(h.filtered), p.preserveHTML ? k.html(e) : k.text(e))); }, selectedItem(e) { const t = g.get.choiceValue(e); const n = g.get.choiceText(e, !1); const i = g.get.choiceText(e, !0); g.debug('Setting user selection to item', e), g.remove.activeItem(), g.set.partialSearch(n), g.set.activeItem(e), g.set.selected(t, e), g.set.text(i); }, selectedLetter(e) { let t; const n = O.filter(`.${h.selected}`); const i = n.length > 0 && g.has.firstLetter(n, e); let o = !1; i && (t = n.nextAll(O).eq(0), g.has.firstLetter(t, e) && (o = t)), o || O.each(function () { if (g.has.firstLetter(Y(this), e)) return o = Y(this), !1; }), o && (g.verbose('Scrolling to next value with letter', e), g.set.scrollPosition(o), n.removeClass(h.selected), o.addClass(h.selected), p.selectOnKeydown && g.is.single() && g.set.selectedItem(o)); }, direction(e) { p.direction == 'auto' ? (g.remove.upward(), g.can.openDownward(e) ? g.remove.upward(e) : g.set.upward(e), g.is.leftward(e) || g.can.openRightward(e) || g.set.leftward(e)) : p.direction == 'upward' && g.set.upward(e); }, upward(e) { (e || w).addClass(h.upward); }, leftward(e) { (e || F).addClass(h.leftward); }, value(e, t, n) { const i = g.escape.value(e); const o = R.length > 0; const a = g.get.values(); const r = e !== J ? String(e) : e; if (o) { if (!p.allowReselection && r == a && (g.verbose('Skipping value update already same value', e, a), !g.is.initialLoad())) return; g.is.single() && g.has.selectInput() && g.can.extendSelect() && (g.debug('Adding user option', e), g.add.optionValue(e)), g.debug('Updating input value', i, a), j = !0, R.val(i), !1 === p.fireOnInit && g.is.initialLoad() ? g.debug('Input native change event ignored on initial load') : g.trigger.change(), j = !1; } else g.verbose('Storing value in metadata', i, R), i !== a && w.data(b.value, r); g.is.single() && p.clearable && (i ? g.set.clearable() : g.remove.clearable()), !1 === p.fireOnInit && g.is.initialLoad() ? g.verbose('No callback on initial load', p.onChange) : p.onChange.call(z, e, t, n); }, active() { w.addClass(h.active); }, multiple() { w.addClass(h.multiple); }, visible() { w.addClass(h.visible); }, exactly(e, t) { g.debug('Setting selected to exact values'), g.clear(), g.set.selected(e, t); }, selected(e, s) { const l = g.is.multiple(); (s = p.allowAdditions ? s || g.get.itemWithAdditions(e) : s || g.get.item(e)) && (g.debug('Setting selected menu item to', s), g.is.multiple() && g.remove.searchWidth(), g.is.single() ? (g.remove.activeItem(), g.remove.selectedItem()) : p.useLabels && g.remove.selectedItem(), s.each(function () { const e = Y(this); const t = g.get.choiceText(e); const n = g.get.choiceValue(e, t); const i = e.hasClass(h.filtered); const o = e.hasClass(h.active); const a = e.hasClass(h.addition); const r = l && s.length == 1; l ? !o || a ? (p.apiSettings && p.saveRemoteData && g.save.remoteData(t, n), p.useLabels ? (g.add.label(n, t, r), g.add.value(n, t, e), g.set.activeItem(e), g.filterActive(), g.select.nextAvailable(s)) : (g.add.value(n, t, e), g.set.text(g.add.variables(c.count)), g.set.activeItem(e))) : i || (g.debug('Selected active value, removing label'), g.remove.selected(n)) : (p.apiSettings && p.saveRemoteData && g.save.remoteData(t, n), g.set.text(t), g.set.value(n, t, e), e.addClass(h.active).addClass(h.selected)); })); }, clearable() { P.addClass(h.clear); },
        },
        add: {
          label(e, t, n) { let i; const o = g.is.searchSelection() ? T : k; let a = g.escape.value(e); p.ignoreCase && (a = a.toLowerCase()), i = Y('<a />').addClass(h.label).attr(`data-${b.value}`, a).html(m.label(a, t)), i = p.onLabelCreate.call(i, a, t), g.has.label(e) ? g.debug('User selection already exists, skipping', a) : (p.label.variation && i.addClass(p.label.variation), !0 === n ? (g.debug('Animating in label', i), i.addClass(h.hidden).insertBefore(o).transition(p.label.transition, p.label.duration)) : (g.debug('Adding selection label', i), i.insertBefore(o))); },
          message(e) { let t = F.children(y.message); const n = p.templates.message(g.add.variables(e)); t.length > 0 ? t.html(n) : t = Y('<div/>').html(n).addClass(h.message).appendTo(F); },
          optionValue(e) {
            const t = g.escape.value(e); R.find(`option[value="${g.escape.string(t)}"]`).length > 0 || (g.disconnect.selectObserver(), g.is.single() && (g.verbose('Removing previous user addition'), R.find(`option.${h.addition}`).remove()), Y('<option/>').prop('value', t).addClass(h.addition).html(e)
              .appendTo(R), g.verbose('Adding user addition as an <option>', e), g.observe.select());
          },
          userSuggestion(e) {
            let t; let n = F.children(y.addition); const i = g.get.item(e); const o = i && i.not(y.addition).length; const a = n.length > 0; p.useLabels && g.has.maxSelections() || (e === '' || o ? n.remove() : (a ? (n.data(b.value, e).data(b.text, e).attr(`data-${b.value}`, e).attr(`data-${b.text}`, e)
              .removeClass(h.filtered), p.hideAdditions || (t = p.templates.addition(g.add.variables(c.addResult, e)), n.html(t)), g.verbose('Replacing user suggestion with new value', n)) : ((n = g.create.userChoice(e)).prependTo(F), g.verbose('Adding item choice to menu corresponding with user choice addition', n)), p.hideAdditions && !g.is.allFiltered() || n.addClass(h.selected).siblings().removeClass(h.selected), g.refreshItems()));
          },
          variables(e, t) { let n; let i; const o = e.search('{count}') !== -1; const a = e.search('{maxCount}') !== -1; const r = e.search('{term}') !== -1; return g.verbose('Adding templated variables to message', e), o && (n = g.get.selectionCount(), e = e.replace('{count}', n)), a && (n = g.get.selectionCount(), e = e.replace('{maxCount}', p.maxSelections)), r && (i = t || g.get.query(), e = e.replace('{term}', i)), e; },
          value(e, t, n) { let i; const o = g.get.values(); g.has.value(e) ? g.debug('Value already selected') : e !== '' ? (i = Y.isArray(o) ? (i = o.concat([e]), g.get.uniqueArray(i)) : [e], g.has.selectInput() ? g.can.extendSelect() && (g.debug('Adding value to select', e, i, R), g.add.optionValue(e)) : (i = i.join(p.delimiter), g.debug('Setting hidden input to delimited value', i, R)), !1 === p.fireOnInit && g.is.initialLoad() ? g.verbose('Skipping onadd callback on initial load', p.onAdd) : p.onAdd.call(z, e, t, n), g.set.value(i, e, t, n), g.check.maxSelections()) : g.debug('Cannot select blank values from multiselect'); },
        },
        remove: {
          active() { w.removeClass(h.active); }, activeLabel() { w.find(y.label).removeClass(h.active); }, empty() { w.removeClass(h.empty); }, loading() { w.removeClass(h.loading); }, initialLoad() { e = !1; }, upward(e) { (e || w).removeClass(h.upward); }, leftward(e) { (e || F).removeClass(h.leftward); }, visible() { w.removeClass(h.visible); }, activeItem() { O.removeClass(h.active); }, filteredItem() { p.useLabels && g.has.maxSelections() || (p.useLabels && g.is.multiple() ? O.not(`.${h.active}`).removeClass(h.filtered) : O.removeClass(h.filtered), g.remove.empty()); }, optionValue(e) { const t = g.escape.value(e); const n = R.find(`option[value="${g.escape.string(t)}"]`); n.length > 0 && n.hasClass(h.addition) && (r && (r.disconnect(), g.verbose('Temporarily disconnecting mutation observer')), n.remove(), g.verbose('Removing user addition as an <option>', t), r && r.observe(R[0], { childList: !0, subtree: !0 })); }, message() { F.children(y.message).remove(); }, searchWidth() { T.css('width', ''); }, searchTerm() { g.verbose('Cleared search term'), T.val(''), g.set.filtered(); }, userAddition() { O.filter(y.addition).remove(); }, selected(e, t) { if (!(t = p.allowAdditions ? t || g.get.itemWithAdditions(e) : t || g.get.item(e))) return !1; t.each(function () { const e = Y(this); const t = g.get.choiceText(e); const n = g.get.choiceValue(e, t); g.is.multiple() ? p.useLabels ? (g.remove.value(n, t, e), g.remove.label(n)) : (g.remove.value(n, t, e), g.get.selectionCount() === 0 ? g.set.placeholderText() : g.set.text(g.add.variables(c.count))) : g.remove.value(n, t, e), e.removeClass(h.filtered).removeClass(h.active), p.useLabels && e.removeClass(h.selected); }); }, selectedItem() { O.removeClass(h.selected); }, value(e, t, n) { let i; const o = g.get.values(); g.has.selectInput() ? (g.verbose('Input is <select> removing selected option', e), i = g.remove.arrayValue(e, o), g.remove.optionValue(e)) : (g.verbose('Removing from delimited values', e), i = (i = g.remove.arrayValue(e, o)).join(p.delimiter)), !1 === p.fireOnInit && g.is.initialLoad() ? g.verbose('No callback on initial load', p.onRemove) : p.onRemove.call(z, e, t, n), g.set.value(i, t, n), g.check.maxSelections(); }, arrayValue(t, e) { return Y.isArray(e) || (e = [e]), e = Y.grep(e, (e) => t != e), g.verbose('Removed value from delimited string', t, e), e; }, label(e, t) { const n = w.find(y.label).filter(`[data-${b.value}="${g.escape.string(e)}"]`); g.verbose('Removing label', n), n.remove(); }, activeLabels(e) { e = e || w.find(y.label).filter(`.${h.active}`), g.verbose('Removing active label selections', e), g.remove.labels(e); }, labels(e) { e = e || w.find(y.label), g.verbose('Removing labels', e), e.each(function () { const e = Y(this); const t = e.data(b.value); const n = t !== J ? String(t) : t; const i = g.is.userValue(n); !1 !== p.onLabelRemove.call(e, t) ? (g.remove.message(), i ? (g.remove.value(n), g.remove.label(n)) : g.remove.selected(n)) : g.debug('Label remove callback cancelled removal'); }); }, tabbable() { g.is.searchSelection() ? (g.debug('Searchable dropdown initialized'), T.removeAttr('tabindex')) : (g.debug('Simple selection dropdown initialized'), w.removeAttr('tabindex')), F.removeAttr('tabindex'); }, clearable() { P.removeClass(h.clear); },
        },
        has: {
          menuSearch() { return g.has.search() && T.closest(F).length > 0; }, search() { return T.length > 0; }, sizer() { return A.length > 0; }, selectInput() { return R.is('select'); }, minCharacters(e) { return !p.minCharacters || (e = e !== J ? String(e) : String(g.get.query())).length >= p.minCharacters; }, firstLetter(e, t) { let n; return !(!e || e.length === 0 || typeof t !== 'string') && (n = g.get.choiceText(e, !1), (t = t.toLowerCase()) == String(n).charAt(0).toLowerCase()); }, input() { return R.length > 0; }, items() { return O.length > 0; }, menu() { return F.length > 0; }, message() { return F.children(y.message).length !== 0; }, label(e) { let t = g.escape.value(e); const n = w.find(y.label); return p.ignoreCase && (t = t.toLowerCase()), n.filter(`[data-${b.value}="${g.escape.string(t)}"]`).length > 0; }, maxSelections() { return p.maxSelections && g.get.selectionCount() >= p.maxSelections; }, allResultsFiltered() { const e = O.not(y.addition); return e.filter(y.unselectable).length === e.length; }, userSuggestion() { return F.children(y.addition).length > 0; }, query() { return g.get.query() !== ''; }, value(e) { return p.ignoreCase ? g.has.valueIgnoringCase(e) : g.has.valueMatchingCase(e); }, valueMatchingCase(e) { const t = g.get.values(); return !!(Y.isArray(t) ? t && Y.inArray(e, t) !== -1 : t == e); }, valueIgnoringCase(n) { let e = g.get.values(); let i = !1; return Y.isArray(e) || (e = [e]), Y.each(e, (e, t) => { if (String(n).toLowerCase() == String(t).toLowerCase()) return !(i = !0); }), i; },
        },
        is: {
          active() { return w.hasClass(h.active); }, animatingInward() { return F.transition('is inward'); }, animatingOutward() { return F.transition('is outward'); }, bubbledLabelClick(e) { return Y(e.target).is('select, input') && w.closest('label').length > 0; }, bubbledIconClick(e) { return Y(e.target).closest(P).length > 0; }, alreadySetup() { return w.is('select') && w.parent(y.dropdown).data(C) !== J && w.prev().length === 0; }, animating(e) { return e ? e.transition && e.transition('is animating') : F.transition && F.transition('is animating'); }, leftward(e) { return (e || F).hasClass(h.leftward); }, disabled() { return w.hasClass(h.disabled); }, focused() { return K.activeElement === w[0]; }, focusedOnSearch() { return K.activeElement === T[0]; }, allFiltered() { return (g.is.multiple() || g.has.search()) && !(p.hideAdditions == 0 && g.has.userSuggestion()) && !g.has.message() && g.has.allResultsFiltered(); }, hidden(e) { return !g.is.visible(e); }, initialLoad() { return e; }, inObject(n, e) { let i = !1; return Y.each(e, (e, t) => { if (t == n) return i = !0; }), i; }, multiple() { return w.hasClass(h.multiple); }, remote() { return p.apiSettings && g.can.useAPI(); }, single() { return !g.is.multiple(); }, selectMutation(e) { let n = !1; return Y.each(e, (e, t) => { if (t.target && Y(t.target).is('select')) return n = !0; }), n; }, search() { return w.hasClass(h.search); }, searchSelection() { return g.has.search() && T.parent(y.dropdown).length === 1; }, selection() { return w.hasClass(h.selection); }, userValue(e) { return Y.inArray(e, g.get.userValues()) !== -1; }, upward(e) { return (e || w).hasClass(h.upward); }, visible(e) { return e ? e.hasClass(h.visible) : F.hasClass(h.visible); }, verticallyScrollableContext() { const e = S.get(0) !== Z && S.css('overflow-y'); return e == 'auto' || e == 'scroll'; }, horizontallyScrollableContext() { const e = S.get(0) !== Z && S.css('overflow-X'); return e == 'auto' || e == 'scroll'; },
        },
        can: {
          activate(e) { return !!p.useLabels || (!g.has.maxSelections() || !(!g.has.maxSelections() || !e.hasClass(h.active))); }, openDownward(e) { let t; let n; const i = e || F; let o = !0; return i.addClass(h.loading), n = { context: { offset: S.get(0) === Z ? { top: 0, left: 0 } : S.offset(), scrollTop: S.scrollTop(), height: S.outerHeight() }, menu: { offset: i.offset(), height: i.outerHeight() } }, g.is.verticallyScrollableContext() && (n.menu.offset.top += n.context.scrollTop), o = (t = { above: n.context.scrollTop <= n.menu.offset.top - n.context.offset.top - n.menu.height, below: n.context.scrollTop + n.context.height >= n.menu.offset.top - n.context.offset.top + n.menu.height }).below ? (g.verbose('Dropdown can fit in context downward', t), !0) : t.below || t.above ? (g.verbose('Dropdown cannot fit below, opening upward', t), !1) : (g.verbose('Dropdown cannot fit in either direction, favoring downward', t), !0), i.removeClass(h.loading), o; }, openRightward(e) { let t; let n; const i = e || F; let o = !0; return i.addClass(h.loading), n = { context: { offset: S.get(0) === Z ? { top: 0, left: 0 } : S.offset(), scrollLeft: S.scrollLeft(), width: S.outerWidth() }, menu: { offset: i.offset(), width: i.outerWidth() } }, g.is.horizontallyScrollableContext() && (n.menu.offset.left += n.context.scrollLeft), (t = n.menu.offset.left - n.context.offset.left + n.menu.width >= n.context.scrollLeft + n.context.width) && (g.verbose('Dropdown cannot fit in context rightward', t), o = !1), i.removeClass(h.loading), o; }, click() { return U || p.on == 'click'; }, extendSelect() { return p.allowAdditions || p.apiSettings; }, show() { return !g.is.disabled() && (g.has.items() || g.has.message()); }, useAPI() { return Y.fn.api !== J; },
        },
        animate: {
          show(e, t) {
            let n; const i = t || F; const o = t ? function () {} : function () { g.hideSubMenus(), g.hideOthers(), g.set.active(); }; e = Y.isFunction(e) ? e : function () {}, g.verbose('Doing menu show animation', i), g.set.direction(t), n = g.get.transition(t), g.is.selection() && g.set.scrollPosition(g.get.selectedItem(), !0), (g.is.hidden(i) || g.is.animating(i)) && (n == 'none' ? (o(), i.transition('show'), e.call(z)) : Y.fn.transition !== J && w.transition('is supported') ? i.transition({
              animation: `${n} in`, debug: p.debug, verbose: p.verbose, duration: p.duration, queue: !0, onStart: o, onComplete() { e.call(z); },
            }) : g.error(f.noTransition, n));
          },
          hide(e, t) {
            const n = t || F; const i = (t ? p.duration : p.duration, t ? function () {} : function () { g.can.click() && g.unbind.intent(), g.remove.active(); }); const o = g.get.transition(t); e = Y.isFunction(e) ? e : function () {}, (g.is.visible(n) || g.is.animating(n)) && (g.verbose('Doing menu hide animation', n), o == 'none' ? (i(), n.transition('hide'), e.call(z)) : Y.fn.transition !== J && w.transition('is supported') ? n.transition({
              animation: `${o} out`, duration: p.duration, debug: p.debug, verbose: p.verbose, queue: !1, onStart: i, onComplete() { e.call(z); },
            }) : g.error(f.transition));
          },
        },
        hideAndClear() { g.remove.searchTerm(), g.has.maxSelections() || (g.has.search() ? g.hide(() => { g.remove.filteredItem(); }) : g.hide()); },
        delay: { show() { g.verbose('Delaying show event to ensure user intent'), clearTimeout(g.timer), g.timer = setTimeout(g.show, p.delay.show); }, hide() { g.verbose('Delaying hide event to ensure user intent'), clearTimeout(g.timer), g.timer = setTimeout(g.hide, p.delay.hide); } },
        escape: { value(e) { const t = Y.isArray(e); const n = typeof e === 'string'; const i = !n && !t; const o = n && e.search(d.quote) !== -1; const a = []; return i || !o ? e : (g.debug('Encoding quote values for use in select', e), t ? (Y.each(e, (e, t) => { a.push(t.replace(d.quote, '&quot;')); }), a) : e.replace(d.quote, '&quot;')); }, string(e) { return (e = String(e)).replace(d.escape, '\\$&'); } },
        setting(e, t) { if (g.debug('Changing setting', e, t), Y.isPlainObject(e))Y.extend(!0, p, e); else { if (t === J) return p[e]; Y.isPlainObject(p[e]) ? Y.extend(!0, p[e], t) : p[e] = t; } },
        internal(e, t) { if (Y.isPlainObject(e))Y.extend(!0, g, e); else { if (t === J) return g[e]; g[e] = t; } },
        debug() { !p.silent && p.debug && (p.performance ? g.performance.log(arguments) : (g.debug = Function.prototype.bind.call(console.info, console, `${p.name}:`), g.debug.apply(console, arguments))); },
        verbose() { !p.silent && p.verbose && p.debug && (p.performance ? g.performance.log(arguments) : (g.verbose = Function.prototype.bind.call(console.info, console, `${p.name}:`), g.verbose.apply(console, arguments))); },
        error() { p.silent || (g.error = Function.prototype.bind.call(console.error, console, `${p.name}:`), g.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; p.performance && (n = (t = (new Date()).getTime()) - (W || t), W = t, B.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: z, 'Execution Time': n,
            })), clearTimeout(g.performance.timer), g.performance.timer = setTimeout(g.performance.display, 500);
          },
          display() { let e = `${p.name}:`; let n = 0; W = !1, clearTimeout(g.performance.timer), Y.each(B, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, H && (e += ` '${H}'`), (console.group !== J || console.table !== J) && B.length > 0 && (console.groupCollapsed(e), console.table ? console.table(B) : Y.each(B, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), B = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = I; return e = e || $, t = z || t, typeof i === 'string' && r !== J && (i = i.split(/[\. ]/), o = i.length - 1, Y.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (Y.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== J) return a = r[n], !1; if (!Y.isPlainObject(r[t]) || e == o) return r[t] !== J ? a = r[t] : g.error(f.method, i), !1; r = r[t]; } })), Y.isFunction(a) ? n = a.apply(t, e) : a !== J && (n = a), Y.isArray(L) ? L.push(n) : L !== J ? L = [L, n] : n !== J && (L = n), a; },
      }, X ? (I === J && g.initialize(), g.invoke(Q)) : (I !== J && I.invoke('destroy'), g.initialize());
    }), L !== J ? L : V;
  }, Y.fn.dropdown.settings = {
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    on: 'click',
    action: 'activate',
    values: !1,
    clearable: !1,
    apiSettings: !1,
    selectOnKeydown: !0,
    minCharacters: 0,
    filterRemoteData: !1,
    saveRemoteData: !0,
    throttle: 200,
    context: Z,
    direction: 'auto',
    keepOnScreen: !0,
    match: 'both',
    fullTextSearch: !1,
    placeholder: 'auto',
    preserveHTML: !0,
    sortSelect: !1,
    forceSelection: !0,
    allowAdditions: !1,
    ignoreCase: !1,
    hideAdditions: !0,
    maxSelections: !1,
    useLabels: !0,
    delimiter: ',',
    showOnFocus: !0,
    allowReselection: !1,
    allowTab: !0,
    allowCategorySelection: !1,
    fireOnInit: !1,
    transition: 'auto',
    duration: 200,
    glyphWidth: 1.037,
    label: { transition: 'scale', duration: 200, variation: !1 },
    delay: {
      hide: 300, show: 200, search: 20, touch: 50,
    },
    onChange(e, t, n) {},
    onAdd(e, t, n) {},
    onRemove(e, t, n) {},
    onLabelSelect(e) {},
    onLabelCreate(e, t) { return Y(this); },
    onLabelRemove(e) { return !0; },
    onNoResults(e) { return !0; },
    onShow() {},
    onHide() {},
    name: 'Dropdown',
    namespace: 'dropdown',
    message: {
      addResult: 'Add <b>{term}</b>', count: '{count} selected', maxSelections: 'Max {maxCount} selections', noResults: 'No results found.', serverError: 'There was an error contacting the server',
    },
    error: {
      action: 'You called a dropdown action that was not defined', alreadySetup: 'Once a select has been initialized behaviors must be called on the created ui dropdown', labels: 'Allowing user additions currently requires the use of labels.', missingMultiple: '<select> requires multiple property to be set to correctly preserve multiple values', method: 'The method you called is not defined.', noAPI: 'The API module is required to load resources remotely', noStorage: 'Saving remote data requires session storage', noTransition: 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>',
    },
    regExp: { escape: /[-[\]{}()*+?.,\\^$|#\s]/g, quote: /"/g },
    metadata: {
      defaultText: 'defaultText', defaultValue: 'defaultValue', placeholderText: 'placeholder', text: 'text', value: 'value',
    },
    fields: {
      remoteValues: 'results', values: 'values', disabled: 'disabled', name: 'name', value: 'value', text: 'text',
    },
    keys: {
      backspace: 8, delimiter: 188, deleteKey: 46, enter: 13, escape: 27, pageUp: 33, pageDown: 34, leftArrow: 37, upArrow: 38, rightArrow: 39, downArrow: 40,
    },
    selector: {
      addition: '.addition', dropdown: '.ui.dropdown', hidden: '.hidden', icon: '> .dropdown.icon', input: '> input[type="hidden"], > select', item: '.item', label: '> .label', remove: '> .label > .delete.icon', siblingLabel: '.label', menu: '.menu', message: '.message', menuIcon: '.dropdown.icon', search: 'input.search, .menu > .search > input, .menu input.search', sizer: '> input.sizer', text: '> .text:not(.icon)', unselectable: '.disabled, .filtered',
    },
    className: {
      active: 'active', addition: 'addition', animating: 'animating', clear: 'clear', disabled: 'disabled', empty: 'empty', dropdown: 'ui dropdown', filtered: 'filtered', hidden: 'hidden transition', item: 'item', label: 'ui label', loading: 'loading', menu: 'menu', message: 'message', multiple: 'multiple', placeholder: 'default', sizer: 'sizer', search: 'search', selected: 'selected', selection: 'selection', upward: 'upward', leftward: 'left', visible: 'visible',
    },
  }, Y.fn.dropdown.settings.templates = {
    dropdown(e) { const t = e.placeholder || !1; let n = (e.values, ''); return n += '<i class="dropdown icon"></i>', e.placeholder ? n += `<div class="default text">${t}</div>` : n += '<div class="text"></div>', n += '<div class="menu">', Y.each(e.values, (e, t) => { n += t.disabled ? `<div class="disabled item" data-value="${t.value}">${t.name}</div>` : `<div class="item" data-value="${t.value}">${t.name}</div>`; }), n += '</div>'; },
    menu(e, o) {
      const t = e[o.values] || {}; let a = ''; return Y.each(t, (e, t) => {
        const n = t[o.text] ? `data-text="${t[o.text]}"` : ''; const
          i = t[o.disabled] ? 'disabled ' : ''; a += `<div class="${i}item" data-value="${t[o.value]}"${n}>`, a += t[o.name], a += '</div>';
      }), a;
    },
    label(e, t) { return `${t}<i class="delete icon"></i>`; },
    message(e) { return e; },
    addition(e) { return e; },
  };
}(jQuery, window, document)), (function (k, T, e, A) {
  T = void 0 !== T && T.Math == Math ? T : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), k.fn.embed = function (p) {
    let h; const v = k(this); const b = v.selector || ''; let y = (new Date()).getTime(); let x = []; const C = p; const w = typeof C === 'string'; const S = [].slice.call(arguments, 1); return v.each(function () {
      let s; const i = k.isPlainObject(p) ? k.extend(!0, {}, k.fn.embed.settings, p) : k.extend({}, k.fn.embed.settings); const e = i.selector; const t = i.className; const o = i.sources; const l = i.error; const a = i.metadata; const n = i.namespace; const r = i.templates; const c = `.${n}`; const u = `module-${n}`; const d = (k(T), k(this)); let f = (d.find(e.placeholder), d.find(e.icon), d.find(e.embed)); const m = this; let g = d.data(u); s = {
        initialize() { s.debug('Initializing embed'), s.determine.autoplay(), s.create(), s.bind.events(), s.instantiate(); },
        instantiate() { s.verbose('Storing instance of module', s), g = s, d.data(u, s); },
        destroy() { s.verbose('Destroying previous instance of embed'), s.reset(), d.removeData(u).off(c); },
        refresh() { s.verbose('Refreshing selector cache'), d.find(e.placeholder), d.find(e.icon), f = d.find(e.embed); },
        bind: { events() { s.has.placeholder() && (s.debug('Adding placeholder events'), d.on(`click${c}`, e.placeholder, s.createAndShow).on(`click${c}`, e.icon, s.createAndShow)); } },
        create() { s.get.placeholder() ? s.createPlaceholder() : s.createAndShow(); },
        createPlaceholder(e) { const t = s.get.icon(); const n = s.get.url(); s.generate.embed(n); e = e || s.get.placeholder(), d.html(r.placeholder(e, t)), s.debug('Creating placeholder for embed', e, t); },
        createEmbed(e) { s.refresh(), e = e || s.get.url(), f = k('<div/>').addClass(t.embed).html(s.generate.embed(e)).appendTo(d), i.onCreate.call(m, e), s.debug('Creating embed object', f); },
        changeEmbed(e) { f.html(s.generate.embed(e)); },
        createAndShow() { s.createEmbed(), s.show(); },
        change(e, t, n) { s.debug('Changing video to ', e, t, n), d.data(a.source, e).data(a.id, t), n ? d.data(a.url, n) : d.removeData(a.url), s.has.embed() ? s.changeEmbed() : s.create(); },
        reset() { s.debug('Clearing embed and showing placeholder'), s.remove.data(), s.remove.active(), s.remove.embed(), s.showPlaceholder(), i.onReset.call(m); },
        show() { s.debug('Showing embed'), s.set.active(), i.onDisplay.call(m); },
        hide() { s.debug('Hiding embed'), s.showPlaceholder(); },
        showPlaceholder() { s.debug('Showing placeholder image'), s.remove.active(), i.onPlaceholderDisplay.call(m); },
        get: {
          id() { return i.id || d.data(a.id); }, placeholder() { return i.placeholder || d.data(a.placeholder); }, icon() { return i.icon ? i.icon : d.data(a.icon) !== A ? d.data(a.icon) : s.determine.icon(); }, source(e) { return i.source ? i.source : d.data(a.source) !== A ? d.data(a.source) : s.determine.source(); }, type() { const e = s.get.source(); return o[e] !== A && o[e].type; }, url() { return i.url ? i.url : d.data(a.url) !== A ? d.data(a.url) : s.determine.url(); },
        },
        determine: {
          autoplay() { s.should.autoplay() && (i.autoplay = !0); }, source(n) { let i = !1; return (n = n || s.get.url()) && k.each(o, (e, t) => { if (n.search(t.domain) !== -1) return i = e, !1; }), i; }, icon() { const e = s.get.source(); return o[e] !== A && o[e].icon; }, url() { let e; const t = i.id || d.data(a.id); const n = i.source || d.data(a.source); return (e = o[n] !== A && o[n].url.replace('{id}', t)) && d.data(a.url, e), e; },
        },
        set: { active() { d.addClass(t.active); } },
        remove: {
          data() {
            d.removeData(a.id).removeData(a.icon).removeData(a.placeholder).removeData(a.source)
              .removeData(a.url);
          },
          active() { d.removeClass(t.active); },
          embed() { f.empty(); },
        },
        encode: { parameters(e) { let t; const n = []; for (t in e)n.push(`${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`); return n.join('&amp;'); } },
        generate: { embed(e) { s.debug('Generating embed html'); let t; let n; const i = s.get.source(); return (e = s.get.url(e)) ? (n = s.generate.parameters(i), t = r.iframe(e, n)) : s.error(l.noURL, d), t; }, parameters(e, t) { let n = o[e] && o[e].parameters !== A ? o[e].parameters(i) : {}; return (t = t || i.parameters) && (n = k.extend({}, n, t)), n = i.onEmbed(n), s.encode.parameters(n); } },
        has: { embed() { return f.length > 0; }, placeholder() { return i.placeholder || d.data(a.placeholder); } },
        should: { autoplay() { return i.autoplay === 'auto' ? i.placeholder || d.data(a.placeholder) !== A : i.autoplay; } },
        is: { video() { return s.get.type() == 'video'; } },
        setting(e, t) { if (s.debug('Changing setting', e, t), k.isPlainObject(e))k.extend(!0, i, e); else { if (t === A) return i[e]; k.isPlainObject(i[e]) ? k.extend(!0, i[e], t) : i[e] = t; } },
        internal(e, t) { if (k.isPlainObject(e))k.extend(!0, s, e); else { if (t === A) return s[e]; s[e] = t; } },
        debug() { !i.silent && i.debug && (i.performance ? s.performance.log(arguments) : (s.debug = Function.prototype.bind.call(console.info, console, `${i.name}:`), s.debug.apply(console, arguments))); },
        verbose() { !i.silent && i.verbose && i.debug && (i.performance ? s.performance.log(arguments) : (s.verbose = Function.prototype.bind.call(console.info, console, `${i.name}:`), s.verbose.apply(console, arguments))); },
        error() { i.silent || (s.error = Function.prototype.bind.call(console.error, console, `${i.name}:`), s.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; i.performance && (n = (t = (new Date()).getTime()) - (y || t), y = t, x.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: m, 'Execution Time': n,
            })), clearTimeout(s.performance.timer), s.performance.timer = setTimeout(s.performance.display, 500);
          },
          display() { let e = `${i.name}:`; let n = 0; y = !1, clearTimeout(s.performance.timer), k.each(x, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, b && (e += ` '${b}'`), v.length > 1 && (e += ` (${v.length})`), (console.group !== A || console.table !== A) && x.length > 0 && (console.groupCollapsed(e), console.table ? console.table(x) : k.each(x, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), x = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = g; return e = e || S, t = m || t, typeof i === 'string' && r !== A && (i = i.split(/[\. ]/), o = i.length - 1, k.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (k.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== A) return a = r[n], !1; if (!k.isPlainObject(r[t]) || e == o) return r[t] !== A ? a = r[t] : s.error(l.method, i), !1; r = r[t]; } })), k.isFunction(a) ? n = a.apply(t, e) : a !== A && (n = a), k.isArray(h) ? h.push(n) : h !== A ? h = [h, n] : n !== A && (h = n), a; },
      }, w ? (g === A && s.initialize(), s.invoke(C)) : (g !== A && g.invoke('destroy'), s.initialize());
    }), h !== A ? h : this;
  }, k.fn.embed.settings = {
    name: 'Embed',
    namespace: 'embed',
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    icon: !1,
    source: !1,
    url: !1,
    id: !1,
    autoplay: 'auto',
    color: '#444444',
    hd: !0,
    brandedUI: !1,
    parameters: !1,
    onDisplay() {},
    onPlaceholderDisplay() {},
    onReset() {},
    onCreate(e) {},
    onEmbed(e) { return e; },
    metadata: {
      id: 'id', icon: 'icon', placeholder: 'placeholder', source: 'source', url: 'url',
    },
    error: { noURL: 'No URL specified', method: 'The method you called is not defined' },
    className: { active: 'active', embed: 'embed' },
    selector: { embed: '.embed', placeholder: '.placeholder', icon: '.icon' },
    sources: {
      youtube: {
        name: 'youtube',
        type: 'video',
        icon: 'video play',
        domain: 'youtube.com',
        url: '//www.youtube.com/embed/{id}',
        parameters(e) {
          return {
            autohide: !e.brandedUI, autoplay: e.autoplay, color: e.color || A, hq: e.hd, jsapi: e.api, modestbranding: !e.brandedUI,
          };
        },
      },
      vimeo: {
        name: 'vimeo',
        type: 'video',
        icon: 'video play',
        domain: 'vimeo.com',
        url: '//player.vimeo.com/video/{id}',
        parameters(e) {
          return {
            api: e.api, autoplay: e.autoplay, byline: e.brandedUI, color: e.color || A, portrait: e.brandedUI, title: e.brandedUI,
          };
        },
      },
    },
    templates: { iframe(e, t) { let n = e; return t && (n += `?${t}`), `<iframe src="${n}" width="100%" height="100%" frameborder="0" scrolling="no" webkitAllowFullScreen mozallowfullscreen allowFullScreen></iframe>`; }, placeholder(e, t) { let n = ''; return t && (n += `<i class="${t} icon"></i>`), e && (n += `<img class="placeholder" src="${e}">`), n; } },
    api: !1,
    onPause() {},
    onPlay() {},
    onStop() {},
  };
}(jQuery, window, document)), (function (j, z, I, M) {
  z = void 0 !== z && z.Math == Math ? z : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), j.fn.modal = function (w) {
    let S; const e = j(this); const k = j(z); const T = j(I); const A = j('body'); const R = e.selector || ''; let P = (new Date()).getTime(); let E = []; const F = w; const O = typeof F === 'string'; const D = [].slice.call(arguments, 1); const q = z.requestAnimationFrame || z.mozRequestAnimationFrame || z.webkitRequestAnimationFrame || z.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return e.each(function () {
      let n; let i; let e; let o; let a; let t; let r; let s; let l; const c = j.isPlainObject(w) ? j.extend(!0, {}, j.fn.modal.settings, w) : j.extend({}, j.fn.modal.settings); const u = c.selector; const d = c.className; const f = c.namespace; const m = c.error; const g = `.${f}`; const p = `module-${f}`; const h = j(this); const v = j(c.context); const b = h.find(u.close); const y = this; let x = h.data(p); let C = !1; l = {
        initialize() { l.verbose('Initializing dimmer', v), l.create.id(), l.create.dimmer(), l.refreshModals(), l.bind.events(), c.observeChanges && l.observeChanges(), l.instantiate(); },
        instantiate() { l.verbose('Storing instance of modal'), x = l, h.data(p, x); },
        create: { dimmer() { const e = { debug: c.debug, variation: !c.centered && 'top aligned', dimmerName: 'modals' }; const t = j.extend(!0, e, c.dimmerSettings); j.fn.dimmer !== M ? (l.debug('Creating dimmer'), o = v.dimmer(t), c.detachable ? (l.verbose('Modal is detachable, moving content into dimmer'), o.dimmer('add content', h)) : l.set.undetached(), a = o.dimmer('get dimmer')) : l.error(m.dimmer); }, id() { r = (`${Math.random().toString(16)}000000000`).substr(2, 8), t = `.${r}`, l.verbose('Creating unique id for element', r); } },
        destroy() { l.verbose('Destroying previous modal'), h.removeData(p).off(g), k.off(t), a.off(t), b.off(g), v.dimmer('destroy'); },
        observeChanges() { 'MutationObserver' in z && ((s = new MutationObserver(((e) => { l.debug('DOM tree modified, refreshing'), l.refresh(); }))).observe(y, { childList: !0, subtree: !0 }), l.debug('Setting up mutation observer', s)); },
        refresh() { l.remove.scrolling(), l.cacheSizes(), l.can.useFlex() || l.set.modalOffset(), l.set.screenHeight(), l.set.type(); },
        refreshModals() { i = h.siblings(u.modal), n = i.add(h); },
        attachEvents(e, t) { const n = j(e); t = j.isFunction(l[t]) ? l[t] : l.toggle, n.length > 0 ? (l.debug('Attaching modal events to element', e, t), n.off(g).on(`click${g}`, t)) : l.error(m.notFound, e); },
        bind: { events() { l.verbose('Attaching events'), h.on(`click${g}`, u.close, l.event.close).on(`click${g}`, u.approve, l.event.approve).on(`click${g}`, u.deny, l.event.deny), k.on(`resize${t}`, l.event.resize); }, scrollLock() { o.get(0).addEventListener('touchmove', l.event.preventScroll, { passive: !1 }); } },
        unbind: { scrollLock() { o.get(0).removeEventListener('touchmove', l.event.preventScroll, { passive: !1 }); } },
        get: { id() { return (`${Math.random().toString(16)}000000000`).substr(2, 8); } },
        event: {
          approve() { C || !1 === c.onApprove.call(y, j(this)) ? l.verbose('Approve callback returned false cancelling hide') : (C = !0, l.hide(() => { C = !1; })); }, preventScroll(e) { e.preventDefault(); }, deny() { C || !1 === c.onDeny.call(y, j(this)) ? l.verbose('Deny callback returned false cancelling hide') : (C = !0, l.hide(() => { C = !1; })); }, close() { l.hide(); }, click(e) { if (c.closable) { const t = j(e.target).closest(u.modal).length > 0; const n = j.contains(I.documentElement, e.target); !t && n && l.is.active() && (l.debug('Dimmer clicked, hiding all modals'), l.remove.clickaway(), c.allowMultiple ? l.hide() : l.hideAll()); } else l.verbose('Dimmer clicked but closable setting is disabled'); }, debounce(e, t) { clearTimeout(l.timer), l.timer = setTimeout(e, t); }, keyboard(e) { e.which == 27 && (c.closable ? (l.debug('Escape key pressed hiding modal'), l.hide()) : l.debug('Escape key pressed, but closable is set to false'), e.preventDefault()); }, resize() { o.dimmer('is active') && (l.is.animating() || l.is.active()) && q(l.refresh); },
        },
        toggle() { l.is.active() || l.is.animating() ? l.hide() : l.show(); },
        show(e) { e = j.isFunction(e) ? e : function () {}, l.refreshModals(), l.set.dimmerSettings(), l.set.dimmerStyles(), l.showModal(e); },
        hide(e) { e = j.isFunction(e) ? e : function () {}, l.refreshModals(), l.hideModal(e); },
        showModal(e) {
          e = j.isFunction(e) ? e : function () {}, l.is.animating() || !l.is.active() ? (l.showDimmer(), l.cacheSizes(), l.can.useFlex() ? l.remove.legacy() : (l.set.legacy(), l.set.modalOffset(), l.debug('Using non-flex legacy modal positioning.')), l.set.screenHeight(), l.set.type(), l.set.clickaway(), !c.allowMultiple && l.others.active() ? l.hideOthers(l.showModal) : (c.allowMultiple && c.detachable && h.detach().appendTo(a), c.onShow.call(y), c.transition && j.fn.transition !== M && h.transition('is supported') ? (l.debug('Showing modal with css animations'), h.transition({
            debug: c.debug, animation: `${c.transition} in`, queue: c.queue, duration: c.duration, useFailSafe: !0, onComplete() { c.onVisible.apply(y), c.keyboardShortcuts && l.add.keyboardShortcuts(), l.save.focus(), l.set.active(), c.autofocus && l.set.autofocus(), e(); },
          })) : l.error(m.noTransition))) : l.debug('Modal is already visible');
        },
        hideModal(e, t) {
          e = j.isFunction(e) ? e : function () {}, l.debug('Hiding modal'), !1 !== c.onHide.call(y, j(this)) ? (l.is.animating() || l.is.active()) && (c.transition && j.fn.transition !== M && h.transition('is supported') ? (l.remove.active(), h.transition({
            debug: c.debug, animation: `${c.transition} out`, queue: c.queue, duration: c.duration, useFailSafe: !0, onStart() { l.others.active() || t || l.hideDimmer(), c.keyboardShortcuts && l.remove.keyboardShortcuts(); }, onComplete() { c.onHidden.call(y), l.remove.dimmerStyles(), l.restore.focus(), e(); },
          })) : l.error(m.noTransition)) : l.verbose('Hide callback returned false cancelling hide');
        },
        showDimmer() { o.dimmer('is animating') || !o.dimmer('is active') ? (l.debug('Showing dimmer'), o.dimmer('show')) : l.debug('Dimmer already visible'); },
        hideDimmer() { o.dimmer('is animating') || o.dimmer('is active') ? (l.unbind.scrollLock(), o.dimmer('hide', () => { l.remove.clickaway(), l.remove.screenHeight(); })) : l.debug('Dimmer is not visible cannot hide'); },
        hideAll(e) { const t = n.filter(`.${d.active}, .${d.animating}`); e = j.isFunction(e) ? e : function () {}, t.length > 0 && (l.debug('Hiding all visible modals'), l.hideDimmer(), t.modal('hide modal', e)); },
        hideOthers(e) { const t = i.filter(`.${d.active}, .${d.animating}`); e = j.isFunction(e) ? e : function () {}, t.length > 0 && (l.debug('Hiding other modals', i), t.modal('hide modal', e, !0)); },
        others: { active() { return i.filter(`.${d.active}`).length > 0; }, animating() { return i.filter(`.${d.animating}`).length > 0; } },
        add: { keyboardShortcuts() { l.verbose('Adding keyboard shortcuts'), T.on(`keyup${g}`, l.event.keyboard); } },
        save: { focus() { j(I.activeElement).closest(h).length > 0 || (e = j(I.activeElement).blur()); } },
        restore: { focus() { e && e.length > 0 && e.focus(); } },
        remove: {
          active() { h.removeClass(d.active); }, legacy() { h.removeClass(d.legacy); }, clickaway() { a.off(`click${t}`); }, dimmerStyles() { a.removeClass(d.inverted), o.removeClass(d.blurring); }, bodyStyle() { A.attr('style') === '' && (l.verbose('Removing style attribute'), A.removeAttr('style')); }, screenHeight() { l.debug('Removing page height'), A.css('height', ''); }, keyboardShortcuts() { l.verbose('Removing keyboard shortcuts'), T.off(`keyup${g}`); }, scrolling() { o.removeClass(d.scrolling), h.removeClass(d.scrolling); },
        },
        cacheSizes() {
          h.addClass(d.loading); const e = h.prop('scrollHeight'); const t = h.outerWidth(); const n = h.outerHeight(); l.cache !== M && n === 0 || (l.cache = {
            pageHeight: j(I).outerHeight(), width: t, height: n + c.offset, scrollHeight: e + c.offset, contextHeight: c.context == 'body' ? j(z).height() : o.height(),
          }, l.cache.topOffset = -l.cache.height / 2), h.removeClass(d.loading), l.debug('Caching modal and container sizes', l.cache);
        },
        can: { useFlex() { return c.useFlex == 'auto' ? c.detachable && !l.is.ie() : c.useFlex; }, fit() { const e = l.cache.contextHeight; const t = l.cache.contextHeight / 2; const n = l.cache.topOffset; const i = l.cache.scrollHeight; const o = l.cache.height; const a = c.padding; return o < i ? t + n + i + a < e : o + 2 * a < e; } },
        is: {
          active() { return h.hasClass(d.active); }, ie() { return !z.ActiveXObject && 'ActiveXObject' in z || 'ActiveXObject' in z; }, animating() { return h.transition('is supported') ? h.transition('is animating') : h.is(':visible'); }, scrolling() { return o.hasClass(d.scrolling); }, modernBrowser() { return !(z.ActiveXObject || 'ActiveXObject' in z); },
        },
        set: {
          autofocus() { const e = h.find('[tabindex], :input').filter(':visible'); const t = e.filter('[autofocus]'); const n = t.length > 0 ? t.first() : e.first(); n.length > 0 && n.focus(); },
          clickaway() { a.on(`click${t}`, l.event.click); },
          dimmerSettings() {
            if (j.fn.dimmer !== M) {
              const e = {
                debug: c.debug, dimmerName: 'modals', closable: 'auto', useFlex: l.can.useFlex(), variation: !c.centered && 'top aligned', duration: { show: c.duration, hide: c.duration },
              }; const t = j.extend(!0, e, c.dimmerSettings); c.inverted && (t.variation = t.variation !== M ? `${t.variation} inverted` : 'inverted'), v.dimmer('setting', t);
            } else l.error(m.dimmer);
          },
          dimmerStyles() { c.inverted ? a.addClass(d.inverted) : a.removeClass(d.inverted), c.blurring ? o.addClass(d.blurring) : o.removeClass(d.blurring); },
          modalOffset() { const e = l.cache.width; const t = l.cache.height; h.css({ marginTop: c.centered && l.can.fit() ? -t / 2 : 0, marginLeft: -e / 2 }), l.verbose('Setting modal offset for legacy mode'); },
          screenHeight() { l.can.fit() ? A.css('height', '') : (l.debug('Modal is taller than page content, resizing page height'), A.css('height', l.cache.height + 2 * c.padding)); },
          active() { h.addClass(d.active); },
          scrolling() { o.addClass(d.scrolling), h.addClass(d.scrolling), l.unbind.scrollLock(); },
          legacy() { h.addClass(d.legacy); },
          type() { l.can.fit() ? (l.verbose('Modal fits on screen'), l.others.active() || l.others.animating() || (l.remove.scrolling(), l.bind.scrollLock())) : (l.verbose('Modal cannot fit on screen setting to scrolling'), l.set.scrolling()); },
          undetached() { o.addClass(d.undetached); },
        },
        setting(e, t) { if (l.debug('Changing setting', e, t), j.isPlainObject(e))j.extend(!0, c, e); else { if (t === M) return c[e]; j.isPlainObject(c[e]) ? j.extend(!0, c[e], t) : c[e] = t; } },
        internal(e, t) { if (j.isPlainObject(e))j.extend(!0, l, e); else { if (t === M) return l[e]; l[e] = t; } },
        debug() { !c.silent && c.debug && (c.performance ? l.performance.log(arguments) : (l.debug = Function.prototype.bind.call(console.info, console, `${c.name}:`), l.debug.apply(console, arguments))); },
        verbose() { !c.silent && c.verbose && c.debug && (c.performance ? l.performance.log(arguments) : (l.verbose = Function.prototype.bind.call(console.info, console, `${c.name}:`), l.verbose.apply(console, arguments))); },
        error() { c.silent || (l.error = Function.prototype.bind.call(console.error, console, `${c.name}:`), l.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; c.performance && (n = (t = (new Date()).getTime()) - (P || t), P = t, E.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: y, 'Execution Time': n,
            })), clearTimeout(l.performance.timer), l.performance.timer = setTimeout(l.performance.display, 500);
          },
          display() { let e = `${c.name}:`; let n = 0; P = !1, clearTimeout(l.performance.timer), j.each(E, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, R && (e += ` '${R}'`), (console.group !== M || console.table !== M) && E.length > 0 && (console.groupCollapsed(e), console.table ? console.table(E) : j.each(E, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), E = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = x; return e = e || D, t = y || t, typeof i === 'string' && r !== M && (i = i.split(/[\. ]/), o = i.length - 1, j.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (j.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== M) return a = r[n], !1; if (!j.isPlainObject(r[t]) || e == o) return r[t] !== M && (a = r[t]), !1; r = r[t]; } })), j.isFunction(a) ? n = a.apply(t, e) : a !== M && (n = a), j.isArray(S) ? S.push(n) : S !== M ? S = [S, n] : n !== M && (S = n), a; },
      }, O ? (x === M && l.initialize(), l.invoke(F)) : (x !== M && x.invoke('destroy'), l.initialize());
    }), S !== M ? S : this;
  }, j.fn.modal.settings = {
    name: 'Modal',
    namespace: 'modal',
    useFlex: 'auto',
    offset: 0,
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    observeChanges: !1,
    allowMultiple: !1,
    detachable: !0,
    closable: !0,
    autofocus: !0,
    inverted: !1,
    blurring: !1,
    centered: !0,
    dimmerSettings: { closable: !1, useCSS: !0 },
    keyboardShortcuts: !0,
    context: 'body',
    queue: !1,
    duration: 500,
    transition: 'scale',
    padding: 50,
    onShow() {},
    onVisible() {},
    onHide() { return !0; },
    onHidden() {},
    onApprove() { return !0; },
    onDeny() { return !0; },
    selector: {
      close: '> .close', approve: '.actions .positive, .actions .approve, .actions .ok', deny: '.actions .negative, .actions .deny, .actions .cancel', modal: '.ui.modal',
    },
    error: { dimmer: 'UI Dimmer, a required component is not included in this page', method: 'The method you called is not defined.', notFound: 'The element you specified could not be found' },
    className: {
      active: 'active', animating: 'animating', blurring: 'blurring', inverted: 'inverted', legacy: 'legacy', loading: 'loading', scrolling: 'scrolling', undetached: 'undetached',
    },
  };
}(jQuery, window, document)), (function (y, x, e, C) {
  x = void 0 !== x && x.Math == Math ? x : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), y.fn.nag = function (d) {
    let f; const e = y(this); const m = e.selector || ''; let g = (new Date()).getTime(); let p = []; const h = d; const v = typeof h === 'string'; const b = [].slice.call(arguments, 1); return e.each(function () {
      let s; const i = y.isPlainObject(d) ? y.extend(!0, {}, y.fn.nag.settings, d) : y.extend({}, y.fn.nag.settings); const e = (i.className, i.selector); const l = i.error; const t = i.namespace; const n = `.${t}`; const o = `${t}-module`; const a = y(this); const r = (a.find(e.close), i.context ? y(i.context) : y('body')); const c = this; const u = a.data(o); x.requestAnimationFrame || x.mozRequestAnimationFrame || x.webkitRequestAnimationFrame || x.msRequestAnimationFrame; s = {
        initialize() { s.verbose('Initializing element'), a.on(`click${n}`, e.close, s.dismiss).data(o, s), i.detachable && a.parent()[0] !== r[0] && a.detach().prependTo(r), i.displayTime > 0 && setTimeout(s.hide, i.displayTime), s.show(); },
        destroy() { s.verbose('Destroying instance'), a.removeData(o).off(n); },
        show() { s.should.show() && !a.is(':visible') && (s.debug('Showing nag', i.animation.show), i.animation.show == 'fade' ? a.fadeIn(i.duration, i.easing) : a.slideDown(i.duration, i.easing)); },
        hide() { s.debug('Showing nag', i.animation.hide), i.animation.show == 'fade' ? a.fadeIn(i.duration, i.easing) : a.slideUp(i.duration, i.easing); },
        onHide() { s.debug('Removing nag', i.animation.hide), a.remove(), i.onHide && i.onHide(); },
        dismiss(e) { i.storageMethod && s.storage.set(i.key, i.value), s.hide(), e.stopImmediatePropagation(), e.preventDefault(); },
        should: { show() { return i.persist ? (s.debug('Persistent nag is set, can show nag'), !0) : s.storage.get(i.key) != i.value.toString() ? (s.debug('Stored value is not set, can show nag', s.storage.get(i.key)), !0) : (s.debug('Stored value is set, cannot show nag', s.storage.get(i.key)), !1); } },
        get: { storageOptions() { const e = {}; return i.expires && (e.expires = i.expires), i.domain && (e.domain = i.domain), i.path && (e.path = i.path), e; } },
        clear() { s.storage.remove(i.key); },
        storage: { set(e, t) { const n = s.get.storageOptions(); if (i.storageMethod == 'localstorage' && x.localStorage !== C)x.localStorage.setItem(e, t), s.debug('Value stored using local storage', e, t); else if (i.storageMethod == 'sessionstorage' && x.sessionStorage !== C)x.sessionStorage.setItem(e, t), s.debug('Value stored using session storage', e, t); else { if (y.cookie === C) return void s.error(l.noCookieStorage); y.cookie(e, t, n), s.debug('Value stored using cookie', e, t, n); } }, get(e, t) { let n; return i.storageMethod == 'localstorage' && x.localStorage !== C ? n = x.localStorage.getItem(e) : i.storageMethod == 'sessionstorage' && x.sessionStorage !== C ? n = x.sessionStorage.getItem(e) : y.cookie !== C ? n = y.cookie(e) : s.error(l.noCookieStorage), n != 'undefined' && n != 'null' && n !== C && n !== null || (n = C), n; }, remove(e) { const t = s.get.storageOptions(); i.storageMethod == 'localstorage' && x.localStorage !== C ? x.localStorage.removeItem(e) : i.storageMethod == 'sessionstorage' && x.sessionStorage !== C ? x.sessionStorage.removeItem(e) : y.cookie !== C ? y.removeCookie(e, t) : s.error(l.noStorage); } },
        setting(e, t) { if (s.debug('Changing setting', e, t), y.isPlainObject(e))y.extend(!0, i, e); else { if (t === C) return i[e]; y.isPlainObject(i[e]) ? y.extend(!0, i[e], t) : i[e] = t; } },
        internal(e, t) { if (y.isPlainObject(e))y.extend(!0, s, e); else { if (t === C) return s[e]; s[e] = t; } },
        debug() { !i.silent && i.debug && (i.performance ? s.performance.log(arguments) : (s.debug = Function.prototype.bind.call(console.info, console, `${i.name}:`), s.debug.apply(console, arguments))); },
        verbose() { !i.silent && i.verbose && i.debug && (i.performance ? s.performance.log(arguments) : (s.verbose = Function.prototype.bind.call(console.info, console, `${i.name}:`), s.verbose.apply(console, arguments))); },
        error() { i.silent || (s.error = Function.prototype.bind.call(console.error, console, `${i.name}:`), s.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; i.performance && (n = (t = (new Date()).getTime()) - (g || t), g = t, p.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: c, 'Execution Time': n,
            })), clearTimeout(s.performance.timer), s.performance.timer = setTimeout(s.performance.display, 500);
          },
          display() { let e = `${i.name}:`; let n = 0; g = !1, clearTimeout(s.performance.timer), y.each(p, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, m && (e += ` '${m}'`), (console.group !== C || console.table !== C) && p.length > 0 && (console.groupCollapsed(e), console.table ? console.table(p) : y.each(p, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), p = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = u; return e = e || b, t = c || t, typeof i === 'string' && r !== C && (i = i.split(/[\. ]/), o = i.length - 1, y.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (y.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== C) return a = r[n], !1; if (!y.isPlainObject(r[t]) || e == o) return r[t] !== C ? a = r[t] : s.error(l.method, i), !1; r = r[t]; } })), y.isFunction(a) ? n = a.apply(t, e) : a !== C && (n = a), y.isArray(f) ? f.push(n) : f !== C ? f = [f, n] : n !== C && (f = n), a; },
      }, v ? (u === C && s.initialize(), s.invoke(h)) : (u !== C && u.invoke('destroy'), s.initialize());
    }), f !== C ? f : this;
  }, y.fn.nag.settings = {
    name: 'Nag', silent: !1, debug: !1, verbose: !1, performance: !0, namespace: 'Nag', persist: !1, displayTime: 0, animation: { show: 'slide', hide: 'slide' }, context: !1, detachable: !1, expires: 30, domain: !1, path: '/', storageMethod: 'cookie', key: 'nag', value: 'dismiss', error: { noCookieStorage: '$.cookie is not included. A storage solution is required.', noStorage: 'Neither $.cookie or store is defined. A storage solution is required for storing state', method: 'The method you called is not defined.' }, className: { bottom: 'bottom', fixed: 'fixed' }, selector: { close: '.close.icon' }, speed: 500, easing: 'easeOutQuad', onHide() {},
  }, y.extend(y.easing, { easeOutQuad(e, t, n, i, o) { return -i * (t /= o) * (t - 2) + n; } });
}(jQuery, window, document)), (function (z, I, M, L) {
  I = void 0 !== I && I.Math == Math ? I : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), z.fn.popup = function (k) {
    let T; const e = z(this); const A = z(M); const R = z(I); const P = z('body'); const E = e.selector || ''; let F = (new Date()).getTime(); let O = []; const D = k; const q = typeof D === 'string'; const j = [].slice.call(arguments, 1); return e.each(function () {
      let u; let c; let e; let t; let n; let d; const f = z.isPlainObject(k) ? z.extend(!0, {}, z.fn.popup.settings, k) : z.extend({}, z.fn.popup.settings); const o = f.selector; const m = f.className; const g = f.error; const p = f.metadata; const i = f.namespace; const a = `.${f.namespace}`; const r = `module-${i}`; const h = z(this); const s = z(f.context); const l = z(f.scrollContext); const v = z(f.boundary); const b = f.target ? z(f.target) : h; let y = 0; let x = !1; let C = !1; const w = this; let S = h.data(r); d = {
        initialize() { d.debug('Initializing', h), d.createID(), d.bind.events(), !d.exists() && f.preserve && d.create(), f.observeChanges && d.observeChanges(), d.instantiate(); },
        instantiate() { d.verbose('Storing instance', d), S = d, h.data(r, S); },
        observeChanges() { 'MutationObserver' in I && ((e = new MutationObserver(d.event.documentChanged)).observe(M, { childList: !0, subtree: !0 }), d.debug('Setting up mutation observer', e)); },
        refresh() { f.popup ? u = z(f.popup).eq(0) : f.inline && (u = b.nextAll(o.popup).eq(0), f.popup = u), f.popup ? (u.addClass(m.loading), c = d.get.offsetParent(), u.removeClass(m.loading), f.movePopup && d.has.popup() && d.get.offsetParent(u)[0] !== c[0] && (d.debug('Moving popup to the same offset parent as target'), u.detach().appendTo(c))) : c = f.inline ? d.get.offsetParent(b) : d.has.popup() ? d.get.offsetParent(u) : P, c.is('html') && c[0] !== P[0] && (d.debug('Setting page as offset parent'), c = P), d.get.variation() && d.set.variation(); },
        reposition() { d.refresh(), d.set.position(); },
        destroy() { d.debug('Destroying previous module'), e && e.disconnect(), u && !f.preserve && d.removePopup(), clearTimeout(d.hideTimer), clearTimeout(d.showTimer), d.unbind.close(), d.unbind.events(), h.removeData(r); },
        event: {
          start(e) { const t = z.isPlainObject(f.delay) ? f.delay.show : f.delay; clearTimeout(d.hideTimer), C || (d.showTimer = setTimeout(d.show, t)); }, end() { const e = z.isPlainObject(f.delay) ? f.delay.hide : f.delay; clearTimeout(d.showTimer), d.hideTimer = setTimeout(d.hide, e); }, touchstart(e) { C = !0, d.show(); }, resize() { d.is.visible() && d.set.position(); }, documentChanged(e) { [].forEach.call(e, (e) => { e.removedNodes && [].forEach.call(e.removedNodes, (e) => { (e == w || z(e).find(w).length > 0) && (d.debug('Element removed from DOM, tearing down events'), d.destroy()); }); }); }, hideGracefully(e) { const t = z(e.target); const n = z.contains(M.documentElement, e.target); const i = t.closest(o.popup).length > 0; e && !i && n ? (d.debug('Click occurred outside popup hiding popup'), d.hide()) : d.debug('Click was inside popup, keeping popup open'); },
        },
        create() { let e = d.get.html(); const t = d.get.title(); const n = d.get.content(); e || n || t ? (d.debug('Creating pop-up html'), e || (e = f.templates.popup({ title: t, content: n })), u = z('<div/>').addClass(m.popup).data(p.activator, h).html(e), f.inline ? (d.verbose('Inserting popup element inline', u), u.insertAfter(h)) : (d.verbose('Appending popup element to body', u), u.appendTo(s)), d.refresh(), d.set.variation(), f.hoverable && d.bind.popup(), f.onCreate.call(u, w)) : b.next(o.popup).length !== 0 ? (d.verbose('Pre-existing popup found'), f.inline = !0, f.popup = b.next(o.popup).data(p.activator, h), d.refresh(), f.hoverable && d.bind.popup()) : f.popup ? (z(f.popup).data(p.activator, h), d.verbose('Used popup specified in settings'), d.refresh(), f.hoverable && d.bind.popup()) : d.debug('No content specified skipping display', w); },
        createID() { n = (`${Math.random().toString(16)}000000000`).substr(2, 8), t = `.${n}`, d.verbose('Creating unique id for element', n); },
        toggle() { d.debug('Toggling pop-up'), d.is.hidden() ? (d.debug('Popup is hidden, showing pop-up'), d.unbind.close(), d.show()) : (d.debug('Popup is visible, hiding pop-up'), d.hide()); },
        show(e) { if (e = e || function () {}, d.debug('Showing pop-up', f.transition), d.is.hidden() && (!d.is.active() || !d.is.dropdown())) { if (d.exists() || d.create(), !1 === f.onShow.call(u, w)) return void d.debug('onShow callback returned false, cancelling popup animation'); f.preserve || f.popup || d.refresh(), u && d.set.position() && (d.save.conditions(), f.exclusive && d.hideAll(), d.animate.show(e)); } },
        hide(e) { if (e = e || function () {}, d.is.visible() || d.is.animating()) { if (!1 === f.onHide.call(u, w)) return void d.debug('onHide callback returned false, cancelling popup animation'); d.remove.visible(), d.unbind.close(), d.restore.conditions(), d.animate.hide(e); } },
        hideAll() { z(o.popup).filter(`.${m.popupVisible}`).each(function () { z(this).data(p.activator).popup('hide'); }); },
        exists() { return !!u && (f.inline || f.popup ? d.has.popup() : u.closest(s).length >= 1); },
        removePopup() { d.has.popup() && !f.popup && (d.debug('Removing popup', u), u.remove(), u = L, f.onRemove.call(u, w)); },
        save: { conditions() { d.cache = { title: h.attr('title') }, d.cache.title && h.removeAttr('title'), d.verbose('Saving original attributes', d.cache.title); } },
        restore: { conditions() { return d.cache && d.cache.title && (h.attr('title', d.cache.title), d.verbose('Restoring original attributes', d.cache.title)), !0; } },
        supports: { svg() { return typeof SVGGraphicsElement === 'undefined'; } },
        animate: {
          show(e) {
            e = z.isFunction(e) ? e : function () {}, f.transition && z.fn.transition !== L && h.transition('is supported') ? (d.set.visible(), u.transition({
              animation: `${f.transition} in`, queue: !1, debug: f.debug, verbose: f.verbose, duration: f.duration, onComplete() { d.bind.close(), e.call(u, w), f.onVisible.call(u, w); },
            })) : d.error(g.noTransition);
          },
          hide(e) {
            e = z.isFunction(e) ? e : function () {}, d.debug('Hiding pop-up'), !1 !== f.onHide.call(u, w) ? f.transition && z.fn.transition !== L && h.transition('is supported') ? u.transition({
              animation: `${f.transition} out`, queue: !1, duration: f.duration, debug: f.debug, verbose: f.verbose, onComplete() { d.reset(), e.call(u, w), f.onHidden.call(u, w); },
            }) : d.error(g.noTransition) : d.debug('onHide callback returned false, cancelling popup animation');
          },
        },
        change: { content(e) { u.html(e); } },
        get: {
          html() { return h.removeData(p.html), h.data(p.html) || f.html; },
          title() { return h.removeData(p.title), h.data(p.title) || f.title; },
          content() { return h.removeData(p.content), h.data(p.content) || f.content || h.attr('title'); },
          variation() { return h.removeData(p.variation), h.data(p.variation) || f.variation; },
          popup() { return u; },
          popupOffset() { return u.offset(); },
          calculations() {
            let e; const t = d.get.offsetParent(u); const n = b[0]; const i = v[0] == I; const o = f.inline || f.popup && f.movePopup ? b.position() : b.offset(); const a = i ? { top: 0, left: 0 } : v.offset(); let r = {}; const s = i ? { top: R.scrollTop(), left: R.scrollLeft() } : { top: 0, left: 0 }; if (r = {
              target: {
                element: b[0], width: b.outerWidth(), height: b.outerHeight(), top: o.top, left: o.left, margin: {},
              },
              popup: { width: u.outerWidth(), height: u.outerHeight() },
              parent: { width: c.outerWidth(), height: c.outerHeight() },
              screen: {
                top: a.top, left: a.left, scroll: { top: s.top, left: s.left }, width: v.width(), height: v.height(),
              },
            }, t.get(0) !== c.get(0)) { const l = t.offset(); r.target.top -= l.top, r.target.left -= l.left, r.parent.width = t.outerWidth(), r.parent.height = t.outerHeight(); } return f.setFluidWidth && d.is.fluid() && (r.container = { width: u.parent().outerWidth() }, r.popup.width = r.container.width), r.target.margin.top = f.inline ? parseInt(I.getComputedStyle(n).getPropertyValue('margin-top'), 10) : 0, r.target.margin.left = f.inline ? d.is.rtl() ? parseInt(I.getComputedStyle(n).getPropertyValue('margin-right'), 10) : parseInt(I.getComputedStyle(n).getPropertyValue('margin-left'), 10) : 0, e = r.screen, r.boundary = {
              top: e.top + e.scroll.top, bottom: e.top + e.scroll.top + e.height, left: e.left + e.scroll.left, right: e.left + e.scroll.left + e.width,
            }, r;
          },
          id() { return n; },
          startEvent() { return f.on == 'hover' ? 'mouseenter' : f.on == 'focus' && 'focus'; },
          scrollEvent() { return 'scroll'; },
          endEvent() { return f.on == 'hover' ? 'mouseleave' : f.on == 'focus' && 'blur'; },
          distanceFromBoundary(e, t) {
            let n; let i; let o = {}; return n = (t = t || d.get.calculations()).popup, i = t.boundary, e && (o = {
              top: e.top - i.top, left: e.left - i.left, right: i.right - (e.left + n.width), bottom: i.bottom - (e.top + n.height),
            }, d.verbose('Distance from boundaries determined', e, o)), o;
          },
          offsetParent(e) { let t = (e !== L ? e[0] : b[0]).parentNode; let n = z(t); if (t) for (let i = n.css('transform') === 'none', o = n.css('position') === 'static', a = n.is('body'); t && !a && o && i;)t = t.parentNode, i = (n = z(t)).css('transform') === 'none', o = n.css('position') === 'static', a = n.is('body'); return n && n.length > 0 ? n : z(); },
          positions() {
            return {
              'top left': !1, 'top center': !1, 'top right': !1, 'bottom left': !1, 'bottom center': !1, 'bottom right': !1, 'left center': !1, 'right center': !1,
            };
          },
          nextPosition(e) {
            const t = e.split(' '); const n = t[0]; const i = t[1]; const o = n == 'top' || n == 'bottom'; let a = !1; let r = !1; let s = !1; return x || (d.verbose('All available positions available'), x = d.get.positions()), d.debug('Recording last position tried', e), x[e] = !0, f.prefer === 'opposite' && (s = (s = [{
              top: 'bottom', bottom: 'top', left: 'right', right: 'left',
            }[n], i]).join(' '), a = !0 === x[s], d.debug('Trying opposite strategy', s)), f.prefer === 'adjacent' && o && (s = (s = [n, { left: 'center', center: 'right', right: 'left' }[i]]).join(' '), r = !0 === x[s], d.debug('Trying adjacent strategy', s)), (r || a) && (d.debug('Using backup position', s), s = {
              'top left': 'top center', 'top center': 'top right', 'top right': 'right center', 'right center': 'bottom right', 'bottom right': 'bottom center', 'bottom center': 'bottom left', 'bottom left': 'left center', 'left center': 'top left',
            }[e]), s;
          },
        },
        set: {
          position(e, t) {
            if (b.length !== 0 && u.length !== 0) {
              let n; let i; let o; let a; let r; let s; let l; let c; if (t = t || d.get.calculations(), e = e || h.data(p.position) || f.position, n = h.data(p.offset) || f.offset, i = f.distanceAway, o = t.target, a = t.popup, r = t.parent, d.should.centerArrow(t) && (d.verbose('Adjusting offset to center arrow on small target element'), e != 'top left' && e != 'bottom left' || (n += o.width / 2, n -= f.arrowPixelsFromEdge), e != 'top right' && e != 'bottom right' || (n -= o.width / 2, n += f.arrowPixelsFromEdge)), o.width === 0 && o.height === 0 && !d.is.svg(o.element)) return d.debug('Popup target is hidden, no action taken'), !1; switch (f.inline && (d.debug('Adding margin to calculation', o.margin), e == 'left center' || e == 'right center' ? (n += o.margin.top, i += -o.margin.left) : e == 'top left' || e == 'top center' || e == 'top right' ? (n += o.margin.left, i -= o.margin.top) : (n += o.margin.left, i += o.margin.top)), d.debug('Determining popup position from calculations', e, t), d.is.rtl() && (e = e.replace(/left|right/g, (e) => (e == 'left' ? 'right' : 'left')), d.debug('RTL: Popup position updated', e)), y == f.maxSearchDepth && typeof f.lastResort === 'string' && (e = f.lastResort), e) {
                case 'top left': s = {
                  top: 'auto', bottom: r.height - o.top + i, left: o.left + n, right: 'auto',
                }; break; case 'top center': s = {
                  bottom: r.height - o.top + i, left: o.left + o.width / 2 - a.width / 2 + n, top: 'auto', right: 'auto',
                }; break; case 'top right': s = {
                  bottom: r.height - o.top + i, right: r.width - o.left - o.width - n, top: 'auto', left: 'auto',
                }; break; case 'left center': s = {
                  top: o.top + o.height / 2 - a.height / 2 + n, right: r.width - o.left + i, left: 'auto', bottom: 'auto',
                }; break; case 'right center': s = {
                  top: o.top + o.height / 2 - a.height / 2 + n, left: o.left + o.width + i, bottom: 'auto', right: 'auto',
                }; break; case 'bottom left': s = {
                  top: o.top + o.height + i, left: o.left + n, bottom: 'auto', right: 'auto',
                }; break; case 'bottom center': s = {
                  top: o.top + o.height + i, left: o.left + o.width / 2 - a.width / 2 + n, bottom: 'auto', right: 'auto',
                }; break; case 'bottom right': s = {
                  top: o.top + o.height + i, right: r.width - o.left - o.width - n, left: 'auto', bottom: 'auto',
                };
              } if (s === L && d.error(g.invalidPosition, e), d.debug('Calculated popup positioning values', s), u.css(s).removeClass(m.position).addClass(e).addClass(m.loading), l = d.get.popupOffset(), c = d.get.distanceFromBoundary(l, t), d.is.offstage(c, e)) { if (d.debug('Position is outside viewport', e), y < f.maxSearchDepth) return y++, e = d.get.nextPosition(e), d.debug('Trying new position', e), !!u && d.set.position(e, t); if (!f.lastResort) return d.debug('Popup could not find a position to display', u), d.error(g.cannotPlace, w), d.remove.attempts(), d.remove.loading(), d.reset(), f.onUnplaceable.call(u, w), !1; d.debug('No position found, showing with last position'); } return d.debug('Position is on stage', e), d.remove.attempts(), d.remove.loading(), f.setFluidWidth && d.is.fluid() && d.set.fluidWidth(t), !0;
            }d.error(g.notFound);
          },
          fluidWidth(e) { e = e || d.get.calculations(), d.debug('Automatically setting element width to parent width', e.parent.width), u.css('width', e.container.width); },
          variation(e) { (e = e || d.get.variation()) && d.has.popup() && (d.verbose('Adding variation to popup', e), u.addClass(e)); },
          visible() { h.addClass(m.visible); },
        },
        remove: {
          loading() { u.removeClass(m.loading); }, variation(e) { (e = e || d.get.variation()) && (d.verbose('Removing variation', e), u.removeClass(e)); }, visible() { h.removeClass(m.visible); }, attempts() { d.verbose('Resetting all searched positions'), y = 0, x = !1; },
        },
        bind: {
          events() { d.debug('Binding popup events to module'), f.on == 'click' && h.on(`click${a}`, d.toggle), f.on == 'hover' && h.on(`touchstart${a}`, d.event.touchstart), d.get.startEvent() && h.on(d.get.startEvent() + a, d.event.start).on(d.get.endEvent() + a, d.event.end), f.target && d.debug('Target set to element', b), R.on(`resize${t}`, d.event.resize); }, popup() { d.verbose('Allowing hover events on popup to prevent closing'), u && d.has.popup() && u.on(`mouseenter${a}`, d.event.start).on(`mouseleave${a}`, d.event.end); }, close() { (!0 === f.hideOnScroll || f.hideOnScroll == 'auto' && f.on != 'click') && d.bind.closeOnScroll(), d.is.closable() ? d.bind.clickaway() : f.on == 'hover' && C && d.bind.touchClose(); }, closeOnScroll() { d.verbose('Binding scroll close event to document'), l.one(d.get.scrollEvent() + t, d.event.hideGracefully); }, touchClose() { d.verbose('Binding popup touchclose event to document'), A.on(`touchstart${t}`, (e) => { d.verbose('Touched away from popup'), d.event.hideGracefully.call(w, e); }); }, clickaway() { d.verbose('Binding popup close event to document'), A.on(`click${t}`, (e) => { d.verbose('Clicked away from popup'), d.event.hideGracefully.call(w, e); }); },
        },
        unbind: { events() { R.off(t), h.off(a); }, close() { A.off(t), l.off(t); } },
        has: { popup() { return u && u.length > 0; } },
        should: { centerArrow(e) { return !d.is.basic() && e.target.width <= 2 * f.arrowPixelsFromEdge; } },
        is: {
          closable() { return f.closable == 'auto' ? f.on != 'hover' : f.closable; }, offstage(e, n) { const i = []; return z.each(e, (e, t) => { t < -f.jitter && (d.debug('Position exceeds allowable distance from edge', e, t, n), i.push(e)); }), i.length > 0; }, svg(e) { return d.supports.svg() && e instanceof SVGGraphicsElement; }, basic() { return h.hasClass(m.basic); }, active() { return h.hasClass(m.active); }, animating() { return u !== L && u.hasClass(m.animating); }, fluid() { return u !== L && u.hasClass(m.fluid); }, visible() { return u !== L && u.hasClass(m.popupVisible); }, dropdown() { return h.hasClass(m.dropdown); }, hidden() { return !d.is.visible(); }, rtl() { return h.css('direction') == 'rtl'; },
        },
        reset() { d.remove.visible(), f.preserve ? z.fn.transition !== L && u.transition('remove transition') : d.removePopup(); },
        setting(e, t) { if (z.isPlainObject(e))z.extend(!0, f, e); else { if (t === L) return f[e]; f[e] = t; } },
        internal(e, t) { if (z.isPlainObject(e))z.extend(!0, d, e); else { if (t === L) return d[e]; d[e] = t; } },
        debug() { !f.silent && f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
        verbose() { !f.silent && f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments))); },
        error() { f.silent || (d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; f.performance && (n = (t = (new Date()).getTime()) - (F || t), F = t, O.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: w, 'Execution Time': n,
            })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 500);
          },
          display() { let e = `${f.name}:`; let n = 0; F = !1, clearTimeout(d.performance.timer), z.each(O, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, E && (e += ` '${E}'`), (console.group !== L || console.table !== L) && O.length > 0 && (console.groupCollapsed(e), console.table ? console.table(O) : z.each(O, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), O = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = S; return e = e || j, t = w || t, typeof i === 'string' && r !== L && (i = i.split(/[\. ]/), o = i.length - 1, z.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (z.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== L) return a = r[n], !1; if (!z.isPlainObject(r[t]) || e == o) return r[t] !== L && (a = r[t]), !1; r = r[t]; } })), z.isFunction(a) ? n = a.apply(t, e) : a !== L && (n = a), z.isArray(T) ? T.push(n) : T !== L ? T = [T, n] : n !== L && (T = n), a; },
      }, q ? (S === L && d.initialize(), d.invoke(D)) : (S !== L && S.invoke('destroy'), d.initialize());
    }), T !== L ? T : this;
  }, z.fn.popup.settings = {
    name: 'Popup',
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    namespace: 'popup',
    observeChanges: !0,
    onCreate() {},
    onRemove() {},
    onShow() {},
    onVisible() {},
    onHide() {},
    onUnplaceable() {},
    onHidden() {},
    on: 'hover',
    boundary: I,
    addTouchEvents: !0,
    position: 'top left',
    variation: '',
    movePopup: !0,
    target: !1,
    popup: !1,
    inline: !1,
    preserve: !1,
    hoverable: !1,
    content: !1,
    html: !1,
    title: !1,
    closable: !0,
    hideOnScroll: 'auto',
    exclusive: !1,
    context: 'body',
    scrollContext: I,
    prefer: 'opposite',
    lastResort: !1,
    arrowPixelsFromEdge: 20,
    delay: { show: 50, hide: 70 },
    setFluidWidth: !0,
    duration: 200,
    transition: 'scale',
    distanceAway: 0,
    jitter: 2,
    offset: 0,
    maxSearchDepth: 15,
    error: {
      invalidPosition: 'The position you specified is not a valid position', cannotPlace: 'Popup does not fit within the boundaries of the viewport', method: 'The method you called is not defined.', noTransition: 'This module requires ui transitions <https://github.com/Semantic-Org/UI-Transition>', notFound: 'The target or popup you specified does not exist on the page',
    },
    metadata: {
      activator: 'activator', content: 'content', html: 'html', offset: 'offset', position: 'position', title: 'title', variation: 'variation',
    },
    className: {
      active: 'active', basic: 'basic', animating: 'animating', dropdown: 'dropdown', fluid: 'fluid', loading: 'loading', popup: 'ui popup', position: 'top left center bottom right', visible: 'visible', popupVisible: 'visible',
    },
    selector: { popup: '.ui.popup' },
    templates: {
      escape(e) {
        const t = {
          '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;',
        }; return /[&<>"'`]/.test(e) ? e.replace(/[&<>"'`]/g, (e) => t[e]) : e;
      },
      popup(e) { let t = ''; const n = z.fn.popup.settings.templates.escape; return typeof e !== L && (typeof e.title !== L && e.title && (e.title = n(e.title), t += `<div class="header">${e.title}</div>`), typeof e.content !== L && e.content && (e.content = n(e.content), t += `<div class="content">${e.content}</div>`)), t; },
    },
  };
}(jQuery, window, document)), (function (k, e, T, A) {
  void 0 !== (e = void 0 !== e && e.Math == Math ? e : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')()) && e.Math == Math || (typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')()); k.fn.progress = function (h) {
    let v; const e = k(this); const b = e.selector || ''; let y = (new Date()).getTime(); let x = []; const C = h; const w = typeof C === 'string'; const S = [].slice.call(arguments, 1); return e.each(function () {
      let s; const i = k.isPlainObject(h) ? k.extend(!0, {}, k.fn.progress.settings, h) : k.extend({}, k.fn.progress.settings); const t = i.className; const n = i.metadata; const e = i.namespace; const o = i.selector; const l = i.error; const a = `.${e}`; const r = `module-${e}`; const c = k(this); const u = k(this).find(o.bar); const d = k(this).find(o.progress); const f = k(this).find(o.label); const m = this; let g = c.data(r); let p = !1; s = {
        initialize() { s.debug('Initializing progress bar', i), s.set.duration(), s.set.transitionEvent(), s.read.metadata(), s.read.settings(), s.instantiate(); },
        instantiate() { s.verbose('Storing instance of progress', s), g = s, c.data(r, s); },
        destroy() { s.verbose('Destroying previous progress for', c), clearInterval(g.interval), s.remove.state(), c.removeData(r), g = A; },
        reset() { s.remove.nextValue(), s.update.progress(0); },
        complete() { (s.percent === A || s.percent < 100) && (s.remove.progressPoll(), s.set.percent(100)); },
        read: { metadata() { const e = { percent: c.data(n.percent), total: c.data(n.total), value: c.data(n.value) }; e.percent && (s.debug('Current percent value set from metadata', e.percent), s.set.percent(e.percent)), e.total && (s.debug('Total value set from metadata', e.total), s.set.total(e.total)), e.value && (s.debug('Current value set from metadata', e.value), s.set.value(e.value), s.set.progress(e.value)); }, settings() { !1 !== i.total && (s.debug('Current total set in settings', i.total), s.set.total(i.total)), !1 !== i.value && (s.debug('Current value set in settings', i.value), s.set.value(i.value), s.set.progress(s.value)), !1 !== i.percent && (s.debug('Current percent set in settings', i.percent), s.set.percent(i.percent)); } },
        bind: { transitionEnd(t) { const e = s.get.transitionEnd(); u.one(e + a, function (e) { clearTimeout(s.failSafeTimer), t.call(this, e); }), s.failSafeTimer = setTimeout(() => { u.triggerHandler(e); }, i.duration + i.failSafeDelay), s.verbose('Adding fail safe timer', s.timer); } },
        increment(e) { let t; let n; s.has.total() ? n = (t = s.get.value()) + (e = e || 1) : (n = (t = s.get.percent()) + (e = e || s.get.randomValue()), 100, s.debug('Incrementing percentage by', t, n)), n = s.get.normalizedValue(n), s.set.progress(n); },
        decrement(e) { let t; let n; s.get.total() ? (n = (t = s.get.value()) - (e = e || 1), s.debug('Decrementing value by', e, t)) : (n = (t = s.get.percent()) - (e = e || s.get.randomValue()), s.debug('Decrementing percentage by', e, t)), n = s.get.normalizedValue(n), s.set.progress(n); },
        has: { progressPoll() { return s.progressPoll; }, total() { return !1 !== s.get.total(); } },
        get: {
          text(e) { const t = s.value || 0; const n = s.total || 0; const i = p ? s.get.displayPercent() : s.percent || 0; const o = s.total > 0 ? n - t : 100 - i; return e = (e = e || '').replace('{value}', t).replace('{total}', n).replace('{left}', o).replace('{percent}', i), s.verbose('Adding variables to progress bar text', e), e; },
          normalizedValue(e) { if (e < 0) return s.debug('Value cannot decrement below 0'), 0; if (s.has.total()) { if (e > s.total) return s.debug('Value cannot increment above total', s.total), s.total; } else if (e > 100) return s.debug('Value cannot increment above 100 percent'), 100; return e; },
          updateInterval() { return i.updateInterval == 'auto' ? i.duration : i.updateInterval; },
          randomValue() { return s.debug('Generating random increment percentage'), Math.floor(Math.random() * i.random.max + i.random.min); },
          numericValue(e) { return typeof e === 'string' ? e.replace(/[^\d.]/g, '') !== '' && +e.replace(/[^\d.]/g, '') : e; },
          transitionEnd() {
            let e; const t = T.createElement('element'); const n = {
              transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd',
            }; for (e in n) if (t.style[e] !== A) return n[e];
          },
          displayPercent() { const e = u.width(); const t = c.width(); const n = parseInt(u.css('min-width'), 10) < e ? e / t * 100 : s.percent; return i.precision > 0 ? Math.round(n * (10 * i.precision)) / (10 * i.precision) : Math.round(n); },
          percent() { return s.percent || 0; },
          value() { return s.nextValue || s.value || 0; },
          total() { return s.total || !1; },
        },
        create: { progressPoll() { s.progressPoll = setTimeout(() => { s.update.toNextValue(), s.remove.progressPoll(); }, s.get.updateInterval()); } },
        is: {
          complete() { return s.is.success() || s.is.warning() || s.is.error(); }, success() { return c.hasClass(t.success); }, warning() { return c.hasClass(t.warning); }, error() { return c.hasClass(t.error); }, active() { return c.hasClass(t.active); }, visible() { return c.is(':visible'); },
        },
        remove: {
          progressPoll() { s.verbose('Removing progress poll timer'), s.progressPoll && (clearTimeout(s.progressPoll), delete s.progressPoll); }, nextValue() { s.verbose('Removing progress value stored for next update'), delete s.nextValue; }, state() { s.verbose('Removing stored state'), delete s.total, delete s.percent, delete s.value; }, active() { s.verbose('Removing active state'), c.removeClass(t.active); }, success() { s.verbose('Removing success state'), c.removeClass(t.success); }, warning() { s.verbose('Removing warning state'), c.removeClass(t.warning); }, error() { s.verbose('Removing error state'), c.removeClass(t.error); },
        },
        set: {
          barWidth(e) { e > 100 ? s.error(l.tooHigh, e) : e < 0 ? s.error(l.tooLow, e) : (u.css('width', `${e}%`), c.attr('data-percent', parseInt(e, 10))); }, duration(e) { e = typeof (e = e || i.duration) === 'number' ? `${e}ms` : e, s.verbose('Setting progress bar transition duration', e), u.css({ 'transition-duration': e }); }, percent(e) { e = typeof e === 'string' ? +e.replace('%', '') : e, e = i.precision > 0 ? Math.round(e * (10 * i.precision)) / (10 * i.precision) : Math.round(e), s.percent = e, s.has.total() || (s.value = i.precision > 0 ? Math.round(e / 100 * s.total * (10 * i.precision)) / (10 * i.precision) : Math.round(e / 100 * s.total * 10) / 10, i.limitValues && (s.value = s.value > 100 ? 100 : s.value < 0 ? 0 : s.value)), s.set.barWidth(e), s.set.labelInterval(), s.set.labels(), i.onChange.call(m, e, s.value, s.total); }, labelInterval() { clearInterval(s.interval), s.bind.transitionEnd(() => { s.verbose('Bar finished animating, removing continuous label updates'), clearInterval(s.interval), p = !1, s.set.labels(); }), p = !0, s.interval = setInterval(() => { k.contains(T.documentElement, m) || (clearInterval(s.interval), p = !1), s.set.labels(); }, i.framerate); }, labels() { s.verbose('Setting both bar progress and outer label text'), s.set.barLabel(), s.set.state(); }, label(e) { (e = e || '') && (e = s.get.text(e), s.verbose('Setting label to text', e), f.text(e)); }, state(e) { (e = e !== A ? e : s.percent) === 100 ? i.autoSuccess && !(s.is.warning() || s.is.error() || s.is.success()) ? (s.set.success(), s.debug('Automatically triggering success at 100%')) : (s.verbose('Reached 100% removing active state'), s.remove.active(), s.remove.progressPoll()) : e > 0 ? (s.verbose('Adjusting active progress bar label', e), s.set.active()) : (s.remove.active(), s.set.label(i.text.active)); }, barLabel(e) { e !== A ? d.text(s.get.text(e)) : i.label == 'ratio' && s.total ? (s.verbose('Adding ratio to bar label'), d.text(s.get.text(i.text.ratio))) : i.label == 'percent' && (s.verbose('Adding percentage to bar label'), d.text(s.get.text(i.text.percent))); }, active(e) { e = e || i.text.active, s.debug('Setting active state'), i.showActivity && !s.is.active() && c.addClass(t.active), s.remove.warning(), s.remove.error(), s.remove.success(), (e = i.onLabelUpdate('active', e, s.value, s.total)) && s.set.label(e), s.bind.transitionEnd(() => { i.onActive.call(m, s.value, s.total); }); }, success(e) { e = e || i.text.success || i.text.active, s.debug('Setting success state'), c.addClass(t.success), s.remove.active(), s.remove.warning(), s.remove.error(), s.complete(), e = i.text.success ? i.onLabelUpdate('success', e, s.value, s.total) : i.onLabelUpdate('active', e, s.value, s.total), s.set.label(e), s.bind.transitionEnd(() => { i.onSuccess.call(m, s.total); }); }, warning(e) { e = e || i.text.warning, s.debug('Setting warning state'), c.addClass(t.warning), s.remove.active(), s.remove.success(), s.remove.error(), s.complete(), (e = i.onLabelUpdate('warning', e, s.value, s.total)) && s.set.label(e), s.bind.transitionEnd(() => { i.onWarning.call(m, s.value, s.total); }); }, error(e) { e = e || i.text.error, s.debug('Setting error state'), c.addClass(t.error), s.remove.active(), s.remove.success(), s.remove.warning(), s.complete(), (e = i.onLabelUpdate('error', e, s.value, s.total)) && s.set.label(e), s.bind.transitionEnd(() => { i.onError.call(m, s.value, s.total); }); }, transitionEvent() { s.get.transitionEnd(); }, total(e) { s.total = e; }, value(e) { s.value = e; }, progress(e) { s.has.progressPoll() ? (s.debug('Updated within interval, setting next update to use new value', e), s.set.nextValue(e)) : (s.debug('First update in progress update interval, immediately updating', e), s.update.progress(e), s.create.progressPoll()); }, nextValue(e) { s.nextValue = e; },
        },
        update: { toNextValue() { const e = s.nextValue; e && (s.debug('Update interval complete using last updated value', e), s.update.progress(e), s.remove.nextValue()); }, progress(e) { let t; !1 === (e = s.get.numericValue(e)) && s.error(l.nonNumeric, e), e = s.get.normalizedValue(e), s.has.total() ? (s.set.value(e), t = e / s.total * 100, s.debug('Calculating percent complete from total', t)) : (t = e, s.debug('Setting value to exact percentage value', t)), s.set.percent(t); } },
        setting(e, t) { if (s.debug('Changing setting', e, t), k.isPlainObject(e))k.extend(!0, i, e); else { if (t === A) return i[e]; k.isPlainObject(i[e]) ? k.extend(!0, i[e], t) : i[e] = t; } },
        internal(e, t) { if (k.isPlainObject(e))k.extend(!0, s, e); else { if (t === A) return s[e]; s[e] = t; } },
        debug() { !i.silent && i.debug && (i.performance ? s.performance.log(arguments) : (s.debug = Function.prototype.bind.call(console.info, console, `${i.name}:`), s.debug.apply(console, arguments))); },
        verbose() { !i.silent && i.verbose && i.debug && (i.performance ? s.performance.log(arguments) : (s.verbose = Function.prototype.bind.call(console.info, console, `${i.name}:`), s.verbose.apply(console, arguments))); },
        error() { i.silent || (s.error = Function.prototype.bind.call(console.error, console, `${i.name}:`), s.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; i.performance && (n = (t = (new Date()).getTime()) - (y || t), y = t, x.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: m, 'Execution Time': n,
            })), clearTimeout(s.performance.timer), s.performance.timer = setTimeout(s.performance.display, 500);
          },
          display() { let e = `${i.name}:`; let n = 0; y = !1, clearTimeout(s.performance.timer), k.each(x, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, b && (e += ` '${b}'`), (console.group !== A || console.table !== A) && x.length > 0 && (console.groupCollapsed(e), console.table ? console.table(x) : k.each(x, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), x = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = g; return e = e || S, t = m || t, typeof i === 'string' && r !== A && (i = i.split(/[\. ]/), o = i.length - 1, k.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (k.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== A) return a = r[n], !1; if (!k.isPlainObject(r[t]) || e == o) return r[t] !== A ? a = r[t] : s.error(l.method, i), !1; r = r[t]; } })), k.isFunction(a) ? n = a.apply(t, e) : a !== A && (n = a), k.isArray(v) ? v.push(n) : v !== A ? v = [v, n] : n !== A && (v = n), a; },
      }, w ? (g === A && s.initialize(), s.invoke(C)) : (g !== A && g.invoke('destroy'), s.initialize());
    }), v !== A ? v : this;
  }, k.fn.progress.settings = {
    name: 'Progress',
    namespace: 'progress',
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    random: { min: 2, max: 5 },
    duration: 300,
    updateInterval: 'auto',
    autoSuccess: !0,
    showActivity: !0,
    limitValues: !0,
    label: 'percent',
    precision: 0,
    framerate: 1e3 / 30,
    percent: !1,
    total: !1,
    value: !1,
    failSafeDelay: 100,
    onLabelUpdate(e, t, n, i) { return t; },
    onChange(e, t, n) {},
    onSuccess(e) {},
    onActive(e, t) {},
    onError(e, t) {},
    onWarning(e, t) {},
    error: {
      method: 'The method you called is not defined.', nonNumeric: 'Progress value is non numeric', tooHigh: 'Value specified is above 100%', tooLow: 'Value specified is below 0%',
    },
    regExp: { variable: /\{\$*[A-z0-9]+\}/g },
    metadata: { percent: 'percent', total: 'total', value: 'value' },
    selector: { bar: '> .bar', label: '> .label', progress: '.bar > .progress' },
    text: {
      active: !1, error: !1, success: !1, warning: !1, percent: '{percent}%', ratio: '{value} of {total}',
    },
    className: {
      active: 'active', error: 'error', success: 'success', warning: 'warning',
    },
  };
}(jQuery, window, document)), (function (w, e, t, S) {
  e = void 0 !== e && e.Math == Math ? e : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), w.fn.rating = function (m) {
    let g; const p = w(this); const h = p.selector || ''; let v = (new Date()).getTime(); let b = []; const y = m; const x = typeof y === 'string'; const C = [].slice.call(arguments, 1); return p.each(function () {
      let e; let i; const o = w.isPlainObject(m) ? w.extend(!0, {}, w.fn.rating.settings, m) : w.extend({}, w.fn.rating.settings); const t = o.namespace; const a = o.className; const n = o.metadata; const r = o.selector; const s = (o.error, `.${t}`); const l = `module-${t}`; const c = this; let u = w(this).data(l); const d = w(this); let f = d.find(r.icon); i = {
        initialize() { i.verbose('Initializing rating module', o), f.length === 0 && i.setup.layout(), o.interactive ? i.enable() : i.disable(), i.set.initialLoad(), i.set.rating(i.get.initialRating()), i.remove.initialLoad(), i.instantiate(); },
        instantiate() { i.verbose('Instantiating module', o), u = i, d.data(l, i); },
        destroy() { i.verbose('Destroying previous instance', u), i.remove.events(), d.removeData(l); },
        refresh() { f = d.find(r.icon); },
        setup: { layout() { const e = i.get.maxRating(); const t = w.fn.rating.settings.templates.icon(e); i.debug('Generating icon html dynamically'), d.html(t), i.refresh(); } },
        event: { mouseenter() { const e = w(this); e.nextAll().removeClass(a.selected), d.addClass(a.selected), e.addClass(a.selected).prevAll().addClass(a.selected); }, mouseleave() { d.removeClass(a.selected), f.removeClass(a.selected); }, click() { const e = w(this); const t = i.get.rating(); const n = f.index(e) + 1; (o.clearable == 'auto' ? f.length === 1 : o.clearable) && t == n ? i.clearRating() : i.set.rating(n); } },
        clearRating() { i.debug('Clearing current rating'), i.set.rating(0); },
        bind: { events() { i.verbose('Binding events'), d.on(`mouseenter${s}`, r.icon, i.event.mouseenter).on(`mouseleave${s}`, r.icon, i.event.mouseleave).on(`click${s}`, r.icon, i.event.click); } },
        remove: { events() { i.verbose('Removing events'), d.off(s); }, initialLoad() { e = !1; } },
        enable() { i.debug('Setting rating to interactive mode'), i.bind.events(), d.removeClass(a.disabled); },
        disable() { i.debug('Setting rating to read-only mode'), i.remove.events(), d.addClass(a.disabled); },
        is: { initialLoad() { return e; } },
        get: { initialRating() { return d.data(n.rating) !== S ? (d.removeData(n.rating), d.data(n.rating)) : o.initialRating; }, maxRating() { return d.data(n.maxRating) !== S ? (d.removeData(n.maxRating), d.data(n.maxRating)) : o.maxRating; }, rating() { const e = f.filter(`.${a.active}`).length; return i.verbose('Current rating retrieved', e), e; } },
        set: { rating(e) { const t = e - 1 >= 0 ? e - 1 : 0; const n = f.eq(t); d.removeClass(a.selected), f.removeClass(a.selected).removeClass(a.active), e > 0 && (i.verbose('Setting current rating to', e), n.prevAll().addBack().addClass(a.active)), i.is.initialLoad() || o.onRate.call(c, e); }, initialLoad() { e = !0; } },
        setting(e, t) { if (i.debug('Changing setting', e, t), w.isPlainObject(e))w.extend(!0, o, e); else { if (t === S) return o[e]; w.isPlainObject(o[e]) ? w.extend(!0, o[e], t) : o[e] = t; } },
        internal(e, t) { if (w.isPlainObject(e))w.extend(!0, i, e); else { if (t === S) return i[e]; i[e] = t; } },
        debug() { !o.silent && o.debug && (o.performance ? i.performance.log(arguments) : (i.debug = Function.prototype.bind.call(console.info, console, `${o.name}:`), i.debug.apply(console, arguments))); },
        verbose() { !o.silent && o.verbose && o.debug && (o.performance ? i.performance.log(arguments) : (i.verbose = Function.prototype.bind.call(console.info, console, `${o.name}:`), i.verbose.apply(console, arguments))); },
        error() { o.silent || (i.error = Function.prototype.bind.call(console.error, console, `${o.name}:`), i.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; o.performance && (n = (t = (new Date()).getTime()) - (v || t), v = t, b.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: c, 'Execution Time': n,
            })), clearTimeout(i.performance.timer), i.performance.timer = setTimeout(i.performance.display, 500);
          },
          display() { let e = `${o.name}:`; let n = 0; v = !1, clearTimeout(i.performance.timer), w.each(b, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, h && (e += ` '${h}'`), p.length > 1 && (e += ` (${p.length})`), (console.group !== S || console.table !== S) && b.length > 0 && (console.groupCollapsed(e), console.table ? console.table(b) : w.each(b, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), b = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = u; return e = e || C, t = c || t, typeof i === 'string' && r !== S && (i = i.split(/[\. ]/), o = i.length - 1, w.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (w.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== S) return a = r[n], !1; if (!w.isPlainObject(r[t]) || e == o) return r[t] !== S && (a = r[t]), !1; r = r[t]; } })), w.isFunction(a) ? n = a.apply(t, e) : a !== S && (n = a), w.isArray(g) ? g.push(n) : g !== S ? g = [g, n] : n !== S && (g = n), a; },
      }, x ? (u === S && i.initialize(), i.invoke(y)) : (u !== S && u.invoke('destroy'), i.initialize());
    }), g !== S ? g : this;
  }, w.fn.rating.settings = {
    name: 'Rating',
    namespace: 'rating',
    slent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    initialRating: 0,
    interactive: !0,
    maxRating: 4,
    clearable: 'auto',
    fireOnInit: !1,
    onRate(e) {},
    error: { method: 'The method you called is not defined', noMaximum: 'No maximum rating specified. Cannot generate HTML automatically' },
    metadata: { rating: 'rating', maxRating: 'maxRating' },
    className: {
      active: 'active', disabled: 'disabled', selected: 'selected', loading: 'loading',
    },
    selector: { icon: '.icon' },
    templates: { icon(e) { for (var t = 1, n = ''; t <= e;)n += '<i class="icon"></i>', t++; return n; } },
  };
}(jQuery, window, document)), (function (E, F, O, D) {
  F = void 0 !== F && F.Math == Math ? F : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), E.fn.search = function (l) {
    let C; const w = E(this); const S = w.selector || ''; let k = (new Date()).getTime(); let T = []; const A = l; const R = typeof A === 'string'; const P = [].slice.call(arguments, 1); return E(this).each(function () {
      let f; const c = E.isPlainObject(l) ? E.extend(!0, {}, E.fn.search.settings, l) : E.extend({}, E.fn.search.settings); const m = c.className; const u = c.metadata; const d = c.regExp; const a = c.fields; const g = c.selector; const p = c.error; const e = c.namespace; const i = `.${e}`; const t = `${e}-module`; const h = E(this); let v = h.find(g.prompt); let n = h.find(g.searchButton); let o = h.find(g.results); let r = h.find(g.result); const b = (h.find(g.category), this); let s = h.data(t); let y = !1; let x = !1; f = {
        initialize() { f.verbose('Initializing module'), f.get.settings(), f.determine.searchFields(), f.bind.events(), f.set.type(), f.create.results(), f.instantiate(); },
        instantiate() { f.verbose('Storing instance of module', f), s = f, h.data(t, f); },
        destroy() { f.verbose('Destroying instance'), h.off(i).removeData(t); },
        refresh() { f.debug('Refreshing selector cache'), v = h.find(g.prompt), n = h.find(g.searchButton), h.find(g.category), o = h.find(g.results), r = h.find(g.result); },
        refreshResults() { o = h.find(g.results), r = h.find(g.result); },
        bind: {
          events() {
            f.verbose('Binding events to search'), c.automatic && (h.on(f.get.inputEvent() + i, g.prompt, f.event.input), v.attr('autocomplete', 'off')), h.on(`focus${i}`, g.prompt, f.event.focus).on(`blur${i}`, g.prompt, f.event.blur).on(`keydown${i}`, g.prompt, f.handleKeyboard).on(`click${i}`, g.searchButton, f.query)
              .on(`mousedown${i}`, g.results, f.event.result.mousedown)
              .on(`mouseup${i}`, g.results, f.event.result.mouseup)
              .on(`click${i}`, g.result, f.event.result.click);
          },
        },
        determine: { searchFields() { l && l.searchFields !== D && (c.searchFields = l.searchFields); } },
        event: {
          input() { c.searchDelay ? (clearTimeout(f.timer), f.timer = setTimeout(() => { f.is.focused() && f.query(); }, c.searchDelay)) : f.query(); }, focus() { f.set.focus(), c.searchOnFocus && f.has.minimumCharacters() && f.query(() => { f.can.show() && f.showResults(); }); }, blur(e) { const t = O.activeElement === this; const n = function () { f.cancel.query(), f.remove.focus(), f.timer = setTimeout(f.hideResults, c.hideDelay); }; t || (x = !1, f.resultsClicked ? (f.debug('Determining if user action caused search to close'), h.one(`click.close${i}`, g.results, (e) => { f.is.inMessage(e) || y ? v.focus() : (y = !1, f.is.animating() || f.is.hidden() || n()); })) : (f.debug('Input blurred without user action, closing results'), n())); }, result: { mousedown() { f.resultsClicked = !0; }, mouseup() { f.resultsClicked = !1; }, click(e) { f.debug('Search result selected'); const t = E(this); const n = t.find(g.title).eq(0); const i = t.is('a[href]') ? t : t.find('a[href]').eq(0); const o = i.attr('href') || !1; const a = i.attr('target') || !1; const r = (n.html(), n.length > 0 && n.text()); const s = f.get.results(); const l = t.data(u.result) || f.get.result(r, s); if (E.isFunction(c.onSelect) && !1 === c.onSelect.call(b, l, s)) return f.debug('Custom onSelect callback cancelled default select action'), void (y = !0); f.hideResults(), r && f.set.value(r), o && (f.verbose('Opening search link found in result', i), a == '_blank' || e.ctrlKey ? F.open(o) : F.location.href = o); } },
        },
        handleKeyboard(e) {
          let t; const n = h.find(g.result); const i = h.find(g.category); const o = n.filter(`.${m.active}`); const a = n.index(o); const r = n.length; const s = o.length > 0; const l = e.which; const c = 13; const u = 38; const d = 40; if (l == 27 && (f.verbose('Escape key pressed, blurring search field'), f.hideResults(), x = !0), f.is.visible()) {
            if (l == c) { if (f.verbose('Enter key pressed, selecting active result'), n.filter(`.${m.active}`).length > 0) return f.event.result.click.call(n.filter(`.${m.active}`), e), e.preventDefault(), !1; } else {
              l == u && s ? (f.verbose('Up key pressed, changing active result'), t = a - 1 < 0 ? a : a - 1, i.removeClass(m.active), n.removeClass(m.active).eq(t).addClass(m.active).closest(i)
                .addClass(m.active), e.preventDefault()) : l == d && (f.verbose('Down key pressed, changing active result'), t = r <= a + 1 ? a : a + 1, i.removeClass(m.active), n.removeClass(m.active).eq(t).addClass(m.active).closest(i)
                .addClass(m.active), e.preventDefault());
            }
          } else l == c && (f.verbose('Enter key pressed, executing query'), f.query(), f.set.buttonPressed(), v.one('keyup', f.remove.buttonFocus));
        },
        setup: {
          api(t, n) {
            const e = {
              debug: c.debug, on: !1, cache: c.cache, action: 'search', urlData: { query: t }, onSuccess(e) { f.parse.response.call(b, e, t), n(); }, onFailure() { f.displayMessage(p.serverError), n(); }, onAbort(e) {}, onError: f.error,
            }; E.extend(!0, e, c.apiSettings), f.verbose('Setting up API request', e), h.api(e);
          },
        },
        can: { useAPI() { return E.fn.api !== D; }, show() { return f.is.focused() && !f.is.visible() && !f.is.empty(); }, transition() { return c.transition && E.fn.transition !== D && h.transition('is supported'); } },
        is: {
          animating() { return o.hasClass(m.animating); }, hidden() { return o.hasClass(m.hidden); }, inMessage(e) { if (e.target) { const t = E(e.target); return E.contains(O.documentElement, e.target) && t.closest(g.message).length > 0; } }, empty() { return o.html() === ''; }, visible() { return o.filter(':visible').length > 0; }, focused() { return v.filter(':focus').length > 0; },
        },
        get: {
          settings() { E.isPlainObject(l) && l.searchFullText && (c.fullTextSearch = l.searchFullText, f.error(c.error.oldSearchSyntax, b)); }, inputEvent() { const e = v[0]; return e !== D && e.oninput !== D ? 'input' : e !== D && e.onpropertychange !== D ? 'propertychange' : 'keyup'; }, value() { return v.val(); }, results() { return h.data(u.results); }, result(n, e) { const i = ['title', 'id']; let o = !1; return n = n !== D ? n : f.get.value(), e = e !== D ? e : f.get.results(), c.type === 'category' ? (f.debug('Finding result that matches', n), E.each(e, (e, t) => { if (E.isArray(t.results) && (o = f.search.object(n, t.results, i)[0])) return !1; })) : (f.debug('Finding result in results object', n), o = f.search.object(n, e, i)[0]), o || !1; },
        },
        select: { firstResult() { f.verbose('Selecting first result'), r.first().addClass(m.active); } },
        set: {
          focus() { h.addClass(m.focus); }, loading() { h.addClass(m.loading); }, value(e) { f.verbose('Setting search input value', e), v.val(e); }, type(e) { e = e || c.type, c.type == 'category' && h.addClass(c.type); }, buttonPressed() { n.addClass(m.pressed); },
        },
        remove: { loading() { h.removeClass(m.loading); }, focus() { h.removeClass(m.focus); }, buttonPressed() { n.removeClass(m.pressed); } },
        query(e) { e = E.isFunction(e) ? e : function () {}; const t = f.get.value(); const n = f.read.cache(t); e = e || function () {}, f.has.minimumCharacters() ? (n ? (f.debug('Reading result from cache', t), f.save.results(n.results), f.addResults(n.html), f.inject.id(n.results), e()) : (f.debug('Querying for', t), E.isPlainObject(c.source) || E.isArray(c.source) ? (f.search.local(t), e()) : f.can.useAPI() ? f.search.remote(t, e) : (f.error(p.source), e())), c.onSearchQuery.call(b, t)) : f.hideResults(); },
        search: { local(e) { let t; let n = f.search.object(e, c.content); f.set.loading(), f.save.results(n), f.debug('Returned full local search results', n), c.maxResults > 0 && (f.debug('Using specified max results', n), n = n.slice(0, c.maxResults)), c.type == 'category' && (n = f.create.categoryResults(n)), t = f.generateResults({ results: n }), f.remove.loading(), f.addResults(t), f.inject.id(n), f.write.cache(e, { html: t, results: n }); }, remote(e, t) { t = E.isFunction(t) ? t : function () {}, h.api('is loading') && h.api('abort'), f.setup.api(e, t), h.api('query'); }, object(i, t, e) { const a = []; const r = []; const s = []; const n = i.toString().replace(d.escape, '\\$&'); const o = new RegExp(d.beginsWith + n, 'i'); const l = function (e, t) { const n = E.inArray(t, a) == -1; const i = E.inArray(t, s) == -1; const o = E.inArray(t, r) == -1; n && i && o && e.push(t); }; return t = t || c.source, e = e !== D ? e : c.searchFields, E.isArray(e) || (e = [e]), t === D || !1 === t ? (f.error(p.source), []) : (E.each(e, (e, n) => { E.each(t, (e, t) => { typeof t[n] === 'string' && (t[n].search(o) !== -1 ? l(a, t) : c.fullTextSearch === 'exact' && f.exactSearch(i, t[n]) ? l(r, t) : c.fullTextSearch == 1 && f.fuzzySearch(i, t[n]) && l(s, t)); }); }), E.merge(r, s), E.merge(a, r), a); } },
        exactSearch(e, t) { return e = e.toLowerCase(), (t = t.toLowerCase()).indexOf(e) > -1; },
        fuzzySearch(e, t) { const n = t.length; const i = e.length; if (typeof e !== 'string') return !1; if (e = e.toLowerCase(), t = t.toLowerCase(), n < i) return !1; if (i === n) return e === t; e:for (let o = 0, a = 0; o < i; o++) { for (let r = e.charCodeAt(o); a < n;) if (t.charCodeAt(a++) === r) continue e; return !1; } return !0; },
        parse: { response(e, t) { const n = f.generateResults(e); f.verbose('Parsing server response', e), e !== D && t !== D && e[a.results] !== D && (f.addResults(n), f.inject.id(e[a.results]), f.write.cache(t, { html: n, results: e[a.results] }), f.save.results(e[a.results])); } },
        cancel: { query() { f.can.useAPI() && h.api('abort'); } },
        has: { minimumCharacters() { return f.get.value().length >= c.minCharacters; }, results() { return o.length !== 0 && o.html() != ''; } },
        clear: { cache(e) { const t = h.data(u.cache); e ? e && t && t[e] && (f.debug('Removing value from cache', e), delete t[e], h.data(u.cache, t)) : (f.debug('Clearing cache', e), h.removeData(u.cache)); } },
        read: { cache(e) { const t = h.data(u.cache); return !!c.cache && (f.verbose('Checking cache for generated html for query', e), typeof t === 'object' && t[e] !== D && t[e]); } },
        create: { categoryResults(e) { const n = {}; return E.each(e, (e, t) => { t.category && (n[t.category] === D ? (f.verbose('Creating new category of results', t.category), n[t.category] = { name: t.category, results: [t] }) : n[t.category].results.push(t)); }), n; }, id(e, t) { let n; const i = e + 1; return t !== D ? (n = String.fromCharCode(97 + t) + i, f.verbose('Creating category result id', n)) : (n = i, f.verbose('Creating result id', n)), n; }, results() { o.length === 0 && (o = E('<div />').addClass(m.results).appendTo(h)); } },
        inject: {
          result(e, t, n) {
            f.verbose('Injecting result into results'); const i = n !== D ? o.children().eq(n).children(g.results).first()
              .children(g.result)
              .eq(t) : o.children(g.result).eq(t); f.verbose('Injecting results metadata', i), i.data(u.result, e);
          },
          id(i) { f.debug('Injecting unique ids into results'); let o = 0; let a = 0; return c.type === 'category' ? E.each(i, (e, i) => { a = 0, E.each(i.results, (e, t) => { const n = i.results[e]; n.id === D && (n.id = f.create.id(a, o)), f.inject.result(n, a, o), a++; }), o++; }) : E.each(i, (e, t) => { const n = i[e]; n.id === D && (n.id = f.create.id(a)), f.inject.result(n, a), a++; }), i; },
        },
        save: { results(e) { f.verbose('Saving current search results to metadata', e), h.data(u.results, e); } },
        write: { cache(e, t) { const n = h.data(u.cache) !== D ? h.data(u.cache) : {}; c.cache && (f.verbose('Writing generated html to cache', e, t), n[e] = t, h.data(u.cache, n)); } },
        addResults(e) { if (E.isFunction(c.onResultsAdd) && !1 === c.onResultsAdd.call(o, e)) return f.debug('onResultsAdd callback cancelled default action'), !1; e ? (o.html(e), f.refreshResults(), c.selectFirstResult && f.select.firstResult(), f.showResults()) : f.hideResults(() => { o.empty(); }); },
        showResults(e) {
          e = E.isFunction(e) ? e : function () {}, x || !f.is.visible() && f.has.results() && (f.can.transition() ? (f.debug('Showing results with css animations'), o.transition({
            animation: `${c.transition} in`, debug: c.debug, verbose: c.verbose, duration: c.duration, onComplete() { e(); }, queue: !0,
          })) : (f.debug('Showing results with javascript'), o.stop().fadeIn(c.duration, c.easing)), c.onResultsOpen.call(o));
        },
        hideResults(e) {
          e = E.isFunction(e) ? e : function () {}, f.is.visible() && (f.can.transition() ? (f.debug('Hiding results with css animations'), o.transition({
            animation: `${c.transition} out`, debug: c.debug, verbose: c.verbose, duration: c.duration, onComplete() { e(); }, queue: !0,
          })) : (f.debug('Hiding results with javascript'), o.stop().fadeOut(c.duration, c.easing)), c.onResultsClose.call(o));
        },
        generateResults(e) { f.debug('Generating html from response', e); const t = c.templates[c.type]; const n = E.isPlainObject(e[a.results]) && !E.isEmptyObject(e[a.results]); const i = E.isArray(e[a.results]) && e[a.results].length > 0; let o = ''; return n || i ? (c.maxResults > 0 && (n ? c.type == 'standard' && f.error(p.maxResults) : e[a.results] = e[a.results].slice(0, c.maxResults)), E.isFunction(t) ? o = t(e, a) : f.error(p.noTemplate, !1)) : c.showNoResults && (o = f.displayMessage(p.noResults, 'empty')), c.onResults.call(b, e), o; },
        displayMessage(e, t) { return t = t || 'standard', f.debug('Displaying message', e, t), f.addResults(c.templates.message(e, t)), c.templates.message(e, t); },
        setting(e, t) { if (E.isPlainObject(e))E.extend(!0, c, e); else { if (t === D) return c[e]; c[e] = t; } },
        internal(e, t) { if (E.isPlainObject(e))E.extend(!0, f, e); else { if (t === D) return f[e]; f[e] = t; } },
        debug() { !c.silent && c.debug && (c.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${c.name}:`), f.debug.apply(console, arguments))); },
        verbose() { !c.silent && c.verbose && c.debug && (c.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${c.name}:`), f.verbose.apply(console, arguments))); },
        error() { c.silent || (f.error = Function.prototype.bind.call(console.error, console, `${c.name}:`), f.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; c.performance && (n = (t = (new Date()).getTime()) - (k || t), k = t, T.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: b, 'Execution Time': n,
            })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
          },
          display() { let e = `${c.name}:`; let n = 0; k = !1, clearTimeout(f.performance.timer), E.each(T, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, S && (e += ` '${S}'`), w.length > 1 && (e += ` (${w.length})`), (console.group !== D || console.table !== D) && T.length > 0 && (console.groupCollapsed(e), console.table ? console.table(T) : E.each(T, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), T = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = s; return e = e || P, t = b || t, typeof i === 'string' && r !== D && (i = i.split(/[\. ]/), o = i.length - 1, E.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (E.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== D) return a = r[n], !1; if (!E.isPlainObject(r[t]) || e == o) return r[t] !== D && (a = r[t]), !1; r = r[t]; } })), E.isFunction(a) ? n = a.apply(t, e) : a !== D && (n = a), E.isArray(C) ? C.push(n) : C !== D ? C = [C, n] : n !== D && (C = n), a; },
      }, R ? (s === D && f.initialize(), f.invoke(A)) : (s !== D && s.invoke('destroy'), f.initialize());
    }), C !== D ? C : this;
  }, E.fn.search.settings = {
    name: 'Search',
    namespace: 'search',
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    type: 'standard',
    minCharacters: 1,
    selectFirstResult: !1,
    apiSettings: !1,
    source: !1,
    searchOnFocus: !0,
    searchFields: ['title', 'description'],
    displayField: '',
    fullTextSearch: 'exact',
    automatic: !0,
    hideDelay: 0,
    searchDelay: 200,
    maxResults: 7,
    cache: !0,
    showNoResults: !0,
    transition: 'scale',
    duration: 200,
    easing: 'easeOutExpo',
    onSelect: !1,
    onResultsAdd: !1,
    onSearchQuery(e) {},
    onResults(e) {},
    onResultsOpen() {},
    onResultsClose() {},
    className: {
      animating: 'animating', active: 'active', empty: 'empty', focus: 'focus', hidden: 'hidden', loading: 'loading', results: 'results', pressed: 'down',
    },
    error: {
      source: 'Cannot search. No source used, and Semantic API module was not included', noResults: 'Your search returned no results', logging: 'Error in debug logging, exiting.', noEndpoint: 'No search endpoint was specified', noTemplate: 'A valid template name was not specified.', oldSearchSyntax: 'searchFullText setting has been renamed fullTextSearch for consistency, please adjust your settings.', serverError: 'There was an issue querying the server.', maxResults: 'Results must be an array to use maxResults setting', method: 'The method you called is not defined.',
    },
    metadata: { cache: 'cache', results: 'results', result: 'result' },
    regExp: { escape: /[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, beginsWith: '(?:s|^)' },
    fields: {
      categories: 'results', categoryName: 'name', categoryResults: 'results', description: 'description', image: 'image', price: 'price', results: 'results', title: 'title', url: 'url', action: 'action', actionText: 'text', actionURL: 'url',
    },
    selector: {
      prompt: '.prompt', searchButton: '.search.button', results: '.results', message: '.results > .message', category: '.category', result: '.result', title: '.title, .name',
    },
    templates: {
      escape(e) {
        const t = {
          '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#x27;', '`': '&#x60;',
        }; return /[&<>"'`]/.test(e) ? e.replace(/[&<>"'`]/g, (e) => t[e]) : e;
      },
      message(e, t) { let n = ''; return e !== D && t !== D && (n += `<div class="message ${t}">`, n += t == 'empty' ? `<div class="header">No Results</div class="header"><div class="description">${e}</div class="description">` : ` <div class="description">${e}</div>`, n += '</div>'), n; },
      category(e, n) { let i = ''; E.fn.search.settings.templates.escape; return e[n.categoryResults] !== D && (E.each(e[n.categoryResults], (e, t) => { t[n.results] !== D && t.results.length > 0 && (i += '<div class="category">', t[n.categoryName] !== D && (i += `<div class="name">${t[n.categoryName]}</div>`), i += '<div class="results">', E.each(t.results, (e, t) => { t[n.url] ? i += `<a class="result" href="${t[n.url]}">` : i += '<a class="result">', t[n.image] !== D && (i += `<div class="image"> <img src="${t[n.image]}"></div>`), i += '<div class="content">', t[n.price] !== D && (i += `<div class="price">${t[n.price]}</div>`), t[n.title] !== D && (i += `<div class="title">${t[n.title]}</div>`), t[n.description] !== D && (i += `<div class="description">${t[n.description]}</div>`), i += '</div>', i += '</a>'; }), i += '</div>', i += '</div>'); }), e[n.action] && (i += `<a href="${e[n.action][n.actionURL]}" class="action">${e[n.action][n.actionText]}</a>`), i); },
      standard(e, n) { let i = ''; return e[n.results] !== D && (E.each(e[n.results], (e, t) => { t[n.url] ? i += `<a class="result" href="${t[n.url]}">` : i += '<a class="result">', t[n.image] !== D && (i += `<div class="image"> <img src="${t[n.image]}"></div>`), i += '<div class="content">', t[n.price] !== D && (i += `<div class="price">${t[n.price]}</div>`), t[n.title] !== D && (i += `<div class="title">${t[n.title]}</div>`), t[n.description] !== D && (i += `<div class="description">${t[n.description]}</div>`), i += '</div>', i += '</a>'; }), e[n.action] && (i += `<a href="${e[n.action][n.actionURL]}" class="action">${e[n.action][n.actionText]}</a>`), i); },
    },
  };
}(jQuery, window, document)), (function (A, e, R, P) {
  e = void 0 !== e && e.Math == Math ? e : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), A.fn.shape = function (v) {
    let b; const y = A(this); let x = (A('body'), (new Date()).getTime()); let C = []; const w = v; const S = typeof w === 'string'; const k = [].slice.call(arguments, 1); const T = e.requestAnimationFrame || e.mozRequestAnimationFrame || e.webkitRequestAnimationFrame || e.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return y.each(function () {
      let i; let o; let a; const t = y.selector || ''; const r = A.isPlainObject(v) ? A.extend(!0, {}, A.fn.shape.settings, v) : A.extend({}, A.fn.shape.settings); const e = r.namespace; const s = r.selector; const n = r.error; const l = r.className; const c = `.${e}`; const u = `module-${e}`; let d = A(this); let f = d.find(s.sides); let m = d.find(s.side); let g = !1; const p = this; let h = d.data(u); a = {
        initialize() { a.verbose('Initializing module for', p), a.set.defaultSide(), a.instantiate(); },
        instantiate() { a.verbose('Storing instance of module', a), h = a, d.data(u, h); },
        destroy() { a.verbose('Destroying previous module for', p), d.removeData(u).off(c); },
        refresh() { a.verbose('Refreshing selector cache for', p), d = A(p), f = A(this).find(s.shape), m = A(this).find(s.side); },
        repaint() { a.verbose('Forcing repaint event'); (f[0] || R.createElement('div')).offsetWidth; },
        animate(e, t) { a.verbose('Animating box with properties', e), t = t || function (e) { a.verbose('Executing animation callback'), e !== P && e.stopPropagation(), a.reset(), a.set.active(); }, r.beforeChange.call(o[0]), a.get.transitionEvent() ? (a.verbose('Starting CSS animation'), d.addClass(l.animating), f.css(e).one(a.get.transitionEvent(), t), a.set.duration(r.duration), T(() => { d.addClass(l.animating), i.addClass(l.hidden); })) : t(); },
        queue(e) { a.debug('Queueing animation of', e), f.one(a.get.transitionEvent(), () => { a.debug('Executing queued animation'), setTimeout(() => { d.shape(e); }, 0); }); },
        reset() { a.verbose('Animating states reset'), d.removeClass(l.animating).attr('style', '').removeAttr('style'), f.attr('style', '').removeAttr('style'), m.attr('style', '').removeAttr('style').removeClass(l.hidden), o.removeClass(l.animating).attr('style', '').removeAttr('style'); },
        is: { complete() { return m.filter(`.${l.active}`)[0] == o[0]; }, animating() { return d.hasClass(l.animating); } },
        set: {
          defaultSide() { i = d.find(`.${r.className.active}`), o = i.next(s.side).length > 0 ? i.next(s.side) : d.find(s.side).first(), g = !1, a.verbose('Active side set to', i), a.verbose('Next side set to', o); },
          duration(e) {
            e = typeof (e = e || r.duration) === 'number' ? `${e}ms` : e, a.verbose('Setting animation duration', e), (r.duration || r.duration === 0) && f.add(m).css({
              '-webkit-transition-duration': e, '-moz-transition-duration': e, '-ms-transition-duration': e, '-o-transition-duration': e, 'transition-duration': e,
            });
          },
          currentStageSize() { const e = d.find(`.${r.className.active}`); const t = e.outerWidth(!0); const n = e.outerHeight(!0); d.css({ width: t, height: n }); },
          stageSize() { const e = d.clone().addClass(l.loading); const t = e.find(`.${r.className.active}`); const n = g ? e.find(s.side).eq(g) : t.next(s.side).length > 0 ? t.next(s.side) : e.find(s.side).first(); const i = r.width == 'next' ? n.outerWidth(!0) : r.width == 'initial' ? d.width() : r.width; const o = r.height == 'next' ? n.outerHeight(!0) : r.height == 'initial' ? d.height() : r.height; t.removeClass(l.active), n.addClass(l.active), e.insertAfter(d), e.remove(), r.width != 'auto' && (d.css('width', i + r.jitter), a.verbose('Specifying width during animation', i)), r.height != 'auto' && (d.css('height', o + r.jitter), a.verbose('Specifying height during animation', o)); },
          nextSide(e) { g = e, o = m.filter(e), g = m.index(o), o.length === 0 && (a.set.defaultSide(), a.error(n.side)), a.verbose('Next side manually set to', o); },
          active() { a.verbose('Setting new side to active', o), m.removeClass(l.active), o.addClass(l.active), r.onChange.call(o[0]), a.set.defaultSide(); },
        },
        flip: {
          up() { if (!a.is.complete() || a.is.animating() || r.allowRepeats) if (a.is.animating())a.queue('flip up'); else { a.debug('Flipping up', o); const e = a.get.transform.up(); a.set.stageSize(), a.stage.above(), a.animate(e); } else a.debug('Side already visible', o); }, down() { if (!a.is.complete() || a.is.animating() || r.allowRepeats) if (a.is.animating())a.queue('flip down'); else { a.debug('Flipping down', o); const e = a.get.transform.down(); a.set.stageSize(), a.stage.below(), a.animate(e); } else a.debug('Side already visible', o); }, left() { if (!a.is.complete() || a.is.animating() || r.allowRepeats) if (a.is.animating())a.queue('flip left'); else { a.debug('Flipping left', o); const e = a.get.transform.left(); a.set.stageSize(), a.stage.left(), a.animate(e); } else a.debug('Side already visible', o); }, right() { if (!a.is.complete() || a.is.animating() || r.allowRepeats) if (a.is.animating())a.queue('flip right'); else { a.debug('Flipping right', o); const e = a.get.transform.right(); a.set.stageSize(), a.stage.right(), a.animate(e); } else a.debug('Side already visible', o); }, over() { !a.is.complete() || a.is.animating() || r.allowRepeats ? a.is.animating() ? a.queue('flip over') : (a.debug('Flipping over', o), a.set.stageSize(), a.stage.behind(), a.animate(a.get.transform.over())) : a.debug('Side already visible', o); }, back() { !a.is.complete() || a.is.animating() || r.allowRepeats ? a.is.animating() ? a.queue('flip back') : (a.debug('Flipping back', o), a.set.stageSize(), a.stage.behind(), a.animate(a.get.transform.back())) : a.debug('Side already visible', o); },
        },
        get: {
          transform: {
            up() { return { transform: `translateY(${-(i.outerHeight(!0) - o.outerHeight(!0)) / 2}px) translateZ(${-i.outerHeight(!0) / 2}px) rotateX(-90deg)` }; }, down() { return { transform: `translateY(${-(i.outerHeight(!0) - o.outerHeight(!0)) / 2}px) translateZ(${-i.outerHeight(!0) / 2}px) rotateX(90deg)` }; }, left() { return { transform: `translateX(${-(i.outerWidth(!0) - o.outerWidth(!0)) / 2}px) translateZ(${-i.outerWidth(!0) / 2}px) rotateY(90deg)` }; }, right() { return { transform: `translateX(${-(i.outerWidth(!0) - o.outerWidth(!0)) / 2}px) translateZ(${-i.outerWidth(!0) / 2}px) rotateY(-90deg)` }; }, over() { return { transform: `translateX(${-(i.outerWidth(!0) - o.outerWidth(!0)) / 2}px) rotateY(180deg)` }; }, back() { return { transform: `translateX(${-(i.outerWidth(!0) - o.outerWidth(!0)) / 2}px) rotateY(-180deg)` }; },
          },
          transitionEvent() {
            let e; const t = R.createElement('element'); const n = {
              transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd',
            }; for (e in n) if (t.style[e] !== P) return n[e];
          },
          nextSide() { return i.next(s.side).length > 0 ? i.next(s.side) : d.find(s.side).first(); },
        },
        stage: {
          above() { const e = { origin: (i.outerHeight(!0) - o.outerHeight(!0)) / 2, depth: { active: o.outerHeight(!0) / 2, next: i.outerHeight(!0) / 2 } }; a.verbose('Setting the initial animation position as above', o, e), f.css({ transform: `translateZ(-${e.depth.active}px)` }), i.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), o.addClass(l.animating).css({ top: `${e.origin}px`, transform: `rotateX(90deg) translateZ(${e.depth.next}px)` }); }, below() { const e = { origin: (i.outerHeight(!0) - o.outerHeight(!0)) / 2, depth: { active: o.outerHeight(!0) / 2, next: i.outerHeight(!0) / 2 } }; a.verbose('Setting the initial animation position as below', o, e), f.css({ transform: `translateZ(-${e.depth.active}px)` }), i.css({ transform: `rotateY(0deg) translateZ(${e.depth.active}px)` }), o.addClass(l.animating).css({ top: `${e.origin}px`, transform: `rotateX(-90deg) translateZ(${e.depth.next}px)` }); }, left() { const e = i.outerWidth(!0); const t = o.outerWidth(!0); const n = { origin: (e - t) / 2, depth: { active: t / 2, next: e / 2 } }; a.verbose('Setting the initial animation position as left', o, n), f.css({ transform: `translateZ(-${n.depth.active}px)` }), i.css({ transform: `rotateY(0deg) translateZ(${n.depth.active}px)` }), o.addClass(l.animating).css({ left: `${n.origin}px`, transform: `rotateY(-90deg) translateZ(${n.depth.next}px)` }); }, right() { const e = i.outerWidth(!0); const t = o.outerWidth(!0); const n = { origin: (e - t) / 2, depth: { active: t / 2, next: e / 2 } }; a.verbose('Setting the initial animation position as left', o, n), f.css({ transform: `translateZ(-${n.depth.active}px)` }), i.css({ transform: `rotateY(0deg) translateZ(${n.depth.active}px)` }), o.addClass(l.animating).css({ left: `${n.origin}px`, transform: `rotateY(90deg) translateZ(${n.depth.next}px)` }); }, behind() { const e = i.outerWidth(!0); const t = o.outerWidth(!0); const n = { origin: (e - t) / 2, depth: { active: t / 2, next: e / 2 } }; a.verbose('Setting the initial animation position as behind', o, n), i.css({ transform: 'rotateY(0deg)' }), o.addClass(l.animating).css({ left: `${n.origin}px`, transform: 'rotateY(-180deg)' }); },
        },
        setting(e, t) { if (a.debug('Changing setting', e, t), A.isPlainObject(e))A.extend(!0, r, e); else { if (t === P) return r[e]; A.isPlainObject(r[e]) ? A.extend(!0, r[e], t) : r[e] = t; } },
        internal(e, t) { if (A.isPlainObject(e))A.extend(!0, a, e); else { if (t === P) return a[e]; a[e] = t; } },
        debug() { !r.silent && r.debug && (r.performance ? a.performance.log(arguments) : (a.debug = Function.prototype.bind.call(console.info, console, `${r.name}:`), a.debug.apply(console, arguments))); },
        verbose() { !r.silent && r.verbose && r.debug && (r.performance ? a.performance.log(arguments) : (a.verbose = Function.prototype.bind.call(console.info, console, `${r.name}:`), a.verbose.apply(console, arguments))); },
        error() { r.silent || (a.error = Function.prototype.bind.call(console.error, console, `${r.name}:`), a.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; r.performance && (n = (t = (new Date()).getTime()) - (x || t), x = t, C.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: p, 'Execution Time': n,
            })), clearTimeout(a.performance.timer), a.performance.timer = setTimeout(a.performance.display, 500);
          },
          display() { let e = `${r.name}:`; let n = 0; x = !1, clearTimeout(a.performance.timer), A.each(C, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, t && (e += ` '${t}'`), y.length > 1 && (e += ` (${y.length})`), (console.group !== P || console.table !== P) && C.length > 0 && (console.groupCollapsed(e), console.table ? console.table(C) : A.each(C, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), C = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = h; return e = e || k, t = p || t, typeof i === 'string' && r !== P && (i = i.split(/[\. ]/), o = i.length - 1, A.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (A.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== P) return a = r[n], !1; if (!A.isPlainObject(r[t]) || e == o) return r[t] !== P && (a = r[t]), !1; r = r[t]; } })), A.isFunction(a) ? n = a.apply(t, e) : a !== P && (n = a), A.isArray(b) ? b.push(n) : b !== P ? b = [b, n] : n !== P && (b = n), a; },
      }, S ? (h === P && a.initialize(), a.invoke(w)) : (h !== P && h.invoke('destroy'), a.initialize());
    }), b !== P ? b : this;
  }, A.fn.shape.settings = {
    name: 'Shape',
    silent: !1,
    debug: !1,
    verbose: !1,
    jitter: 0,
    performance: !0,
    namespace: 'shape',
    width: 'initial',
    height: 'initial',
    beforeChange() {},
    onChange() {},
    allowRepeats: !1,
    duration: !1,
    error: { side: 'You tried to switch to a side that does not exist.', method: 'The method you called is not defined' },
    className: {
      animating: 'animating', hidden: 'hidden', loading: 'loading', active: 'active',
    },
    selector: { sides: '.sides', side: '.side' },
  };
}(jQuery, window, document)), (function (q, j, z, I) {
  j = void 0 !== j && j.Math == Math ? j : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), q.fn.sidebar = function (x) {
    let C; const e = q(this); const w = q(j); const S = q(z); const k = q('html'); const T = q('head'); const A = e.selector || ''; let R = (new Date()).getTime(); let P = []; const E = x; const F = typeof E === 'string'; const O = [].slice.call(arguments, 1); const D = j.requestAnimationFrame || j.mozRequestAnimationFrame || j.webkitRequestAnimationFrame || j.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; return e.each(function () {
      let r; let s; let e; let t; let l; let c; const u = q.isPlainObject(x) ? q.extend(!0, {}, q.fn.sidebar.settings, x) : q.extend({}, q.fn.sidebar.settings); const n = u.selector; const a = u.className; const i = u.namespace; const o = u.regExp; const d = u.error; const f = `.${i}`; const m = `module-${i}`; const g = q(this); let p = q(u.context); let h = g.children(n.sidebar); let v = (p.children(n.fixed), p.children(n.pusher)); const b = this; let y = g.data(m); c = {
        initialize() { c.debug('Initializing sidebar', x), c.create.id(), l = c.get.transitionEvent(), u.delaySetup ? D(c.setup.layout) : c.setup.layout(), D(() => { c.setup.cache(); }), c.instantiate(); },
        instantiate() { c.verbose('Storing instance of module', c), y = c, g.data(m, c); },
        create: { id() { e = (`${Math.random().toString(16)}000000000`).substr(2, 8), s = `.${e}`, c.verbose('Creating unique id for element', e); } },
        destroy() { c.verbose('Destroying previous module for', g), g.off(f).removeData(m), c.is.ios() && c.remove.ios(), p.off(s), w.off(s), S.off(s); },
        event: {
          clickaway(e) { const t = v.find(e.target).length > 0 || v.is(e.target); const n = p.is(e.target); t && (c.verbose('User clicked on dimmed page'), c.hide()), n && (c.verbose('User clicked on dimmable context (scaled out page)'), c.hide()); }, touch(e) {}, containScroll(e) { b.scrollTop <= 0 && (b.scrollTop = 1), b.scrollTop + b.offsetHeight >= b.scrollHeight && (b.scrollTop = b.scrollHeight - b.offsetHeight - 1); }, scroll(e) { q(e.target).closest(n.sidebar).length === 0 && e.preventDefault(); },
        },
        bind: { clickaway() { c.verbose('Adding clickaway events to context', p), u.closable && p.on(`click${s}`, c.event.clickaway).on(`touchend${s}`, c.event.clickaway); }, scrollLock() { u.scrollLock && (c.debug('Disabling page scroll'), w.on(`DOMMouseScroll${s}`, c.event.scroll)), c.verbose('Adding events to contain sidebar scroll'), S.on(`touchmove${s}`, c.event.touch), g.on(`scroll${f}`, c.event.containScroll); } },
        unbind: { clickaway() { c.verbose('Removing clickaway events from context', p), p.off(s); }, scrollLock() { c.verbose('Removing scroll lock from page'), S.off(s), w.off(s), g.off(`scroll${f}`); } },
        add: {
          inlineCSS() {
            let e; const t = c.cache.width || g.outerWidth(); const n = c.cache.height || g.outerHeight(); const i = c.is.rtl(); const o = c.get.direction(); const a = {
              left: t, right: -t, top: n, bottom: -n,
            }; i && (c.verbose('RTL detected, flipping widths'), a.left = -t, a.right = t), e = '<style>', o === 'left' || o === 'right' ? (c.debug('Adding CSS rules for animation distance', t), e += ` .ui.visible.${o}.sidebar ~ .fixed, .ui.visible.${o}.sidebar ~ .pusher {   -webkit-transform: translate3d(${a[o]}px, 0, 0);           transform: translate3d(${a[o]}px, 0, 0); }`) : o !== 'top' && o != 'bottom' || (e += ` .ui.visible.${o}.sidebar ~ .fixed, .ui.visible.${o}.sidebar ~ .pusher {   -webkit-transform: translate3d(0, ${a[o]}px, 0);           transform: translate3d(0, ${a[o]}px, 0); }`), c.is.ie() && (o === 'left' || o === 'right' ? (c.debug('Adding CSS rules for animation distance', t), e += ` body.pushable > .ui.visible.${o}.sidebar ~ .pusher:after {   -webkit-transform: translate3d(${a[o]}px, 0, 0);           transform: translate3d(${a[o]}px, 0, 0); }`) : o !== 'top' && o != 'bottom' || (e += ` body.pushable > .ui.visible.${o}.sidebar ~ .pusher:after {   -webkit-transform: translate3d(0, ${a[o]}px, 0);           transform: translate3d(0, ${a[o]}px, 0); }`), e += ' body.pushable > .ui.visible.left.sidebar ~ .ui.visible.right.sidebar ~ .pusher:after, body.pushable > .ui.visible.right.sidebar ~ .ui.visible.left.sidebar ~ .pusher:after {   -webkit-transform: translate3d(0px, 0, 0);           transform: translate3d(0px, 0, 0); }'), r = q(e += '</style>').appendTo(T), c.debug('Adding sizing css to head', r);
          },
        },
        refresh() { c.verbose('Refreshing selector cache'), p = q(u.context), h = p.children(n.sidebar), v = p.children(n.pusher), p.children(n.fixed), c.clear.cache(); },
        refreshSidebars() { c.verbose('Refreshing other sidebars'), h = p.children(n.sidebar); },
        repaint() { c.verbose('Forcing repaint event'), b.style.display = 'none'; b.offsetHeight; b.scrollTop = b.scrollTop, b.style.display = ''; },
        setup: { cache() { c.cache = { width: g.outerWidth(), height: g.outerHeight(), rtl: g.css('direction') == 'rtl' }; }, layout() { p.children(n.pusher).length === 0 && (c.debug('Adding wrapper element for sidebar'), c.error(d.pusher), v = q('<div class="pusher" />'), p.children().not(n.omitted).not(h).wrapAll(v), c.refresh()), g.nextAll(n.pusher).length !== 0 && g.nextAll(n.pusher)[0] === v[0] || (c.debug('Moved sidebar to correct parent element'), c.error(d.movedSidebar, b), g.detach().prependTo(p), c.refresh()), c.clear.cache(), c.set.pushable(), c.set.direction(); } },
        attachEvents(e, t) { const n = q(e); t = q.isFunction(c[t]) ? c[t] : c.toggle, n.length > 0 ? (c.debug('Attaching sidebar events to element', e, t), n.on(`click${f}`, t)) : c.error(d.notFound, e); },
        show(e) { if (e = q.isFunction(e) ? e : function () {}, c.is.hidden()) { if (c.refreshSidebars(), u.overlay && (c.error(d.overlay), u.transition = 'overlay'), c.refresh(), c.othersActive()) if (c.debug('Other sidebars currently visible'), u.exclusive) { if (u.transition != 'overlay') return void c.hideOthers(c.show); c.hideOthers(); } else u.transition = 'overlay'; c.pushPage(() => { e.call(b), u.onShow.call(b); }), u.onChange.call(b), u.onVisible.call(b); } else c.debug('Sidebar is already visible'); },
        hide(e) { e = q.isFunction(e) ? e : function () {}, (c.is.visible() || c.is.animating()) && (c.debug('Hiding sidebar', e), c.refreshSidebars(), c.pullPage(() => { e.call(b), u.onHidden.call(b); }), u.onChange.call(b), u.onHide.call(b)); },
        othersAnimating() { return h.not(g).filter(`.${a.animating}`).length > 0; },
        othersVisible() { return h.not(g).filter(`.${a.visible}`).length > 0; },
        othersActive() { return c.othersVisible() || c.othersAnimating(); },
        hideOthers(e) { const t = h.not(g).filter(`.${a.visible}`); const n = t.length; let i = 0; e = e || function () {}, t.sidebar('hide', () => { ++i == n && e(); }); },
        toggle() { c.verbose('Determining toggled direction'), c.is.hidden() ? c.show() : c.hide(); },
        pushPage(t) { let e; let n; let i; const o = c.get.transition(); const a = o === 'overlay' || c.othersActive() ? g : v; t = q.isFunction(t) ? t : function () {}, u.transition == 'scale down' && c.scrollToTop(), c.set.transition(o), c.repaint(), e = function () { c.bind.clickaway(), c.add.inlineCSS(), c.set.animating(), c.set.visible(); }, n = function () { c.set.dimmed(); }, i = function (e) { e.target == a[0] && (a.off(l + s, i), c.remove.animating(), c.bind.scrollLock(), t.call(b)); }, a.off(l + s), a.on(l + s, i), D(e), u.dimPage && !c.othersVisible() && D(n); },
        pullPage(t) { let e; let n; const i = c.get.transition(); const o = i == 'overlay' || c.othersActive() ? g : v; t = q.isFunction(t) ? t : function () {}, c.verbose('Removing context push state', c.get.direction()), c.unbind.clickaway(), c.unbind.scrollLock(), e = function () { c.set.transition(i), c.set.animating(), c.remove.visible(), u.dimPage && !c.othersVisible() && v.removeClass(a.dimmed); }, n = function (e) { e.target == o[0] && (o.off(l + s, n), c.remove.animating(), c.remove.transition(), c.remove.inlineCSS(), (i == 'scale down' || u.returnScroll && c.is.mobile()) && c.scrollBack(), t.call(b)); }, o.off(l + s), o.on(l + s, n), D(e); },
        scrollToTop() { c.verbose('Scrolling to top of page to avoid animation issues'), t = q(j).scrollTop(), g.scrollTop(0), j.scrollTo(0, 0); },
        scrollBack() { c.verbose('Scrolling back to original page position'), j.scrollTo(0, t); },
        clear: { cache() { c.verbose('Clearing cached dimensions'), c.cache = {}; } },
        set: {
          ios() { k.addClass(a.ios); }, pushed() { p.addClass(a.pushed); }, pushable() { p.addClass(a.pushable); }, dimmed() { v.addClass(a.dimmed); }, active() { g.addClass(a.active); }, animating() { g.addClass(a.animating); }, transition(e) { e = e || c.get.transition(), g.addClass(e); }, direction(e) { e = e || c.get.direction(), g.addClass(a[e]); }, visible() { g.addClass(a.visible); }, overlay() { g.addClass(a.overlay); },
        },
        remove: {
          inlineCSS() { c.debug('Removing inline css styles', r), r && r.length > 0 && r.remove(); }, ios() { k.removeClass(a.ios); }, pushed() { p.removeClass(a.pushed); }, pushable() { p.removeClass(a.pushable); }, active() { g.removeClass(a.active); }, animating() { g.removeClass(a.animating); }, transition(e) { e = e || c.get.transition(), g.removeClass(e); }, direction(e) { e = e || c.get.direction(), g.removeClass(a[e]); }, visible() { g.removeClass(a.visible); }, overlay() { g.removeClass(a.overlay); },
        },
        get: {
          direction() { return g.hasClass(a.top) ? a.top : g.hasClass(a.right) ? a.right : g.hasClass(a.bottom) ? a.bottom : a.left; },
          transition() { let e; const t = c.get.direction(); return e = c.is.mobile() ? u.mobileTransition == 'auto' ? u.defaultTransition.mobile[t] : u.mobileTransition : u.transition == 'auto' ? u.defaultTransition.computer[t] : u.transition, c.verbose('Determined transition', e), e; },
          transitionEvent() {
            let e; const t = z.createElement('element'); const n = {
              transition: 'transitionend', OTransition: 'oTransitionEnd', MozTransition: 'transitionend', WebkitTransition: 'webkitTransitionEnd',
            }; for (e in n) if (t.style[e] !== I) return n[e];
          },
        },
        is: {
          ie() { return !j.ActiveXObject && 'ActiveXObject' in j || 'ActiveXObject' in j; }, ios() { const e = navigator.userAgent; const t = e.match(o.ios); const n = e.match(o.mobileChrome); return !(!t || n) && (c.verbose('Browser was found to be iOS', e), !0); }, mobile() { const e = navigator.userAgent; return e.match(o.mobile) ? (c.verbose('Browser was found to be mobile', e), !0) : (c.verbose('Browser is not mobile, using regular transition', e), !1); }, hidden() { return !c.is.visible(); }, visible() { return g.hasClass(a.visible); }, open() { return c.is.visible(); }, closed() { return c.is.hidden(); }, vertical() { return g.hasClass(a.top); }, animating() { return p.hasClass(a.animating); }, rtl() { return c.cache.rtl === I && (c.cache.rtl = g.css('direction') == 'rtl'), c.cache.rtl; },
        },
        setting(e, t) { if (c.debug('Changing setting', e, t), q.isPlainObject(e))q.extend(!0, u, e); else { if (t === I) return u[e]; q.isPlainObject(u[e]) ? q.extend(!0, u[e], t) : u[e] = t; } },
        internal(e, t) { if (q.isPlainObject(e))q.extend(!0, c, e); else { if (t === I) return c[e]; c[e] = t; } },
        debug() { !u.silent && u.debug && (u.performance ? c.performance.log(arguments) : (c.debug = Function.prototype.bind.call(console.info, console, `${u.name}:`), c.debug.apply(console, arguments))); },
        verbose() { !u.silent && u.verbose && u.debug && (u.performance ? c.performance.log(arguments) : (c.verbose = Function.prototype.bind.call(console.info, console, `${u.name}:`), c.verbose.apply(console, arguments))); },
        error() { u.silent || (c.error = Function.prototype.bind.call(console.error, console, `${u.name}:`), c.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; u.performance && (n = (t = (new Date()).getTime()) - (R || t), R = t, P.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: b, 'Execution Time': n,
            })), clearTimeout(c.performance.timer), c.performance.timer = setTimeout(c.performance.display, 500);
          },
          display() { let e = `${u.name}:`; let n = 0; R = !1, clearTimeout(c.performance.timer), q.each(P, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, A && (e += ` '${A}'`), (console.group !== I || console.table !== I) && P.length > 0 && (console.groupCollapsed(e), console.table ? console.table(P) : q.each(P, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), P = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = y; return e = e || O, t = b || t, typeof i === 'string' && r !== I && (i = i.split(/[\. ]/), o = i.length - 1, q.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (q.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== I) return a = r[n], !1; if (!q.isPlainObject(r[t]) || e == o) return r[t] !== I ? a = r[t] : c.error(d.method, i), !1; r = r[t]; } })), q.isFunction(a) ? n = a.apply(t, e) : a !== I && (n = a), q.isArray(C) ? C.push(n) : C !== I ? C = [C, n] : n !== I && (C = n), a; },
      }, F ? (y === I && c.initialize(), c.invoke(E)) : (y !== I && c.invoke('destroy'), c.initialize());
    }), C !== I ? C : this;
  }, q.fn.sidebar.settings = {
    name: 'Sidebar',
    namespace: 'sidebar',
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    transition: 'auto',
    mobileTransition: 'auto',
    defaultTransition: {
      computer: {
        left: 'uncover', right: 'uncover', top: 'overlay', bottom: 'overlay',
      },
      mobile: {
        left: 'uncover', right: 'uncover', top: 'overlay', bottom: 'overlay',
      },
    },
    context: 'body',
    exclusive: !1,
    closable: !0,
    dimPage: !0,
    scrollLock: !1,
    returnScroll: !1,
    delaySetup: !1,
    duration: 500,
    onChange() {},
    onShow() {},
    onHide() {},
    onHidden() {},
    onVisible() {},
    className: {
      active: 'active', animating: 'animating', dimmed: 'dimmed', ios: 'ios', pushable: 'pushable', pushed: 'pushed', right: 'right', top: 'top', left: 'left', bottom: 'bottom', visible: 'visible',
    },
    selector: {
      fixed: '.fixed', omitted: 'script, link, style, .ui.modal, .ui.dimmer, .ui.nag, .ui.fixed', pusher: '.pusher', sidebar: '.ui.sidebar',
    },
    regExp: { ios: /(iPad|iPhone|iPod)/g, mobileChrome: /(CriOS)/g, mobile: /Mobile|iP(hone|od|ad)|Android|BlackBerry|IEMobile|Kindle|NetFront|Silk-Accelerated|(hpw|web)OS|Fennec|Minimo|Opera M(obi|ini)|Blazer|Dolfin|Dolphin|Skyfire|Zune/g },
    error: {
      method: 'The method you called is not defined.', pusher: 'Had to add pusher element. For optimal performance make sure body content is inside a pusher element', movedSidebar: 'Had to move sidebar. For optimal performance make sure sidebar and pusher are direct children of your body tag', overlay: 'The overlay setting is no longer supported, use animation: overlay', notFound: 'There were no elements that matched the specified selector',
    },
  };
}(jQuery, window, document)), (function (T, A, R, P) {
  A = void 0 !== A && A.Math == Math ? A : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), T.fn.sticky = function (v) {
    let b; const e = T(this); const y = e.selector || ''; let x = (new Date()).getTime(); let C = []; const w = v; const S = typeof w === 'string'; const k = [].slice.call(arguments, 1); return e.each(function () {
      let i; let o; let e; let t; let d; const f = T.isPlainObject(v) ? T.extend(!0, {}, T.fn.sticky.settings, v) : T.extend({}, T.fn.sticky.settings); const n = f.className; const a = f.namespace; const r = f.error; const s = `.${a}`; const l = `module-${a}`; const c = T(this); const u = T(A); const m = T(f.scrollContext); let g = (c.selector, c.data(l)); const p = A.requestAnimationFrame || A.mozRequestAnimationFrame || A.webkitRequestAnimationFrame || A.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; const h = this; d = {
        initialize() { d.determineContainer(), d.determineContext(), d.verbose('Initializing sticky', f, i), d.save.positions(), d.checkErrors(), d.bind.events(), f.observeChanges && d.observeChanges(), d.instantiate(); },
        instantiate() { d.verbose('Storing instance of module', d), g = d, c.data(l, d); },
        destroy() { d.verbose('Destroying previous instance'), d.reset(), e && e.disconnect(), t && t.disconnect(), u.off(`load${s}`, d.event.load).off(`resize${s}`, d.event.resize), m.off(`scrollchange${s}`, d.event.scrollchange), c.removeData(l); },
        observeChanges() { 'MutationObserver' in A && (e = new MutationObserver(d.event.documentChanged), t = new MutationObserver(d.event.changed), e.observe(R, { childList: !0, subtree: !0 }), t.observe(h, { childList: !0, subtree: !0 }), t.observe(o[0], { childList: !0, subtree: !0 }), d.debug('Setting up mutation observer', t)); },
        determineContainer() { i = f.container ? T(f.container) : c.offsetParent(); },
        determineContext() { (o = f.context ? T(f.context) : i).length !== 0 || d.error(r.invalidContext, f.context, c); },
        checkErrors() { if (d.is.hidden() && d.error(r.visible, c), d.cache.element.height > d.cache.context.height) return d.reset(), void d.error(r.elementSize, c); },
        bind: { events() { u.on(`load${s}`, d.event.load).on(`resize${s}`, d.event.resize), m.off(`scroll${s}`).on(`scroll${s}`, d.event.scroll).on(`scrollchange${s}`, d.event.scrollchange); } },
        event: {
          changed(e) { clearTimeout(d.timer), d.timer = setTimeout(() => { d.verbose('DOM tree modified, updating sticky menu', e), d.refresh(); }, 100); }, documentChanged(e) { [].forEach.call(e, (e) => { e.removedNodes && [].forEach.call(e.removedNodes, (e) => { (e == h || T(e).find(h).length > 0) && (d.debug('Element removed from DOM, tearing down events'), d.destroy()); }); }); }, load() { d.verbose('Page contents finished loading'), p(d.refresh); }, resize() { d.verbose('Window resized'), p(d.refresh); }, scroll() { p(() => { m.triggerHandler(`scrollchange${s}`, m.scrollTop()); }); }, scrollchange(e, t) { d.stick(t), f.onScroll.call(h); },
        },
        refresh(e) { d.reset(), f.context || d.determineContext(), e && d.determineContainer(), d.save.positions(), d.stick(), f.onReposition.call(h); },
        supports: { sticky() { const e = T('<div/>'); e[0]; return e.addClass(n.supported), e.css('position').match('sticky'); } },
        save: {
          lastScroll(e) { d.lastScroll = e; },
          elementScroll(e) { d.elementScroll = e; },
          positions() {
            const e = { height: m.height() }; const t = {
              margin: { top: parseInt(c.css('margin-top'), 10), bottom: parseInt(c.css('margin-bottom'), 10) }, offset: c.offset(), width: c.outerWidth(), height: c.outerHeight(),
            }; const n = { offset: o.offset(), height: o.outerHeight() }; i.outerHeight(); d.is.standardScroll() || (d.debug('Non-standard scroll. Removing scroll offset from element offset'), e.top = m.scrollTop(), e.left = m.scrollLeft(), t.offset.top += e.top, n.offset.top += e.top, t.offset.left += e.left, n.offset.left += e.left), d.cache = {
              fits: t.height + f.offset <= e.height,
              sameHeight: t.height == n.height,
              scrollContext: { height: e.height },
              element: {
                margin: t.margin, top: t.offset.top - t.margin.top, left: t.offset.left, width: t.width, height: t.height, bottom: t.offset.top + t.height,
              },
              context: { top: n.offset.top, height: n.height, bottom: n.offset.top + n.height },
            }, d.set.containerSize(), d.stick(), d.debug('Caching element positions', d.cache);
          },
        },
        get: {
          direction(e) { let t = 'down'; return e = e || m.scrollTop(), d.lastScroll !== P && (d.lastScroll < e ? t = 'down' : d.lastScroll > e && (t = 'up')), t; }, scrollChange(e) { return e = e || m.scrollTop(), d.lastScroll ? e - d.lastScroll : 0; }, currentElementScroll() { return d.elementScroll ? d.elementScroll : d.is.top() ? Math.abs(parseInt(c.css('top'), 10)) || 0 : Math.abs(parseInt(c.css('bottom'), 10)) || 0; }, elementScroll(e) { e = e || m.scrollTop(); const t = d.cache.element; const n = d.cache.scrollContext; const i = d.get.scrollChange(e); const o = t.height - n.height + f.offset; let a = d.get.currentElementScroll(); const r = a + i; return a = d.cache.fits || r < 0 ? 0 : o < r ? o : r; },
        },
        remove: {
          lastScroll() { delete d.lastScroll; }, elementScroll(e) { delete d.elementScroll; }, minimumSize() { i.css('min-height', ''); }, offset() { c.css('margin-top', ''); },
        },
        set: {
          offset() { d.verbose('Setting offset on element', f.offset), c.css('margin-top', f.offset); }, containerSize() { const e = i.get(0).tagName; e === 'HTML' || e == 'body' ? d.determineContainer() : Math.abs(i.outerHeight() - d.cache.context.height) > f.jitter && (d.debug('Context has padding, specifying exact height for container', d.cache.context.height), i.css({ height: d.cache.context.height })); }, minimumSize() { const e = d.cache.element; i.css('min-height', e.height); }, scroll(e) { d.debug('Setting scroll on element', e), d.elementScroll != e && (d.is.top() && c.css('bottom', '').css('top', -e), d.is.bottom() && c.css('top', '').css('bottom', e)); }, size() { d.cache.element.height !== 0 && d.cache.element.width !== 0 && (h.style.setProperty('width', `${d.cache.element.width}px`, 'important'), h.style.setProperty('height', `${d.cache.element.height}px`, 'important')); },
        },
        is: {
          standardScroll() { return m[0] == A; }, top() { return c.hasClass(n.top); }, bottom() { return c.hasClass(n.bottom); }, initialPosition() { return !d.is.fixed() && !d.is.bound(); }, hidden() { return !c.is(':visible'); }, bound() { return c.hasClass(n.bound); }, fixed() { return c.hasClass(n.fixed); },
        },
        stick(e) { const t = e || m.scrollTop(); const n = d.cache; const i = n.fits; const o = n.sameHeight; const a = n.element; const r = n.scrollContext; const s = n.context; const l = d.is.bottom() && f.pushing ? f.bottomOffset : f.offset; const c = (e = { top: t + l, bottom: t + l + r.height }, d.get.direction(e.top), i ? 0 : d.get.elementScroll(e.top)); const u = !i; a.height !== 0 && !o && (d.is.initialPosition() ? e.top >= s.bottom ? (d.debug('Initial element position is bottom of container'), d.bindBottom()) : e.top > a.top && (a.height + e.top - c >= s.bottom ? (d.debug('Initial element position is bottom of container'), d.bindBottom()) : (d.debug('Initial element position is fixed'), d.fixTop())) : d.is.fixed() ? d.is.top() ? e.top <= a.top ? (d.debug('Fixed element reached top of container'), d.setInitialPosition()) : a.height + e.top - c >= s.bottom ? (d.debug('Fixed element reached bottom of container'), d.bindBottom()) : u && (d.set.scroll(c), d.save.lastScroll(e.top), d.save.elementScroll(c)) : d.is.bottom() && (e.bottom - a.height <= a.top ? (d.debug('Bottom fixed rail has reached top of container'), d.setInitialPosition()) : e.bottom >= s.bottom ? (d.debug('Bottom fixed rail has reached bottom of container'), d.bindBottom()) : u && (d.set.scroll(c), d.save.lastScroll(e.top), d.save.elementScroll(c))) : d.is.bottom() && (e.top <= a.top ? (d.debug('Jumped from bottom fixed to top fixed, most likely used home/end button'), d.setInitialPosition()) : f.pushing ? d.is.bound() && e.bottom <= s.bottom && (d.debug('Fixing bottom attached element to bottom of browser.'), d.fixBottom()) : d.is.bound() && e.top <= s.bottom - a.height && (d.debug('Fixing bottom attached element to top of browser.'), d.fixTop()))); },
        bindTop() {
          d.debug('Binding element to top of parent container'), d.remove.offset(), c.css({ left: '', top: '', marginBottom: '' }).removeClass(n.fixed).removeClass(n.bottom).addClass(n.bound)
            .addClass(n.top), f.onTop.call(h), f.onUnstick.call(h);
        },
        bindBottom() {
          d.debug('Binding element to bottom of parent container'), d.remove.offset(), c.css({ left: '', top: '' }).removeClass(n.fixed).removeClass(n.top).addClass(n.bound)
            .addClass(n.bottom), f.onBottom.call(h), f.onUnstick.call(h);
        },
        setInitialPosition() { d.debug('Returning to initial position'), d.unfix(), d.unbind(); },
        fixTop() {
          d.debug('Fixing element to top of page'), f.setSize && d.set.size(), d.set.minimumSize(), d.set.offset(), c.css({ left: d.cache.element.left, bottom: '', marginBottom: '' }).removeClass(n.bound).removeClass(n.bottom).addClass(n.fixed)
            .addClass(n.top), f.onStick.call(h);
        },
        fixBottom() {
          d.debug('Sticking element to bottom of page'), f.setSize && d.set.size(), d.set.minimumSize(), d.set.offset(), c.css({ left: d.cache.element.left, bottom: '', marginBottom: '' }).removeClass(n.bound).removeClass(n.top).addClass(n.fixed)
            .addClass(n.bottom), f.onStick.call(h);
        },
        unbind() { d.is.bound() && (d.debug('Removing container bound position on element'), d.remove.offset(), c.removeClass(n.bound).removeClass(n.top).removeClass(n.bottom)); },
        unfix() { d.is.fixed() && (d.debug('Removing fixed position on element'), d.remove.minimumSize(), d.remove.offset(), c.removeClass(n.fixed).removeClass(n.top).removeClass(n.bottom), f.onUnstick.call(h)); },
        reset() { d.debug('Resetting elements position'), d.unbind(), d.unfix(), d.resetCSS(), d.remove.offset(), d.remove.lastScroll(); },
        resetCSS() { c.css({ width: '', height: '' }), i.css({ height: '' }); },
        setting(e, t) { if (T.isPlainObject(e))T.extend(!0, f, e); else { if (t === P) return f[e]; f[e] = t; } },
        internal(e, t) { if (T.isPlainObject(e))T.extend(!0, d, e); else { if (t === P) return d[e]; d[e] = t; } },
        debug() { !f.silent && f.debug && (f.performance ? d.performance.log(arguments) : (d.debug = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.debug.apply(console, arguments))); },
        verbose() { !f.silent && f.verbose && f.debug && (f.performance ? d.performance.log(arguments) : (d.verbose = Function.prototype.bind.call(console.info, console, `${f.name}:`), d.verbose.apply(console, arguments))); },
        error() { f.silent || (d.error = Function.prototype.bind.call(console.error, console, `${f.name}:`), d.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; f.performance && (n = (t = (new Date()).getTime()) - (x || t), x = t, C.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: h, 'Execution Time': n,
            })), clearTimeout(d.performance.timer), d.performance.timer = setTimeout(d.performance.display, 0);
          },
          display() { let e = `${f.name}:`; let n = 0; x = !1, clearTimeout(d.performance.timer), T.each(C, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, y && (e += ` '${y}'`), (console.group !== P || console.table !== P) && C.length > 0 && (console.groupCollapsed(e), console.table ? console.table(C) : T.each(C, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), C = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = g; return e = e || k, t = h || t, typeof i === 'string' && r !== P && (i = i.split(/[\. ]/), o = i.length - 1, T.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (T.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== P) return a = r[n], !1; if (!T.isPlainObject(r[t]) || e == o) return r[t] !== P && (a = r[t]), !1; r = r[t]; } })), T.isFunction(a) ? n = a.apply(t, e) : a !== P && (n = a), T.isArray(b) ? b.push(n) : b !== P ? b = [b, n] : n !== P && (b = n), a; },
      }, S ? (g === P && d.initialize(), d.invoke(w)) : (g !== P && g.invoke('destroy'), d.initialize());
    }), b !== P ? b : this;
  }, T.fn.sticky.settings = {
    name: 'Sticky',
    namespace: 'sticky',
    silent: !1,
    debug: !1,
    verbose: !0,
    performance: !0,
    pushing: !1,
    context: !1,
    container: !1,
    scrollContext: A,
    offset: 0,
    bottomOffset: 0,
    jitter: 5,
    setSize: !0,
    observeChanges: !1,
    onReposition() {},
    onScroll() {},
    onStick() {},
    onUnstick() {},
    onTop() {},
    onBottom() {},
    error: {
      container: 'Sticky element must be inside a relative container', visible: 'Element is hidden, you must call refresh after element becomes visible. Use silent setting to surpress this warning in production.', method: 'The method you called is not defined.', invalidContext: 'Context specified does not exist', elementSize: 'Sticky element is larger than its container, cannot create sticky.',
    },
    className: {
      bound: 'bound', fixed: 'fixed', supported: 'native', top: 'top', bottom: 'bottom',
    },
  };
}(jQuery, window, document)), (function (E, F, O, D) {
  F = void 0 !== F && F.Math == Math ? F : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), E.fn.tab = function (r) {
    let c; const u = E.isFunction(this) ? E(F) : E(this); const d = u.selector || ''; let f = (new Date()).getTime(); let m = []; const g = r; const A = typeof g === 'string'; const R = [].slice.call(arguments, 1); let P = !1; return u.each(function () {
      let p; let a; let h; let v; let b; let y; let x = E.isPlainObject(r) ? E.extend(!0, {}, E.fn.tab.settings, r) : E.extend({}, E.fn.tab.settings); const C = x.className; const w = x.metadata; const t = x.selector; const S = x.error; const e = `.${x.namespace}`; const n = `module-${x.namespace}`; const k = E(this); const i = {}; let T = !0; let o = 0; const s = this; let l = k.data(n); b = {
        initialize() { b.debug('Initializing tab menu item', k), b.fix.callbacks(), b.determineTabs(), b.debug('Determining tabs', x.context, a), x.auto && b.set.auto(), b.bind.events(), x.history && !P && (b.initializeHistory(), P = !0), b.instantiate(); },
        instantiate() { b.verbose('Storing instance of module', b), l = b, k.data(n, b); },
        destroy() { b.debug('Destroying tabs', k), k.removeData(n).off(e); },
        bind: { events() { E.isWindow(s) || (b.debug('Attaching tab activation events to element', k), k.on(`click${e}`, b.event.click)); } },
        determineTabs() { let e; x.context === 'parent' ? (k.closest(t.ui).length > 0 ? (e = k.closest(t.ui), b.verbose('Using closest UI element as parent', e)) : e = k, p = e.parent(), b.verbose('Determined parent element for creating context', p)) : x.context ? (p = E(x.context), b.verbose('Using selector for tab context', x.context, p)) : p = E('body'), x.childrenOnly ? (a = p.children(t.tabs), b.debug('Searching tab context children for tabs', p, a)) : (a = p.find(t.tabs), b.debug('Searching tab context for tabs', p, a)); },
        fix: { callbacks() { E.isPlainObject(r) && (r.onTabLoad || r.onTabInit) && (r.onTabLoad && (r.onLoad = r.onTabLoad, delete r.onTabLoad, b.error(S.legacyLoad, r.onLoad)), r.onTabInit && (r.onFirstLoad = r.onTabInit, delete r.onTabInit, b.error(S.legacyInit, r.onFirstLoad)), x = E.extend(!0, {}, E.fn.tab.settings, r)); } },
        initializeHistory() { if (b.debug('Initializing page state'), E.address === D) return b.error(S.state), !1; if (x.historyType == 'state') { if (b.debug('Using HTML5 to manage state'), !1 === x.path) return b.error(S.path), !1; E.address.history(!0).state(x.path); }E.address.bind('change', b.event.history.change); },
        event: { click(e) { const t = E(this).data(w.tab); t !== D ? (x.history ? (b.verbose('Updating page state', e), E.address.value(t)) : (b.verbose('Changing tab', e), b.changeTab(t)), e.preventDefault()) : b.debug('No tab specified'); }, history: { change(e) { const t = e.pathNames.join('/') || b.get.initialPath(); const n = x.templates.determineTitle(t) || !1; b.performance.display(), b.debug('History change event', t, e), y = e, t !== D && b.changeTab(t), n && E.address.title(n); } } },
        refresh() { h && (b.debug('Refreshing tab', h), b.changeTab(h)); },
        cache: { read(e) { return e !== D && i[e]; }, add(e, t) { e = e || h, b.debug('Adding cached content for', e), i[e] = t; }, remove(e) { e = e || h, b.debug('Removing cached content for', e), delete i[e]; } },
        set: { auto() { const e = typeof x.path === 'string' ? `${x.path.replace(/\/$/, '')}/{$tab}` : '/{$tab}'; b.verbose('Setting up automatic tab retrieval from server', e), E.isPlainObject(x.apiSettings) ? x.apiSettings.url = e : x.apiSettings = { url: e }; }, loading(e) { const t = b.get.tabElement(e); t.hasClass(C.loading) || (b.verbose('Setting loading state for', t), t.addClass(C.loading).siblings(a).removeClass(`${C.active} ${C.loading}`), t.length > 0 && x.onRequest.call(t[0], e)); }, state(e) { E.address.value(e); } },
        changeTab(d) { const f = F.history && F.history.pushState && x.ignoreFirstLoad && T; const m = x.auto || E.isPlainObject(x.apiSettings); const g = m && !f ? b.utilities.pathToArray(d) : b.get.defaultPathArray(d); d = b.utilities.arrayToPath(g), E.each(g, (e, t) => { let n; let i; let o; let a; const r = g.slice(0, e + 1); let s = b.utilities.arrayToPath(r); const l = b.is.tab(s); const c = e + 1 == g.length; let u = b.get.tabElement(s); if (b.verbose('Looking for tab', t), l) { if (b.verbose('Tab was found', t), h = s, v = b.utilities.filterArray(g, r), c ? a = !0 : (i = g.slice(0, e + 2), o = b.utilities.arrayToPath(i), (a = !b.is.tab(o)) && b.verbose('Tab parameters found', i)), a && m) return f ? (b.debug('Ignoring remote content on first tab load', s), T = !1, b.cache.add(d, u.html()), b.activate.all(s), x.onFirstLoad.call(u[0], s, v, y), x.onLoad.call(u[0], s, v, y)) : (b.activate.navigation(s), b.fetch.content(s, d)), !1; b.debug('Opened local tab', s), b.activate.all(s), b.cache.read(s) || (b.cache.add(s, !0), b.debug('First time tab loaded calling tab init'), x.onFirstLoad.call(u[0], s, v, y)), x.onLoad.call(u[0], s, v, y); } else { if (d.search('/') != -1 || d === '') return b.error(S.missingTab, k, p, s), !1; if (s = (n = E(`#${d}, a[name="${d}"]`)).closest('[data-tab]').data(w.tab), u = b.get.tabElement(s), n && n.length > 0 && s) return b.debug('Anchor link used, opening parent tab', u, n), u.hasClass(C.active) || setTimeout(() => { b.scrollTo(n); }, 0), b.activate.all(s), b.cache.read(s) || (b.cache.add(s, !0), b.debug('First time tab loaded calling tab init'), x.onFirstLoad.call(u[0], s, v, y)), x.onLoad.call(u[0], s, v, y), !1; } }); },
        scrollTo(e) { const t = !!(e && e.length > 0) && e.offset().top; !1 !== t && (b.debug('Forcing scroll to an in-page link in a hidden tab', t, e), E(O).scrollTop(t)); },
        update: { content(e, t, n) { const i = b.get.tabElement(e); const o = i[0]; n = n !== D ? n : x.evaluateScripts, typeof x.cacheType === 'string' && x.cacheType.toLowerCase() == 'dom' && typeof t !== 'string' ? i.empty().append(E(t).clone(!0)) : n ? (b.debug('Updating HTML and evaluating inline scripts', e, t), i.html(t)) : (b.debug('Updating HTML', e, t), o.innerHTML = t); } },
        fetch: {
          content(t, n) {
            let e; let i; const o = b.get.tabElement(t); const a = {
              dataType: 'html', encodeParameters: !1, on: 'now', cache: x.alwaysRefresh, headers: { 'X-Remote': !0 }, onSuccess(e) { x.cacheType == 'response' && b.cache.add(n, e), b.update.content(t, e), t == h ? (b.debug('Content loaded', t), b.activate.tab(t)) : b.debug('Content loaded in background', t), x.onFirstLoad.call(o[0], t, v, y), x.onLoad.call(o[0], t, v, y), x.loadOnce ? b.cache.add(n, !0) : typeof x.cacheType === 'string' && x.cacheType.toLowerCase() == 'dom' && o.children().length > 0 ? setTimeout(() => { let e = o.children().clone(!0); e = e.not('script'), b.cache.add(n, e); }, 0) : b.cache.add(n, o.html()); }, urlData: { tab: n },
            }; const r = o.api('get request') || !1; const s = r && r.state() === 'pending'; n = n || t, i = b.cache.read(n), x.cache && i ? (b.activate.tab(t), b.debug('Adding cached content', n), x.loadOnce || (x.evaluateScripts == 'once' ? b.update.content(t, i, !1) : b.update.content(t, i)), x.onLoad.call(o[0], t, v, y)) : s ? (b.set.loading(t), b.debug('Content is already loading', n)) : E.api !== D ? (e = E.extend(!0, {}, x.apiSettings, a), b.debug('Retrieving remote content', n, e), b.set.loading(t), o.api(e)) : b.error(S.api);
          },
        },
        activate: { all(e) { b.activate.tab(e), b.activate.navigation(e); }, tab(e) { const t = b.get.tabElement(e); const n = x.deactivate == 'siblings' ? t.siblings(a) : a.not(t); const i = t.hasClass(C.active); b.verbose('Showing tab content for', t), i || (t.addClass(C.active), n.removeClass(`${C.active} ${C.loading}`), t.length > 0 && x.onVisible.call(t[0], e)); }, navigation(e) { const t = b.get.navElement(e); const n = x.deactivate == 'siblings' ? t.siblings(u) : u.not(t); const i = t.hasClass(C.active); b.verbose('Activating tab navigation for', t, e), i || (t.addClass(C.active), n.removeClass(`${C.active} ${C.loading}`)); } },
        deactivate: { all() { b.deactivate.navigation(), b.deactivate.tabs(); }, navigation() { u.removeClass(C.active); }, tabs() { a.removeClass(`${C.active} ${C.loading}`); } },
        is: { tab(e) { return e !== D && b.get.tabElement(e).length > 0; } },
        get: {
          initialPath() { return u.eq(0).data(w.tab) || a.eq(0).data(w.tab); }, path() { return E.address.value(); }, defaultPathArray(e) { return b.utilities.pathToArray(b.get.defaultPath(e)); }, defaultPath(e) { const t = u.filter(`[data-${w.tab}^="${e}/"]`).eq(0).data(w.tab) || !1; if (t) { if (b.debug('Found default tab', t), o < x.maxDepth) return o++, b.get.defaultPath(t); b.error(S.recursion); } else b.debug('No default tabs found for', e, a); return o = 0, e; }, navElement(e) { return e = e || h, u.filter(`[data-${w.tab}="${e}"]`); }, tabElement(e) { let t; let n; let i; let o; return e = e || h, i = b.utilities.pathToArray(e), o = b.utilities.last(i), t = a.filter(`[data-${w.tab}="${e}"]`), n = a.filter(`[data-${w.tab}="${o}"]`), t.length > 0 ? t : n; }, tab() { return h; },
        },
        utilities: {
          filterArray(e, t) { return E.grep(e, (e) => E.inArray(e, t) == -1); }, last(e) { return !!E.isArray(e) && e[e.length - 1]; }, pathToArray(e) { return e === D && (e = h), typeof e === 'string' ? e.split('/') : [e]; }, arrayToPath(e) { return !!E.isArray(e) && e.join('/'); },
        },
        setting(e, t) { if (b.debug('Changing setting', e, t), E.isPlainObject(e))E.extend(!0, x, e); else { if (t === D) return x[e]; E.isPlainObject(x[e]) ? E.extend(!0, x[e], t) : x[e] = t; } },
        internal(e, t) { if (E.isPlainObject(e))E.extend(!0, b, e); else { if (t === D) return b[e]; b[e] = t; } },
        debug() { !x.silent && x.debug && (x.performance ? b.performance.log(arguments) : (b.debug = Function.prototype.bind.call(console.info, console, `${x.name}:`), b.debug.apply(console, arguments))); },
        verbose() { !x.silent && x.verbose && x.debug && (x.performance ? b.performance.log(arguments) : (b.verbose = Function.prototype.bind.call(console.info, console, `${x.name}:`), b.verbose.apply(console, arguments))); },
        error() { x.silent || (b.error = Function.prototype.bind.call(console.error, console, `${x.name}:`), b.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; x.performance && (n = (t = (new Date()).getTime()) - (f || t), f = t, m.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: s, 'Execution Time': n,
            })), clearTimeout(b.performance.timer), b.performance.timer = setTimeout(b.performance.display, 500);
          },
          display() { let e = `${x.name}:`; let n = 0; f = !1, clearTimeout(b.performance.timer), E.each(m, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, d && (e += ` '${d}'`), (console.group !== D || console.table !== D) && m.length > 0 && (console.groupCollapsed(e), console.table ? console.table(m) : E.each(m, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), m = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = l; return e = e || R, t = s || t, typeof i === 'string' && r !== D && (i = i.split(/[\. ]/), o = i.length - 1, E.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (E.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== D) return a = r[n], !1; if (!E.isPlainObject(r[t]) || e == o) return r[t] !== D ? a = r[t] : b.error(S.method, i), !1; r = r[t]; } })), E.isFunction(a) ? n = a.apply(t, e) : a !== D && (n = a), E.isArray(c) ? c.push(n) : c !== D ? c = [c, n] : n !== D && (c = n), a; },
      }, A ? (l === D && b.initialize(), b.invoke(g)) : (l !== D && l.invoke('destroy'), b.initialize());
    }), c !== D ? c : this;
  }, E.tab = function () { E(F).tab.apply(this, arguments); }, E.fn.tab.settings = {
    name: 'Tab',
    namespace: 'tab',
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    auto: !1,
    history: !1,
    historyType: 'hash',
    path: !1,
    context: !1,
    childrenOnly: !1,
    maxDepth: 25,
    deactivate: 'siblings',
    alwaysRefresh: !1,
    cache: !0,
    loadOnce: !1,
    cacheType: 'response',
    ignoreFirstLoad: !1,
    apiSettings: !1,
    evaluateScripts: 'once',
    onFirstLoad(e, t, n) {},
    onLoad(e, t, n) {},
    onVisible(e, t, n) {},
    onRequest(e, t, n) {},
    templates: { determineTitle(e) {} },
    error: {
      api: 'You attempted to load content without API module', method: 'The method you called is not defined', missingTab: 'Activated tab cannot be found. Tabs are case-sensitive.', noContent: 'The tab you specified is missing a content url.', path: 'History enabled, but no path was specified', recursion: 'Max recursive depth reached', legacyInit: 'onTabInit has been renamed to onFirstLoad in 2.0, please adjust your code.', legacyLoad: 'onTabLoad has been renamed to onLoad in 2.0. Please adjust your code', state: "History requires Asual's Address library <https://github.com/asual/jquery-address>",
    },
    metadata: { tab: 'tab', loaded: 'loaded', promise: 'promise' },
    className: { loading: 'loading', active: 'active' },
    selector: { tabs: '.ui.tab', ui: '.ui' },
  };
}(jQuery, window, document)), (function (C, e, w, S) {
  e = void 0 !== e && e.Math == Math ? e : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), C.fn.transition = function () {
    let c; const r = C(this); const g = r.selector || ''; let p = (new Date()).getTime(); let h = []; const v = arguments; const b = v[0]; const y = [].slice.call(arguments, 1); let x = typeof b === 'string'; e.requestAnimationFrame || e.mozRequestAnimationFrame || e.webkitRequestAnimationFrame || e.msRequestAnimationFrame; return r.each(function (i) {
      let u; let s; let t; let d; let n; let o; let e; let a; let f; const m = C(this); const l = this; (f = {
        initialize() { u = f.get.settings.apply(l, v), d = u.className, t = u.error, n = u.metadata, a = `.${u.namespace}`, e = `module-${u.namespace}`, s = m.data(e) || f, o = f.get.animationEndEvent(), x && (x = f.invoke(b)), !1 === x && (f.verbose('Converted arguments into settings object', u), u.interval ? f.delay(u.animate) : f.animate(), f.instantiate()); },
        instantiate() { f.verbose('Storing instance of module', f), s = f, m.data(e, s); },
        destroy() { f.verbose('Destroying previous module for', l), m.removeData(e); },
        refresh() { f.verbose('Refreshing display type on next animation'), delete f.displayType; },
        forceRepaint() { f.verbose('Forcing element repaint'); const e = m.parent(); const t = m.next(); t.length === 0 ? m.detach().appendTo(e) : m.detach().insertBefore(t); },
        repaint() { f.verbose('Repainting element'); l.offsetWidth; },
        delay(e) { let t; let n = f.get.animationDirection(); n || (n = f.can.transition() ? f.get.direction() : 'static'), e = e !== S ? e : u.interval, t = u.reverse == 'auto' && n == d.outward || u.reverse == 1 ? (r.length - i) * u.interval : i * u.interval, f.debug('Delaying animation by', t), setTimeout(f.animate, t); },
        animate(e) { if (u = e || u, !f.is.supported()) return f.error(t.support), !1; if (f.debug('Preparing animation', u.animation), f.is.animating()) { if (u.queue) return !u.allowRepeats && f.has.direction() && f.is.occurring() && !0 !== f.queuing ? f.debug('Animation is currently occurring, preventing queueing same animation', u.animation) : f.queue(u.animation), !1; if (!u.allowRepeats && f.is.occurring()) return f.debug('Animation is already occurring, will not execute repeated animation', u.animation), !1; f.debug('New animation started, completing previous early', u.animation), s.complete(); }f.can.animate() ? f.set.animating(u.animation) : f.error(t.noAnimation, u.animation, l); },
        reset() { f.debug('Resetting animation to beginning conditions'), f.remove.animationCallbacks(), f.restore.conditions(), f.remove.animating(); },
        queue(e) { f.debug('Queueing animation of', e), f.queuing = !0, m.one(`${o}.queue${a}`, function () { f.queuing = !1, f.repaint(), f.animate.apply(this, u); }); },
        complete(e) { f.debug('Animation complete', u.animation), f.remove.completeCallback(), f.remove.failSafe(), f.is.looping() || (f.is.outward() ? (f.verbose('Animation is outward, hiding element'), f.restore.conditions(), f.hide()) : f.is.inward() ? (f.verbose('Animation is outward, showing element'), f.restore.conditions(), f.show()) : (f.verbose('Static animation completed'), f.restore.conditions(), u.onComplete.call(l))); },
        force: { visible() { const e = m.attr('style'); const t = f.get.userStyle(); const n = f.get.displayType(); const i = `${t}display: ${n} !important;`; const o = m.css('display'); const a = e === S || e === ''; o !== n ? (f.verbose('Overriding default display to show element', n), m.attr('style', i)) : a && m.removeAttr('style'); }, hidden() { const e = m.attr('style'); const t = m.css('display'); const n = e === S || e === ''; t === 'none' || f.is.hidden() ? n && m.removeAttr('style') : (f.verbose('Overriding default display to hide element'), m.css('display', 'none')); } },
        has: { direction(e) { let n = !1; return typeof (e = e || u.animation) === 'string' && (e = e.split(' '), C.each(e, (e, t) => { t !== d.inward && t !== d.outward || (n = !0); })), n; }, inlineDisplay() { const e = m.attr('style') || ''; return C.isArray(e.match(/display.*?;/, '')); } },
        set: {
          animating(e) { let t; f.remove.completeCallback(), e = e || u.animation, t = f.get.animationClass(e), f.save.animation(t), f.force.visible(), f.remove.hidden(), f.remove.direction(), f.start.animation(t); }, duration(e, t) { ((t = typeof (t = t || u.duration) === 'number' ? `${t}ms` : t) || t === 0) && (f.verbose('Setting animation duration', t), m.css({ 'animation-duration': t })); }, direction(e) { (e = e || f.get.direction()) == d.inward ? f.set.inward() : f.set.outward(); }, looping() { f.debug('Transition set to loop'), m.addClass(d.looping); }, hidden() { m.addClass(d.transition).addClass(d.hidden); }, inward() { f.debug('Setting direction to inward'), m.removeClass(d.outward).addClass(d.inward); }, outward() { f.debug('Setting direction to outward'), m.removeClass(d.inward).addClass(d.outward); }, visible() { m.addClass(d.transition).addClass(d.visible); },
        },
        start: { animation(e) { e = e || f.get.animationClass(), f.debug('Starting tween', e), m.addClass(e).one(`${o}.complete${a}`, f.complete), u.useFailSafe && f.add.failSafe(), f.set.duration(u.duration), u.onStart.call(l); } },
        save: { animation(e) { f.cache || (f.cache = {}), f.cache.animation = e; }, displayType(e) { e !== 'none' && m.data(n.displayType, e); }, transitionExists(e, t) { C.fn.transition.exists[e] = t, f.verbose('Saving existence of transition', e, t); } },
        restore: { conditions() { const e = f.get.currentAnimation(); e && (m.removeClass(e), f.verbose('Removing animation class', f.cache)), f.remove.duration(); } },
        add: { failSafe() { const e = f.get.duration(); f.timer = setTimeout(() => { m.triggerHandler(o); }, e + u.failSafeDelay), f.verbose('Adding fail safe timer', f.timer); } },
        remove: {
          animating() { m.removeClass(d.animating); }, animationCallbacks() { f.remove.queueCallback(), f.remove.completeCallback(); }, queueCallback() { m.off(`.queue${a}`); }, completeCallback() { m.off(`.complete${a}`); }, display() { m.css('display', ''); }, direction() { m.removeClass(d.inward).removeClass(d.outward); }, duration() { m.css('animation-duration', ''); }, failSafe() { f.verbose('Removing fail safe timer', f.timer), f.timer && clearTimeout(f.timer); }, hidden() { m.removeClass(d.hidden); }, visible() { m.removeClass(d.visible); }, looping() { f.debug('Transitions are no longer looping'), f.is.looping() && (f.reset(), m.removeClass(d.looping)); }, transition() { m.removeClass(d.visible).removeClass(d.hidden); },
        },
        get: {
          settings(e, t, n) { return typeof e === 'object' ? C.extend(!0, {}, C.fn.transition.settings, e) : typeof n === 'function' ? C.extend({}, C.fn.transition.settings, { animation: e, onComplete: n, duration: t }) : typeof t === 'string' || typeof t === 'number' ? C.extend({}, C.fn.transition.settings, { animation: e, duration: t }) : typeof t === 'object' ? C.extend({}, C.fn.transition.settings, t, { animation: e }) : typeof t === 'function' ? C.extend({}, C.fn.transition.settings, { animation: e, onComplete: t }) : C.extend({}, C.fn.transition.settings, { animation: e }); },
          animationClass(e) { const t = e || u.animation; const n = f.can.transition() && !f.has.direction() ? `${f.get.direction()} ` : ''; return `${d.animating} ${d.transition} ${n}${t}`; },
          currentAnimation() { return !(!f.cache || f.cache.animation === S) && f.cache.animation; },
          currentDirection() { return f.is.inward() ? d.inward : d.outward; },
          direction() { return f.is.hidden() || !f.is.visible() ? d.inward : d.outward; },
          animationDirection(e) { let n; return typeof (e = e || u.animation) === 'string' && (e = e.split(' '), C.each(e, (e, t) => { t === d.inward ? n = d.inward : t === d.outward && (n = d.outward); })), n || !1; },
          duration(e) { return !1 === (e = e || u.duration) && (e = m.css('animation-duration') || 0), typeof e === 'string' ? e.indexOf('ms') > -1 ? parseFloat(e) : 1e3 * parseFloat(e) : e; },
          displayType(e) { return e = e === S || e, u.displayType ? u.displayType : (e && m.data(n.displayType) === S && f.can.transition(!0), m.data(n.displayType)); },
          userStyle(e) { return (e = e || m.attr('style') || '').replace(/display.*?;/, ''); },
          transitionExists(e) { return C.fn.transition.exists[e]; },
          animationStartEvent() {
            let e; const t = w.createElement('div'); const n = {
              animation: 'animationstart', OAnimation: 'oAnimationStart', MozAnimation: 'mozAnimationStart', WebkitAnimation: 'webkitAnimationStart',
            }; for (e in n) if (t.style[e] !== S) return n[e]; return !1;
          },
          animationEndEvent() {
            let e; const t = w.createElement('div'); const n = {
              animation: 'animationend', OAnimation: 'oAnimationEnd', MozAnimation: 'mozAnimationEnd', WebkitAnimation: 'webkitAnimationEnd',
            }; for (e in n) if (t.style[e] !== S) return n[e]; return !1;
          },
        },
        can: {
          transition(e) {
            let t; let n; let i; let o; let a; let r; const s = u.animation; const l = f.get.transitionExists(s); let c = f.get.displayType(!1); if (l === S || e) {
              if (f.verbose('Determining whether animation exists'), t = m.attr('class'), n = m.prop('tagName'), o = (i = C(`<${n} />`).addClass(t).insertAfter(m)).addClass(s).removeClass(d.inward).removeClass(d.outward).addClass(d.animating)
                .addClass(d.transition)
                .css('animationName'), a = i.addClass(d.inward).css('animationName'), c || (c = i.attr('class', t).removeAttr('style').removeClass(d.hidden).removeClass(d.visible)
                .show()
                .css('display'), f.verbose('Determining final display state', c), f.save.displayType(c)), i.remove(), o != a)f.debug('Direction exists for animation', s), r = !0; else { if (o == 'none' || !o) return void f.debug('No animation defined in css', s); f.debug('Static animation found', s, c), r = !1; }f.save.transitionExists(s, r);
            } return l !== S ? l : r;
          },
          animate() { return f.can.transition() !== S; },
        },
        is: {
          animating() { return m.hasClass(d.animating); }, inward() { return m.hasClass(d.inward); }, outward() { return m.hasClass(d.outward); }, looping() { return m.hasClass(d.looping); }, occurring(e) { return e = `.${(e = e || u.animation).replace(' ', '.')}`, m.filter(e).length > 0; }, visible() { return m.is(':visible'); }, hidden() { return m.css('visibility') === 'hidden'; }, supported() { return !1 !== o; },
        },
        hide() { f.verbose('Hiding element'), f.is.animating() && f.reset(), l.blur(), f.remove.display(), f.remove.visible(), f.set.hidden(), f.force.hidden(), u.onHide.call(l), u.onComplete.call(l); },
        show(e) { f.verbose('Showing element', e), f.remove.hidden(), f.set.visible(), f.force.visible(), u.onShow.call(l), u.onComplete.call(l); },
        toggle() { f.is.visible() ? f.hide() : f.show(); },
        stop() { f.debug('Stopping current animation'), m.triggerHandler(o); },
        stopAll() { f.debug('Stopping all animation'), f.remove.queueCallback(), m.triggerHandler(o); },
        clear: { queue() { f.debug('Clearing animation queue'), f.remove.queueCallback(); } },
        enable() { f.verbose('Starting animation'), m.removeClass(d.disabled); },
        disable() { f.debug('Stopping animation'), m.addClass(d.disabled); },
        setting(e, t) { if (f.debug('Changing setting', e, t), C.isPlainObject(e))C.extend(!0, u, e); else { if (t === S) return u[e]; C.isPlainObject(u[e]) ? C.extend(!0, u[e], t) : u[e] = t; } },
        internal(e, t) { if (C.isPlainObject(e))C.extend(!0, f, e); else { if (t === S) return f[e]; f[e] = t; } },
        debug() { !u.silent && u.debug && (u.performance ? f.performance.log(arguments) : (f.debug = Function.prototype.bind.call(console.info, console, `${u.name}:`), f.debug.apply(console, arguments))); },
        verbose() { !u.silent && u.verbose && u.debug && (u.performance ? f.performance.log(arguments) : (f.verbose = Function.prototype.bind.call(console.info, console, `${u.name}:`), f.verbose.apply(console, arguments))); },
        error() { u.silent || (f.error = Function.prototype.bind.call(console.error, console, `${u.name}:`), f.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; u.performance && (n = (t = (new Date()).getTime()) - (p || t), p = t, h.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: l, 'Execution Time': n,
            })), clearTimeout(f.performance.timer), f.performance.timer = setTimeout(f.performance.display, 500);
          },
          display() { let e = `${u.name}:`; let n = 0; p = !1, clearTimeout(f.performance.timer), C.each(h, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, g && (e += ` '${g}'`), r.length > 1 && (e += ` (${r.length})`), (console.group !== S || console.table !== S) && h.length > 0 && (console.groupCollapsed(e), console.table ? console.table(h) : C.each(h, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), h = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = s; return e = e || y, t = l || t, typeof i === 'string' && r !== S && (i = i.split(/[\. ]/), o = i.length - 1, C.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (C.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== S) return a = r[n], !1; if (!C.isPlainObject(r[t]) || e == o) return r[t] !== S && (a = r[t]), !1; r = r[t]; } })), C.isFunction(a) ? n = a.apply(t, e) : a !== S && (n = a), C.isArray(c) ? c.push(n) : c !== S ? c = [c, n] : n !== S && (c = n), a !== S && a; },
      }).initialize();
    }), c !== S ? c : this;
  }, C.fn.transition.exists = {}, C.fn.transition.settings = {
    name: 'Transition',
    silent: !1,
    debug: !1,
    verbose: !1,
    performance: !0,
    namespace: 'transition',
    interval: 0,
    reverse: 'auto',
    onStart() {},
    onComplete() {},
    onShow() {},
    onHide() {},
    useFailSafe: !0,
    failSafeDelay: 100,
    allowRepeats: !1,
    displayType: !1,
    animation: 'fade',
    duration: !1,
    queue: !0,
    metadata: { displayType: 'display' },
    className: {
      animating: 'animating', disabled: 'disabled', hidden: 'hidden', inward: 'in', loading: 'loading', looping: 'looping', outward: 'out', transition: 'transition', visible: 'visible',
    },
    error: {
      noAnimation: 'Element is no longer attached to DOM. Unable to animate.  Use silent setting to surpress this warning in production.', repeated: 'That animation is already occurring, cancelling repeated animation', method: 'The method you called is not defined', support: 'This browser does not support CSS animations',
    },
  };
}(jQuery, window, document)), (function (P, E, e, F) {
  E = void 0 !== E && E.Math == Math ? E : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(); P.api = P.fn.api = function (x) {
    let C; const e = P.isFunction(this) ? P(E) : P(this); const w = e.selector || ''; let S = (new Date()).getTime(); let k = []; const T = x; const A = typeof T === 'string'; const R = [].slice.call(arguments, 1); return e.each(function () {
      let a; let r; let n; let e; let s; let l; const c = P.isPlainObject(x) ? P.extend(!0, {}, P.fn.api.settings, x) : P.extend({}, P.fn.api.settings); const t = c.namespace; const i = c.metadata; const o = c.selector; const u = c.error; const d = c.className; const f = `.${t}`; const m = `module-${t}`; const g = P(this); const p = g.closest(o.form); const h = c.stateContext ? P(c.stateContext) : g; const v = this; const b = h[0]; let y = g.data(m); l = {
        initialize() { A || l.bind.events(), l.instantiate(); },
        instantiate() { l.verbose('Storing instance of module', l), y = l, g.data(m, y); },
        destroy() { l.verbose('Destroying previous module for', v), g.removeData(m).off(f); },
        bind: { events() { const e = l.get.event(); e ? (l.verbose('Attaching API events to element', e), g.on(e + f, l.event.trigger)) : c.on == 'now' && (l.debug('Querying API endpoint immediately'), l.query()); } },
        decode: { json(e) { if (e !== F && typeof e === 'string') try { e = JSON.parse(e); } catch (e) {} return e; } },
        read: { cachedResponse(e) { let t; if (E.Storage !== F) return t = sessionStorage.getItem(e), l.debug('Using cached response', e, t), t = l.decode.json(t); l.error(u.noStorage); } },
        write: { cachedResponse(e, t) { t && t === '' ? l.debug('Response empty, not caching', t) : E.Storage !== F ? (P.isPlainObject(t) && (t = JSON.stringify(t)), sessionStorage.setItem(e, t), l.verbose('Storing cached response for url', e, t)) : l.error(u.noStorage); } },
        query() {
          if (l.is.disabled())l.debug('Element is disabled API request aborted'); else {
            if (l.is.loading()) { if (!c.interruptRequests) return void l.debug('Cancelling request, previous request is still pending'); l.debug('Interrupting previous request'), l.abort(); } if (c.defaultData && P.extend(!0, c.urlData, l.get.defaultData()), c.serializeForm && (c.data = l.add.formData(c.data)), !1 === (r = l.get.settings())) return l.cancelled = !0, void l.error(u.beforeSend); if (l.cancelled = !1, (n = l.get.templatedURL()) || l.is.mocked()) {
              if ((n = l.add.urlData(n)) || l.is.mocked()) {
                if (r.url = c.base + n, a = P.extend(!0, {}, c, {
                  type: c.method || c.type, data: e, url: c.base + n, beforeSend: c.beforeXHR, success() {}, failure() {}, complete() {},
                }), l.debug('Querying URL', a.url), l.verbose('Using AJAX settings', a), c.cache === 'local' && l.read.cachedResponse(n)) return l.debug('Response returned from local cache'), l.request = l.create.request(), void l.request.resolveWith(b, [l.read.cachedResponse(n)]); c.throttle ? c.throttleFirstRequest || l.timer ? (l.debug('Throttling request', c.throttle), clearTimeout(l.timer), l.timer = setTimeout(() => { l.timer && delete l.timer, l.debug('Sending throttled request', e, a.method), l.send.request(); }, c.throttle)) : (l.debug('Sending request', e, a.method), l.send.request(), l.timer = setTimeout(() => {}, c.throttle)) : (l.debug('Sending request', e, a.method), l.send.request());
              }
            } else l.error(u.missingURL);
          }
        },
        should: { removeError() { return !0 === c.hideError || c.hideError === 'auto' && !l.is.form(); } },
        is: {
          disabled() { return g.filter(o.disabled).length > 0; }, expectingJSON() { return c.dataType === 'json' || c.dataType === 'jsonp'; }, form() { return g.is('form') || h.is('form'); }, mocked() { return c.mockResponse || c.mockResponseAsync || c.response || c.responseAsync; }, input() { return g.is('input'); }, loading() { return !!l.request && l.request.state() == 'pending'; }, abortedRequest(e) { return e && e.readyState !== F && e.readyState === 0 ? (l.verbose('XHR request determined to be aborted'), !0) : (l.verbose('XHR request was not aborted'), !1); }, validResponse(e) { return l.is.expectingJSON() && P.isFunction(c.successTest) ? (l.debug('Checking JSON returned success', c.successTest, e), c.successTest(e) ? (l.debug('Response passed success test', e), !0) : (l.debug('Response failed success test', e), !1)) : (l.verbose('Response is not JSON, skipping validation', c.successTest, e), !0); },
        },
        was: {
          cancelled() { return l.cancelled || !1; }, succesful() { return l.request && l.request.state() == 'resolved'; }, failure() { return l.request && l.request.state() == 'rejected'; }, complete() { return l.request && (l.request.state() == 'resolved' || l.request.state() == 'rejected'); },
        },
        add: { urlData(o, a) { let e; let t; return o && (e = o.match(c.regExp.required), t = o.match(c.regExp.optional), a = a || c.urlData, e && (l.debug('Looking for required URL variables', e), P.each(e, (e, t) => { const n = t.indexOf('$') !== -1 ? t.substr(2, t.length - 3) : t.substr(1, t.length - 2); let i = P.isPlainObject(a) && a[n] !== F ? a[n] : g.data(n) !== F ? g.data(n) : h.data(n) !== F ? h.data(n) : a[n]; if (i === F) return l.error(u.requiredParameter, n, o), o = !1; l.verbose('Found required variable', n, i), i = c.encodeParameters ? l.get.urlEncodedValue(i) : i, o = o.replace(t, i); })), t && (l.debug('Looking for optional URL variables', e), P.each(t, (e, t) => { const n = t.indexOf('$') !== -1 ? t.substr(3, t.length - 4) : t.substr(2, t.length - 3); const i = P.isPlainObject(a) && a[n] !== F ? a[n] : g.data(n) !== F ? g.data(n) : h.data(n) !== F ? h.data(n) : a[n]; o = i !== F ? (l.verbose('Optional variable Found', n, i), o.replace(t, i)) : (l.verbose('Optional variable not found', n), o.indexOf(`/${t}`) !== -1 ? o.replace(`/${t}`, '') : o.replace(t, '')); }))), o; }, formData(e) { const t = P.fn.serializeObject !== F; const n = t ? p.serializeObject() : p.serialize(); return e = e || c.data, e = P.isPlainObject(e) ? t ? (l.debug('Extending existing data with form data', e, n), P.extend(!0, {}, e, n)) : (l.error(u.missingSerialize), l.debug('Cant extend data. Replacing data with form data', e, n), n) : (l.debug('Adding form data', n), n); } },
        send: { request() { l.set.loading(), l.request = l.create.request(), l.is.mocked() ? l.mockedXHR = l.create.mockedXHR() : l.xhr = l.create.xhr(), c.onRequest.call(b, l.request, l.xhr); } },
        event: { trigger(e) { l.query(), e.type != 'submit' && e.type != 'click' || e.preventDefault(); }, xhr: { always() {}, done(e, t, n) { const i = this; const o = (new Date()).getTime() - s; let a = c.loadingDuration - o; const r = !!P.isFunction(c.onResponse) && (l.is.expectingJSON() ? c.onResponse.call(i, P.extend(!0, {}, e)) : c.onResponse.call(i, e)); a = a > 0 ? a : 0, r && (l.debug('Modified API response in onResponse callback', c.onResponse, r, e), e = r), a > 0 && l.debug('Response completed early delaying state change by', a), setTimeout(() => { l.is.validResponse(e) ? l.request.resolveWith(i, [e, n]) : l.request.rejectWith(i, [n, 'invalid']); }, a); }, fail(e, t, n) { const i = this; const o = (new Date()).getTime() - s; let a = c.loadingDuration - o; (a = a > 0 ? a : 0) > 0 && l.debug('Response completed early delaying state change by', a), setTimeout(() => { l.is.abortedRequest(e) ? l.request.rejectWith(i, [e, 'aborted', n]) : l.request.rejectWith(i, [e, 'error', t, n]); }, a); } }, request: { done(e, t) { l.debug('Successful API Response', e), c.cache === 'local' && n && (l.write.cachedResponse(n, e), l.debug('Saving server response locally', l.cache)), c.onSuccess.call(b, e, g, t); }, complete(e, t) { let n; let i; l.was.succesful() ? (i = e, n = t) : (n = e, i = l.get.responseFromXHR(n)), l.remove.loading(), c.onComplete.call(b, i, g, n); }, fail(e, t, n) { const i = l.get.responseFromXHR(e); const o = l.get.errorFromRequest(i, t, n); if (t == 'aborted') return l.debug('XHR Aborted (Most likely caused by page navigation or CORS Policy)', t, n), c.onAbort.call(b, t, g, e), !0; t == 'invalid' ? l.debug('JSON did not pass success test. A server-side error has most likely occurred', i) : t == 'error' && e !== F && (l.debug('XHR produced a server error', t, n), e.status != 200 && n !== F && n !== '' && l.error(u.statusMessage + n, a.url), c.onError.call(b, o, g, e)), c.errorDuration && t !== 'aborted' && (l.debug('Adding error state'), l.set.error(), l.should.removeError() && setTimeout(l.remove.error, c.errorDuration)), l.debug('API Request failed', o, e), c.onFailure.call(b, i, g, e); } } },
        create: { request() { return P.Deferred().always(l.event.request.complete).done(l.event.request.done).fail(l.event.request.fail); }, mockedXHR() { let e; let t; let n; const i = c.mockResponse || c.response; const o = c.mockResponseAsync || c.responseAsync; return n = P.Deferred().always(l.event.xhr.complete).done(l.event.xhr.done).fail(l.event.xhr.fail), i ? (t = P.isFunction(i) ? (l.debug('Using specified synchronous callback', i), i.call(b, r)) : (l.debug('Using settings specified response', i), i), n.resolveWith(b, [t, !1, { responseText: t }])) : P.isFunction(o) && (e = function (e) { l.debug('Async callback returned response', e), e ? n.resolveWith(b, [e, !1, { responseText: e }]) : n.rejectWith(b, [{ responseText: e }, !1, !1]); }, l.debug('Using specified async response callback', o), o.call(b, r, e)), n; }, xhr() { let e; return e = P.ajax(a).always(l.event.xhr.always).done(l.event.xhr.done).fail(l.event.xhr.fail), l.verbose('Created server request', e, a), e; } },
        set: { error() { l.verbose('Adding error state to element', h), h.addClass(d.error); }, loading() { l.verbose('Adding loading state to element', h), h.addClass(d.loading), s = (new Date()).getTime(); } },
        remove: { error() { l.verbose('Removing error state from element', h), h.removeClass(d.error); }, loading() { l.verbose('Removing loading state from element', h), h.removeClass(d.loading); } },
        get: {
          responseFromXHR(e) { return !!P.isPlainObject(e) && (l.is.expectingJSON() ? l.decode.json(e.responseText) : e.responseText); }, errorFromRequest(e, t, n) { return P.isPlainObject(e) && e.error !== F ? e.error : c.error[t] !== F ? c.error[t] : n; }, request() { return l.request || !1; }, xhr() { return l.xhr || !1; }, settings() { let e; return (e = c.beforeSend.call(b, c)) && (e.success !== F && (l.debug('Legacy success callback detected', e), l.error(u.legacyParameters, e.success), e.onSuccess = e.success), e.failure !== F && (l.debug('Legacy failure callback detected', e), l.error(u.legacyParameters, e.failure), e.onFailure = e.failure), e.complete !== F && (l.debug('Legacy complete callback detected', e), l.error(u.legacyParameters, e.complete), e.onComplete = e.complete)), e === F && l.error(u.noReturnedValue), !1 === e ? e : e !== F ? P.extend(!0, {}, e) : P.extend(!0, {}, c); }, urlEncodedValue(e) { const t = E.decodeURIComponent(e); const n = E.encodeURIComponent(e); return t !== e ? (l.debug('URL value is already encoded, avoiding double encoding', e), e) : (l.verbose('Encoding value using encodeURIComponent', e, n), n); }, defaultData() { const e = {}; return P.isWindow(v) || (l.is.input() ? e.value = g.val() : l.is.form() || (e.text = g.text())), e; }, event() { return P.isWindow(v) || c.on == 'now' ? (l.debug('API called without element, no events attached'), !1) : c.on == 'auto' ? g.is('input') ? v.oninput !== F ? 'input' : v.onpropertychange !== F ? 'propertychange' : 'keyup' : g.is('form') ? 'submit' : 'click' : c.on; }, templatedURL(e) { if (e = e || g.data(i.action) || c.action || !1, n = g.data(i.url) || c.url || !1) return l.debug('Using specified url', n), n; if (e) { if (l.debug('Looking up url for action', e, c.api), c.api[e] === F && !l.is.mocked()) return void l.error(u.missingAction, c.action, c.api); n = c.api[e]; } else l.is.form() && (n = g.attr('action') || h.attr('action') || !1, l.debug('No url or action specified, defaulting to form action', n)); return n; },
        },
        abort() { const e = l.get.xhr(); e && e.state() !== 'resolved' && (l.debug('Cancelling API request'), e.abort()); },
        reset() { l.remove.error(), l.remove.loading(); },
        setting(e, t) { if (l.debug('Changing setting', e, t), P.isPlainObject(e))P.extend(!0, c, e); else { if (t === F) return c[e]; P.isPlainObject(c[e]) ? P.extend(!0, c[e], t) : c[e] = t; } },
        internal(e, t) { if (P.isPlainObject(e))P.extend(!0, l, e); else { if (t === F) return l[e]; l[e] = t; } },
        debug() { !c.silent && c.debug && (c.performance ? l.performance.log(arguments) : (l.debug = Function.prototype.bind.call(console.info, console, `${c.name}:`), l.debug.apply(console, arguments))); },
        verbose() { !c.silent && c.verbose && c.debug && (c.performance ? l.performance.log(arguments) : (l.verbose = Function.prototype.bind.call(console.info, console, `${c.name}:`), l.verbose.apply(console, arguments))); },
        error() { c.silent || (l.error = Function.prototype.bind.call(console.error, console, `${c.name}:`), l.error.apply(console, arguments)); },
        performance: { log(e) { let t; let n; c.performance && (n = (t = (new Date()).getTime()) - (S || t), S = t, k.push({ Name: e[0], Arguments: [].slice.call(e, 1) || '', 'Execution Time': n })), clearTimeout(l.performance.timer), l.performance.timer = setTimeout(l.performance.display, 500); }, display() { let e = `${c.name}:`; let n = 0; S = !1, clearTimeout(l.performance.timer), P.each(k, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, w && (e += ` '${w}'`), (console.group !== F || console.table !== F) && k.length > 0 && (console.groupCollapsed(e), console.table ? console.table(k) : P.each(k, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), k = []; } },
        invoke(i, e, t) { let o; let a; let n; let r = y; return e = e || R, t = v || t, typeof i === 'string' && r !== F && (i = i.split(/[\. ]/), o = i.length - 1, P.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (P.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== F) return a = r[n], !1; if (!P.isPlainObject(r[t]) || e == o) return r[t] !== F ? a = r[t] : l.error(u.method, i), !1; r = r[t]; } })), P.isFunction(a) ? n = a.apply(t, e) : a !== F && (n = a), P.isArray(C) ? C.push(n) : C !== F ? C = [C, n] : n !== F && (C = n), a; },
      }, A ? (y === F && l.initialize(), l.invoke(T)) : (y !== F && y.invoke('destroy'), l.initialize());
    }), C !== F ? C : this;
  }, P.api.settings = {
    name: 'API',
    namespace: 'api',
    debug: !1,
    verbose: !1,
    performance: !0,
    api: {},
    cache: !0,
    interruptRequests: !0,
    on: 'auto',
    stateContext: !1,
    loadingDuration: 0,
    hideError: 'auto',
    errorDuration: 2e3,
    encodeParameters: !0,
    action: !1,
    url: !1,
    base: '',
    urlData: {},
    defaultData: !0,
    serializeForm: !1,
    throttle: 0,
    throttleFirstRequest: !0,
    method: 'get',
    data: {},
    dataType: 'json',
    mockResponse: !1,
    mockResponseAsync: !1,
    response: !1,
    responseAsync: !1,
    beforeSend(e) { return e; },
    beforeXHR(e) {},
    onRequest(e, t) {},
    onResponse: !1,
    onSuccess(e, t) {},
    onComplete(e, t) {},
    onFailure(e, t) {},
    onError(e, t) {},
    onAbort(e, t) {},
    successTest: !1,
    error: {
      beforeSend: 'The before send function has aborted the request', error: 'There was an error with your request', exitConditions: 'API Request Aborted. Exit conditions met', JSONParse: 'JSON could not be parsed during error handling', legacyParameters: 'You are using legacy API success callback names', method: 'The method you called is not defined', missingAction: 'API action used but no url was defined', missingSerialize: 'jquery-serialize-object is required to add form data to an existing data object', missingURL: 'No URL specified for api event', noReturnedValue: 'The beforeSend callback must return a settings object, beforeSend ignored.', noStorage: 'Caching responses locally requires session storage', parseError: 'There was an error parsing your request', requiredParameter: 'Missing a required URL parameter: ', statusMessage: 'Server gave an error: ', timeout: 'Your request timed out',
    },
    regExp: { required: /\{\$*[A-z0-9]+\}/g, optional: /\{\/\$*[A-z0-9]+\}/g },
    className: { loading: 'loading', error: 'error' },
    selector: { disabled: '.disabled', form: 'form' },
    metadata: { action: 'action', url: 'url' },
  };
}(jQuery, window, document)), (function (P, E, F, O) {
  E = void 0 !== E && E.Math == Math ? E : typeof self !== 'undefined' && self.Math == Math ? self : Function('return this')(), P.fn.visibility = function (b) {
    let y; const e = P(this); const x = e.selector || ''; let C = (new Date()).getTime(); let w = []; const S = b; const k = typeof S === 'string'; const T = [].slice.call(arguments, 1); const A = e.length; let R = 0; return e.each(function () {
      let e; let t; let n; let s; const o = P.isPlainObject(b) ? P.extend(!0, {}, P.fn.visibility.settings, b) : P.extend({}, P.fn.visibility.settings); const i = o.className; const a = o.namespace; const l = o.error; const r = o.metadata; const c = `.${a}`; const u = `module-${a}`; const d = P(E); const f = P(this); const m = P(o.context); let g = (f.selector, f.data(u)); const p = E.requestAnimationFrame || E.mozRequestAnimationFrame || E.webkitRequestAnimationFrame || E.msRequestAnimationFrame || function (e) { setTimeout(e, 0); }; const h = this; let v = !1; s = {
        initialize() { s.debug('Initializing', o), s.setup.cache(), s.should.trackChanges() && (o.type == 'image' && s.setup.image(), o.type == 'fixed' && s.setup.fixed(), o.observeChanges && s.observeChanges(), s.bind.events()), s.save.position(), s.is.visible() || s.error(l.visible, f), o.initialCheck && s.checkVisibility(), s.instantiate(); },
        instantiate() { s.debug('Storing instance', s), f.data(u, s), g = s; },
        destroy() { s.verbose('Destroying previous module'), n && n.disconnect(), t && t.disconnect(), d.off(`load${c}`, s.event.load).off(`resize${c}`, s.event.resize), m.off(`scroll${c}`, s.event.scroll).off(`scrollchange${c}`, s.event.scrollchange), o.type == 'fixed' && (s.resetFixed(), s.remove.placeholder()), f.off(c).removeData(u); },
        observeChanges() { 'MutationObserver' in E && (t = new MutationObserver(s.event.contextChanged), n = new MutationObserver(s.event.changed), t.observe(F, { childList: !0, subtree: !0 }), n.observe(h, { childList: !0, subtree: !0 }), s.debug('Setting up mutation observer', n)); },
        bind: { events() { s.verbose('Binding visibility events to scroll and resize'), o.refreshOnLoad && d.on(`load${c}`, s.event.load), d.on(`resize${c}`, s.event.resize), m.off(`scroll${c}`).on(`scroll${c}`, s.event.scroll).on(`scrollchange${c}`, s.event.scrollchange); } },
        event: {
          changed(e) { s.verbose('DOM tree modified, updating visibility calculations'), s.timer = setTimeout(() => { s.verbose('DOM tree modified, updating sticky menu'), s.refresh(); }, 100); }, contextChanged(e) { [].forEach.call(e, (e) => { e.removedNodes && [].forEach.call(e.removedNodes, (e) => { (e == h || P(e).find(h).length > 0) && (s.debug('Element removed from DOM, tearing down events'), s.destroy()); }); }); }, resize() { s.debug('Window resized'), o.refreshOnResize && p(s.refresh); }, load() { s.debug('Page finished loading'), p(s.refresh); }, scroll() { o.throttle ? (clearTimeout(s.timer), s.timer = setTimeout(() => { m.triggerHandler(`scrollchange${c}`, [m.scrollTop()]); }, o.throttle)) : p(() => { m.triggerHandler(`scrollchange${c}`, [m.scrollTop()]); }); }, scrollchange(e, t) { s.checkVisibility(t); },
        },
        precache(e, t) { e instanceof Array || (e = [e]); for (var n = e.length, i = 0, o = [], a = F.createElement('img'), r = function () { ++i >= e.length && P.isFunction(t) && t(); }; n--;)(a = F.createElement('img')).onload = r, a.onerror = r, a.src = e[n], o.push(a); },
        enableCallbacks() { s.debug('Allowing callbacks to occur'), v = !1; },
        disableCallbacks() { s.debug('Disabling all callbacks temporarily'), v = !0; },
        should: { trackChanges() { return k ? (s.debug('One time query, no need to bind events'), !1) : (s.debug('Callbacks being attached'), !0); } },
        setup: { cache() { s.cache = { occurred: {}, screen: {}, element: {} }; }, image() { const e = f.data(r.src); e && (s.verbose('Lazy loading image', e), o.once = !0, o.observeChanges = !1, o.onOnScreen = function () { s.debug('Image on screen', h), s.precache(e, () => { s.set.image(e, function () { ++R == A && o.onAllLoaded.call(this), o.onLoad.call(this); }); }); }); }, fixed() { s.debug('Setting up fixed'), o.once = !1, o.observeChanges = !1, o.initialCheck = !0, o.refreshOnLoad = !0, b.transition || (o.transition = !1), s.create.placeholder(), s.debug('Added placeholder', e), o.onTopPassed = function () { s.debug('Element passed, adding fixed position', f), s.show.placeholder(), s.set.fixed(), o.transition && P.fn.transition !== O && f.transition(o.transition, o.duration); }, o.onTopPassedReverse = function () { s.debug('Element returned to position, removing fixed', f), s.hide.placeholder(), s.remove.fixed(); }; } },
        create: { placeholder() { s.verbose('Creating fixed position placeholder'), e = f.clone(!1).css('display', 'none').addClass(i.placeholder).insertAfter(f); } },
        show: { placeholder() { s.verbose('Showing placeholder'), e.css('display', 'block').css('visibility', 'hidden'); } },
        hide: { placeholder() { s.verbose('Hiding placeholder'), e.css('display', 'none').css('visibility', ''); } },
        set: {
          fixed() {
            s.verbose('Setting element to fixed position'), f.addClass(i.fixed).css({
              position: 'fixed', top: `${o.offset}px`, left: 'auto', zIndex: o.zIndex,
            }), o.onFixed.call(h);
          },
          image(e, t) { if (f.attr('src', e), o.transition) if (P.fn.transition !== O) { if (f.hasClass(i.visible)) return void s.debug('Transition already occurred on this image, skipping animation'); f.transition(o.transition, o.duration, t); } else f.fadeIn(o.duration, t); else f.show(); },
        },
        is: {
          onScreen() { return s.get.elementCalculations().onScreen; }, offScreen() { return s.get.elementCalculations().offScreen; }, visible() { return !(!s.cache || !s.cache.element) && !(s.cache.element.width === 0 && s.cache.element.offset.top === 0); }, verticallyScrollableContext() { const e = m.get(0) !== E && m.css('overflow-y'); return e == 'auto' || e == 'scroll'; }, horizontallyScrollableContext() { const e = m.get(0) !== E && m.css('overflow-x'); return e == 'auto' || e == 'scroll'; },
        },
        refresh() { s.debug('Refreshing constants (width/height)'), o.type == 'fixed' && s.resetFixed(), s.reset(), s.save.position(), o.checkOnRefresh && s.checkVisibility(), o.onRefresh.call(h); },
        resetFixed() { s.remove.fixed(), s.remove.occurred(); },
        reset() { s.verbose('Resetting all cached values'), P.isPlainObject(s.cache) && (s.cache.screen = {}, s.cache.element = {}); },
        checkVisibility(e) { s.verbose('Checking visibility of element', s.cache.element), !v && s.is.visible() && (s.save.scroll(e), s.save.calculations(), s.passed(), s.passingReverse(), s.topVisibleReverse(), s.bottomVisibleReverse(), s.topPassedReverse(), s.bottomPassedReverse(), s.onScreen(), s.offScreen(), s.passing(), s.topVisible(), s.bottomVisible(), s.topPassed(), s.bottomPassed(), o.onUpdate && o.onUpdate.call(h, s.get.elementCalculations())); },
        passed(e, t) { const n = s.get.elementCalculations(); if (e && t)o.onPassed[e] = t; else { if (e !== O) return s.get.pixelsPassed(e) > n.pixelsPassed; n.passing && P.each(o.onPassed, (e, t) => { n.bottomVisible || n.pixelsPassed > s.get.pixelsPassed(e) ? s.execute(t, e) : o.once || s.remove.occurred(t); }); } },
        onScreen(e) { const t = s.get.elementCalculations(); const n = e || o.onOnScreen; const i = 'onScreen'; if (e && (s.debug('Adding callback for onScreen', e), o.onOnScreen = e), t.onScreen ? s.execute(n, i) : o.once || s.remove.occurred(i), e !== O) return t.onOnScreen; },
        offScreen(e) { const t = s.get.elementCalculations(); const n = e || o.onOffScreen; const i = 'offScreen'; if (e && (s.debug('Adding callback for offScreen', e), o.onOffScreen = e), t.offScreen ? s.execute(n, i) : o.once || s.remove.occurred(i), e !== O) return t.onOffScreen; },
        passing(e) { const t = s.get.elementCalculations(); const n = e || o.onPassing; const i = 'passing'; if (e && (s.debug('Adding callback for passing', e), o.onPassing = e), t.passing ? s.execute(n, i) : o.once || s.remove.occurred(i), e !== O) return t.passing; },
        topVisible(e) { const t = s.get.elementCalculations(); const n = e || o.onTopVisible; const i = 'topVisible'; if (e && (s.debug('Adding callback for top visible', e), o.onTopVisible = e), t.topVisible ? s.execute(n, i) : o.once || s.remove.occurred(i), e === O) return t.topVisible; },
        bottomVisible(e) { const t = s.get.elementCalculations(); const n = e || o.onBottomVisible; const i = 'bottomVisible'; if (e && (s.debug('Adding callback for bottom visible', e), o.onBottomVisible = e), t.bottomVisible ? s.execute(n, i) : o.once || s.remove.occurred(i), e === O) return t.bottomVisible; },
        topPassed(e) { const t = s.get.elementCalculations(); const n = e || o.onTopPassed; const i = 'topPassed'; if (e && (s.debug('Adding callback for top passed', e), o.onTopPassed = e), t.topPassed ? s.execute(n, i) : o.once || s.remove.occurred(i), e === O) return t.topPassed; },
        bottomPassed(e) { const t = s.get.elementCalculations(); const n = e || o.onBottomPassed; const i = 'bottomPassed'; if (e && (s.debug('Adding callback for bottom passed', e), o.onBottomPassed = e), t.bottomPassed ? s.execute(n, i) : o.once || s.remove.occurred(i), e === O) return t.bottomPassed; },
        passingReverse(e) { const t = s.get.elementCalculations(); const n = e || o.onPassingReverse; const i = 'passingReverse'; if (e && (s.debug('Adding callback for passing reverse', e), o.onPassingReverse = e), t.passing ? o.once || s.remove.occurred(i) : s.get.occurred('passing') && s.execute(n, i), e !== O) return !t.passing; },
        topVisibleReverse(e) { const t = s.get.elementCalculations(); const n = e || o.onTopVisibleReverse; const i = 'topVisibleReverse'; if (e && (s.debug('Adding callback for top visible reverse', e), o.onTopVisibleReverse = e), t.topVisible ? o.once || s.remove.occurred(i) : s.get.occurred('topVisible') && s.execute(n, i), e === O) return !t.topVisible; },
        bottomVisibleReverse(e) { const t = s.get.elementCalculations(); const n = e || o.onBottomVisibleReverse; const i = 'bottomVisibleReverse'; if (e && (s.debug('Adding callback for bottom visible reverse', e), o.onBottomVisibleReverse = e), t.bottomVisible ? o.once || s.remove.occurred(i) : s.get.occurred('bottomVisible') && s.execute(n, i), e === O) return !t.bottomVisible; },
        topPassedReverse(e) { const t = s.get.elementCalculations(); const n = e || o.onTopPassedReverse; const i = 'topPassedReverse'; if (e && (s.debug('Adding callback for top passed reverse', e), o.onTopPassedReverse = e), t.topPassed ? o.once || s.remove.occurred(i) : s.get.occurred('topPassed') && s.execute(n, i), e === O) return !t.onTopPassed; },
        bottomPassedReverse(e) { const t = s.get.elementCalculations(); const n = e || o.onBottomPassedReverse; const i = 'bottomPassedReverse'; if (e && (s.debug('Adding callback for bottom passed reverse', e), o.onBottomPassedReverse = e), t.bottomPassed ? o.once || s.remove.occurred(i) : s.get.occurred('bottomPassed') && s.execute(n, i), e === O) return !t.bottomPassed; },
        execute(e, t) { const n = s.get.elementCalculations(); const i = s.get.screenCalculations(); (e = e || !1) && (o.continuous ? (s.debug('Callback being called continuously', t, n), e.call(h, n, i)) : s.get.occurred(t) || (s.debug('Conditions met', t, n), e.call(h, n, i))), s.save.occurred(t); },
        remove: {
          fixed() {
            s.debug('Removing fixed position'), f.removeClass(i.fixed).css({
              position: '', top: '', left: '', zIndex: '',
            }), o.onUnfixed.call(h);
          },
          placeholder() { s.debug('Removing placeholder content'), e && e.remove(); },
          occurred(e) { if (e) { const t = s.cache.occurred; t[e] !== O && !0 === t[e] && (s.debug('Callback can now be called again', e), s.cache.occurred[e] = !1); } else s.cache.occurred = {}; },
        },
        save: {
          calculations() { s.verbose('Saving all calculations necessary to determine positioning'), s.save.direction(), s.save.screenCalculations(), s.save.elementCalculations(); }, occurred(e) { e && (s.cache.occurred[e] !== O && !0 === s.cache.occurred[e] || (s.verbose('Saving callback occurred', e), s.cache.occurred[e] = !0)); }, scroll(e) { e = e + o.offset || m.scrollTop() + o.offset, s.cache.scroll = e; }, direction() { let e; const t = s.get.scroll(); const n = s.get.lastScroll(); return e = n < t && n ? 'down' : t < n && n ? 'up' : 'static', s.cache.direction = e, s.cache.direction; }, elementPosition() { const e = s.cache.element; const t = s.get.screenSize(); return s.verbose('Saving element position'), e.fits = e.height < t.height, e.offset = f.offset(), e.width = f.outerWidth(), e.height = f.outerHeight(), s.is.verticallyScrollableContext() && (e.offset.top += m.scrollTop() - m.offset().top), s.is.horizontallyScrollableContext() && (e.offset.left += m.scrollLeft - m.offset().left), s.cache.element = e; }, elementCalculations() { const e = s.get.screenCalculations(); const t = s.get.elementPosition(); return o.includeMargin ? (t.margin = {}, t.margin.top = parseInt(f.css('margin-top'), 10), t.margin.bottom = parseInt(f.css('margin-bottom'), 10), t.top = t.offset.top - t.margin.top, t.bottom = t.offset.top + t.height + t.margin.bottom) : (t.top = t.offset.top, t.bottom = t.offset.top + t.height), t.topPassed = e.top >= t.top, t.bottomPassed = e.top >= t.bottom, t.topVisible = e.bottom >= t.top && !t.topPassed, t.bottomVisible = e.bottom >= t.bottom && !t.bottomPassed, t.pixelsPassed = 0, t.percentagePassed = 0, t.onScreen = (t.topVisible || t.passing) && !t.bottomPassed, t.passing = t.topPassed && !t.bottomPassed, t.offScreen = !t.onScreen, t.passing && (t.pixelsPassed = e.top - t.top, t.percentagePassed = (e.top - t.top) / t.height), s.cache.element = t, s.verbose('Updated element calculations', t), t; }, screenCalculations() { const e = s.get.scroll(); return s.save.direction(), s.cache.screen.top = e, s.cache.screen.bottom = e + s.cache.screen.height, s.cache.screen; }, screenSize() { s.verbose('Saving window position'), s.cache.screen = { height: m.height() }; }, position() { s.save.screenSize(), s.save.elementPosition(); },
        },
        get: {
          pixelsPassed(e) { const t = s.get.elementCalculations(); return e.search('%') > -1 ? t.height * (parseInt(e, 10) / 100) : parseInt(e, 10); }, occurred(e) { return s.cache.occurred !== O && s.cache.occurred[e] || !1; }, direction() { return s.cache.direction === O && s.save.direction(), s.cache.direction; }, elementPosition() { return s.cache.element === O && s.save.elementPosition(), s.cache.element; }, elementCalculations() { return s.cache.element === O && s.save.elementCalculations(), s.cache.element; }, screenCalculations() { return s.cache.screen === O && s.save.screenCalculations(), s.cache.screen; }, screenSize() { return s.cache.screen === O && s.save.screenSize(), s.cache.screen; }, scroll() { return s.cache.scroll === O && s.save.scroll(), s.cache.scroll; }, lastScroll() { return s.cache.screen === O ? (s.debug('First scroll event, no last scroll could be found'), !1) : s.cache.screen.top; },
        },
        setting(e, t) { if (P.isPlainObject(e))P.extend(!0, o, e); else { if (t === O) return o[e]; o[e] = t; } },
        internal(e, t) { if (P.isPlainObject(e))P.extend(!0, s, e); else { if (t === O) return s[e]; s[e] = t; } },
        debug() { !o.silent && o.debug && (o.performance ? s.performance.log(arguments) : (s.debug = Function.prototype.bind.call(console.info, console, `${o.name}:`), s.debug.apply(console, arguments))); },
        verbose() { !o.silent && o.verbose && o.debug && (o.performance ? s.performance.log(arguments) : (s.verbose = Function.prototype.bind.call(console.info, console, `${o.name}:`), s.verbose.apply(console, arguments))); },
        error() { o.silent || (s.error = Function.prototype.bind.call(console.error, console, `${o.name}:`), s.error.apply(console, arguments)); },
        performance: {
          log(e) {
            let t; let n; o.performance && (n = (t = (new Date()).getTime()) - (C || t), C = t, w.push({
              Name: e[0], Arguments: [].slice.call(e, 1) || '', Element: h, 'Execution Time': n,
            })), clearTimeout(s.performance.timer), s.performance.timer = setTimeout(s.performance.display, 500);
          },
          display() { let e = `${o.name}:`; let n = 0; C = !1, clearTimeout(s.performance.timer), P.each(w, (e, t) => { n += t['Execution Time']; }), e += ` ${n}ms`, x && (e += ` '${x}'`), (console.group !== O || console.table !== O) && w.length > 0 && (console.groupCollapsed(e), console.table ? console.table(w) : P.each(w, (e, t) => { console.log(`${t.Name}: ${t['Execution Time']}ms`); }), console.groupEnd()), w = []; },
        },
        invoke(i, e, t) { let o; let a; let n; let r = g; return e = e || T, t = h || t, typeof i === 'string' && r !== O && (i = i.split(/[\. ]/), o = i.length - 1, P.each(i, (e, t) => { const n = e != o ? t + i[e + 1].charAt(0).toUpperCase() + i[e + 1].slice(1) : i; if (P.isPlainObject(r[n]) && e != o)r = r[n]; else { if (r[n] !== O) return a = r[n], !1; if (!P.isPlainObject(r[t]) || e == o) return r[t] !== O ? a = r[t] : s.error(l.method, i), !1; r = r[t]; } })), P.isFunction(a) ? n = a.apply(t, e) : a !== O && (n = a), P.isArray(y) ? y.push(n) : y !== O ? y = [y, n] : n !== O && (y = n), a; },
      }, k ? (g === O && s.initialize(), g.save.scroll(), g.save.calculations(), s.invoke(S)) : (g !== O && g.invoke('destroy'), s.initialize());
    }), y !== O ? y : this;
  }, P.fn.visibility.settings = {
    name: 'Visibility', namespace: 'visibility', debug: !1, verbose: !1, performance: !0, observeChanges: !0, initialCheck: !0, refreshOnLoad: !0, refreshOnResize: !0, checkOnRefresh: !0, once: !0, continuous: !1, offset: 0, includeMargin: !1, context: E, throttle: !1, type: !1, zIndex: '10', transition: 'fade in', duration: 1e3, onPassed: {}, onOnScreen: !1, onOffScreen: !1, onPassing: !1, onTopVisible: !1, onBottomVisible: !1, onTopPassed: !1, onBottomPassed: !1, onPassingReverse: !1, onTopVisibleReverse: !1, onBottomVisibleReverse: !1, onTopPassedReverse: !1, onBottomPassedReverse: !1, onLoad() {}, onAllLoaded() {}, onFixed() {}, onUnfixed() {}, onUpdate: !1, onRefresh() {}, metadata: { src: 'src' }, className: { fixed: 'fixed', placeholder: 'placeholder', visible: 'visible' }, error: { method: 'The method you called is not defined.', visible: 'Element is hidden, you must call refresh after element becomes visible' },
  };
}(jQuery, window, document));
